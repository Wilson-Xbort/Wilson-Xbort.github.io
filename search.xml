<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>尾置返回类型</title>
    <url>/2022/06/30/Trailing-return-type/</url>
    <content><![CDATA[<h3 id="C-Primer-第五版-第六章-P221-P224">C++ Primer 第五版 第六章 P221~P224</h3>
<blockquote>
<p>函数指针P221</p>
</blockquote>
<p><img src="/2022/06/30/Trailing-return-type/screen_img1.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img2.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img3.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img4.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img5.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img6.PNG" alt></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 类型别名</span><br><span class="line">typedef string str_arr[10];</span><br><span class="line">str_arr&amp; fun();</span><br><span class="line"></span><br><span class="line">// 尾置返回类型</span><br><span class="line">auto fun()-&gt;string(&amp;)[10];</span><br><span class="line"></span><br><span class="line">// 使用decltype关键字</span><br><span class="line">string s[10];</span><br><span class="line">decltype(s)&amp; fun();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>简单的示例：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">// print containers like vector, deque, list, etc.</span><br><span class="line">// 可以看到这里也使用了尾置返回类型，但是由于类型并非是函数类型，因此没有那么复杂</span><br><span class="line">template&lt;typename Sequence&gt;</span><br><span class="line">auto println(Sequence const&amp; seq) -&gt; std::ostream&amp;</span><br><span class="line">&#123;</span><br><span class="line">    for (auto const&amp; elem : seq) </span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;;</span><br><span class="line">    return std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto eliminate_duplicates(std::vector&lt;std::string&gt; &amp;vs) -&gt; std::vector&lt;std::string&gt;&amp;</span><br><span class="line">&#123;</span><br><span class="line">    std::sort(vs.begin(), vs.end());</span><br><span class="line">    println(vs);</span><br><span class="line"></span><br><span class="line">    auto new_end = std::unique(vs.begin(), vs.end());</span><br><span class="line">    println(vs);</span><br><span class="line"></span><br><span class="line">    vs.erase(new_end, vs.end());</span><br><span class="line">    return vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vs&#123; &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;s&quot;, &quot;v&quot;, &quot;a&quot;, &quot;a&quot; &#125;;</span><br><span class="line">    println(vs);</span><br><span class="line">    println(eliminate_duplicates(vs));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试工具的简单使用</title>
    <url>/2022/07/03/Use-of-performance-test-tools/</url>
    <content><![CDATA[<h2 id="下载工具：">下载工具：</h2>
<table>
<thead>
<tr>
<th><img src="/2022/07/03/Use-of-performance-test-tools/uoptt_icon1.PNG" alt="virtual User Generator"></th>
<th><img src="/2022/07/03/Use-of-performance-test-tools/uoptt_icon2.PNG" alt="controller"></th>
<th><img src="/2022/07/03/Use-of-performance-test-tools/uoptt_icon3.PNG" alt="Analysis"></th>
</tr>
</thead>
</table>
<h2 id="打开virtual-User-Generator：">打开virtual User Generator：</h2>
<ol>
<li>点击录制按钮，选择协议<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img1.png" alt><br>
2.在高级选项中选择明确包含url的脚本<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img2.png" alt><br>
3.点击开始录制后就会进入你所写的url链接，结束后就可以看到Action的代码<br>
4.可以点击<em>设计工作室</em>进行关联<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img3.png" alt><br>
5.点击运行，看到为√的时候就成功了<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img4.png" alt></li>
</ol>
<h2 id="打开controller：">打开controller：</h2>
<p>1.选择脚本<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img5.png" alt><br>
2.进行设置，在基本计划下可以设置用户数量<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img6.png" alt><br>
3.点击运行时设置，可以将自动事务的勾选去掉<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img7.png" alt><br>
4.设置全部完成后可以运行<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img8.png" alt><br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img9.png" alt><br>
5.点击结果-&gt;分析结果<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img10.png" alt><br>
将会自动打开<em>Analysis</em>显示结果</p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>basic_algorithm</title>
    <url>/2022/07/01/basic-algorithm/</url>
    <content><![CDATA[<h3 id="二分查找：">二分查找：</h3>
<p><img src="/2022/07/01/basic-algorithm/binary_search_img3.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/binary_search_img2.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/binary_search_img1.PNG" alt></p>
<h4 id="核心思路：">核心思路：</h4>
<pre><code>-&gt;middle
-&gt;求左边界和右边界之和的平均值,使用此值为下标作为比较的参数
</code></pre>
<h4 id="代码：">代码：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.size() - 1;</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            int mid = (right - left) / 2 + left;</span><br><span class="line">            int num = nums[mid];</span><br><span class="line">            if (num == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (num &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="参考链接：">参考链接：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://leetcode.cn/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="双指针：">双指针：</h3>
<h4 id="核心思路：-2">核心思路：</h4>
<pre><code>-&gt;使用两个指针分别指向位置 p0 和 p1，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针
-&gt;双指针也不一定非得一个指向头，一个指向尾
</code></pre>
<h4 id="例题：">例题：</h4>
<p><img src="/2022/07/01/basic-algorithm/three_algorithm.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/three_algorithm1.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/three_algorithm2.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/three_algorithm3.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/three_algorithm4.PNG" alt></p>
<h4 id="参考链接：-2">参考链接：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://leetcode.cn/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="例题2：">例题2：</h4>
<p><img src="/2022/07/01/basic-algorithm/two_pointer_1.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/two_pointer_2.PNG" alt></p>
<h4 id="参考链接：-3">参考链接：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://leetcode.cn/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="例题2：-2">例题2：</h4>
<p><img src="/2022/07/01/basic-algorithm/two_pointer_3.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/two_pointer_4.PNG" alt></p>
<h4 id="参考链接：-4">参考链接：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        int low = 0, high = numbers.length - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int sum = numbers[low] + numbers[high];</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                return new int[]&#123;low + 1, high + 1&#125;;</span><br><span class="line">            &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                ++low;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="滑动窗口：">滑动窗口：</h3>
<h4 id="例题1：">例题1：</h4>
<p><img src="/2022/07/01/basic-algorithm/sliding_window_2.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/sliding_window_1.PNG" alt></p>
<h4 id="代码：-2">代码：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        // 哈希集合，记录每个字符是否出现过</span><br><span class="line">        unordered_set&lt;char&gt; occ;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br><span class="line">        int rk = -1, ans = 0;</span><br><span class="line">        // 枚举左指针的位置，初始值隐性地表示为 -1</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (i != 0) &#123;</span><br><span class="line">                // 左指针向右移动一格，移除一个字符</span><br><span class="line">                occ.erase(s[i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            while (rk + 1 &lt; n &amp;&amp; !occ.count(s[rk + 1])) &#123;</span><br><span class="line">                // 不断地移动右指针</span><br><span class="line">                occ.insert(s[rk + 1]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            // ☆第 i 到 rk 个字符是一个极长的无重复字符子串</span><br><span class="line">            ans = max(ans, rk - i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="例题2：-3">例题2：</h4>
<h4 id="代码：-3">代码：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool checkInclusion(string s1, string s2) &#123;</span><br><span class="line">        int n1 = s1.size(), n2 = s2.size();</span><br><span class="line">        if(n1 &gt; n2) return false;</span><br><span class="line">        vector&lt;int&gt; cnt1(26), cnt2(26);</span><br><span class="line">        for (int i = 0; i &lt; n1; ++i) &#123;</span><br><span class="line">            ++cnt1[s1[i] - &#x27;a&#x27;];</span><br><span class="line">            ++cnt2[s2[i] - &#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        if (cnt1 == cnt2) return true;</span><br><span class="line">        for (int i = n1; i &lt; n2; ++i) &#123;</span><br><span class="line">            ++cnt2[s2[i] - &#x27;a&#x27;];</span><br><span class="line">            // 如果之前没匹配到的话就一定没有这个字符</span><br><span class="line">            --cnt2[s2[i - n1] - &#x27;a&#x27;];</span><br><span class="line">            if (cnt1 == cnt2) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>删除重复元素</title>
    <url>/2022/07/10/delete-duplicate-elements/</url>
    <content><![CDATA[<h3 id="快速入手">快速入手</h3>
<h4 id="代码如下：">代码如下：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void elimdups(std::vector&lt;std::string&gt;&amp; vs)</span><br><span class="line">&#123;</span><br><span class="line">    std::sort(vs.begin(), vs.end());</span><br><span class="line">    auto new_end = std::unique(vs.begin(), vs.end());</span><br><span class="line">    // 删除重复</span><br><span class="line">    vs.erase(new_end, vs.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路：先用std-sort-排序，通过std-unique-将重复元素放入容器末尾，最后擦除">思路：先用std::sort()排序，通过std::unique() 将重复元素放入容器末尾，最后擦除</h4>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>安装</title>
    <url>/2022/05/31/install/</url>
    <content><![CDATA[<h2 id="快速开始-win-下的安装）">快速开始(win 下的安装）</h2>
<h4 id="1-安装node-js-下载长期支持版本-以下为网址">1.安装node.js, 下载长期支持版本, 以下为网址:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://nodejs.cn/download/</span><br></pre></td></tr></table></figure>
<h4 id="2-安装git，以下为网址">2. 安装git，以下为网址:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://git-scm.com/downloads</span><br></pre></td></tr></table></figure>
<h4 id="3-git配置">3. git配置</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;Your email&quot;</span><br><span class="line">git config --global user.name &quot;Your name&quot;</span><br></pre></td></tr></table></figure>
<h4 id="4-创建存放文件夹-such-as-“blog”">4. 创建存放文件夹 such as “blog”</h4>
<h4 id="5-打开cmd-输入">5. 打开cmd, 输入</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h4 id="6-进入github-创建仓库repository">6. 进入github,创建仓库repository</h4>
<h4 id="7-安装插件">7. 安装插件</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<h4 id="8-更改配置文件-config-xml">8. 更改配置文件_config.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/Githubname/Githubname.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<h4 id="1-运行">1.  运行</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h4 id="2-创建博客">2.  创建博客</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;My blog name&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-生成">3.  生成</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h4 id="4-运行服务">4. 运行服务</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h4 id="5-部署">5.部署</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h2 id="遇到deloy错误的解决方案">遇到deloy错误的解决方案</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSSL SSL_read: Connection was reset, errno 10054 ...</span><br></pre></td></tr></table></figure>
<h4 id="1-进入站点根目录删除-deploy-git文件夹-删除git提交内容文件夹）">1. 进入站点根目录删除.deploy_git文件夹(删除git提交内容文件夹）</h4>
<h4 id="2-执行命令">2. 执行命令</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="经验：">经验：</h2>
<h4 id="Hexo可能出现部分图片能加载成功，部分图片加载不出的情况">Hexo可能出现部分图片能加载成功，部分图片加载不出的情况</h4>
<h2 id="解决方案：">解决方案：</h2>
<h4 id="你可以看看是不是图片名称有重名，将图片名称更改至不重复的即可">你可以看看是不是图片名称有重名，将图片名称更改至不重复的即可</h4>
]]></content>
      <tags>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda expression</title>
    <url>/2022/07/11/lambda-expression/</url>
    <content><![CDATA[<h2 id="lambda-介绍：">lambda 介绍：</h2>
<p><img src="/2022/07/11/lambda-expression/lambda_img1.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img2.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img3.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img4.PNG" alt></p>
<blockquote>
<p>find_if：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img5.PNG" alt></p>
<blockquote>
<p>for_each：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img6.PNG" alt></p>
<blockquote>
<p>示例：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img7.PNG" alt></p>
<blockquote>
<p>值捕获 tips： 需要写在函数内部</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img8.PNG" alt></p>
<blockquote>
<p>引用捕获：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img9.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img10.PNG" alt></p>
<blockquote>
<p>隐式捕获：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img11.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img12.PNG" alt></p>
<blockquote>
<p>捕获列表：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img13.PNG" alt></p>
<blockquote>
<p>可变lambda：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img14.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img15.PNG" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>python 每日一报</title>
    <url>/2022/06/30/python-%E6%AF%8F%E6%97%A5%E4%B8%80%E6%8A%A5/</url>
    <content><![CDATA[<h3 id="代码较简单">代码较简单</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.implicitly_wait(10)</span><br><span class="line">driver.get(&#x27;https://id.sspu.edu.cn/cas/login?service=https%3a%2f%2fhsm.sspu.edu.cn%2fselfreport%2fLoginSSO.aspx%3ftargetUrl%3d%7bbase64%7daHR0cHM6Ly9oc20uc3NwdS5lZHUuY24vc2VsZnJlcG9ydC9JbmRleC5hc3B4&#x27;)</span><br><span class="line">driver.find_element(By.ID, &quot;username&quot;).send_keys(&quot;your admin&quot;)</span><br><span class="line">driver.find_element(By.ID, &quot;password&quot;).send_keys(&quot;your password&quot;)</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, &#x27;.submit_button&#x27;).click()</span><br><span class="line">driver.implicitly_wait(10)</span><br><span class="line">driver.find_element(By.XPATH, &quot;/html/body/form/div[6]/ul/li[1]/a/span&quot;).click();</span><br><span class="line"># 报送日期</span><br><span class="line">js=&quot;document.getElementById(&#x27;p1_BaoSRQ-inputEl&#x27;).removeAttribute(&#x27;readonly&#x27;)&quot;</span><br><span class="line">#js = &quot;$(&#x27;input:eq(0)&#x27;).removeAttr(&#x27;readonly&#x27;)&quot;</span><br><span class="line">driver.execute_script(js)</span><br><span class="line">input_datetime = driver.find_element(By.XPATH, &#x27;//*[@id=&quot;p1_BaoSRQ-inputEl&quot;]&#x27;)</span><br><span class="line">input_datetime.clear()</span><br><span class="line">input_datetime.send_keys(&quot;2022-06-23&quot;)</span><br><span class="line"></span><br><span class="line"># 国内</span><br><span class="line">driver.find_element(By.ID, &#x27;p1_TiWen-inputEl&#x27;).send_keys(36.6)</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, &#x27;.f-btn-text&#x27;).click()</span><br><span class="line">time.sleep(1)</span><br><span class="line"># driver.find_element(By.CSS_SELECTOR, &#x27;.f-btn-text&#x27;).click()</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;PyCharm&#x27;)</span><br><span class="line"></span><br><span class="line"># See PyCharm help at https://www.jetbrains.com/help/pycharm/</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Firefox WebDriver, 安装Selenium</title>
    <url>/2022/06/23/webdriver-config/</url>
    <content><![CDATA[<h2 id="1-安装Selenium">1.安装Selenium</h2>
<h4 id="1-1-在Anaconda下">1.1 在Anaconda下</h4>
<p><img src="/2022/06/23/webdriver-config/img1.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install selnium</span><br></pre></td></tr></table></figure>
<p>#查找Python 安装位置</p>
<p><img src="/2022/06/23/webdriver-config/img2.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where Python</span><br></pre></td></tr></table></figure>
<h2 id="2-下载火狐WebDriver">2.下载火狐WebDriver</h2>
<h4 id="2-1-下载">2.1 下载</h4>
<h4 id="Tips：一般下载最新版本就行">Tips：一般下载最新版本就行</h4>
<p><img src="/2022/06/23/webdriver-config/img3.png" alt><br>
网站如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/mozilla/geckodriver/releases/</span><br></pre></td></tr></table></figure>
<h4 id="2-2-解压后放在Python的安装位置">2.2 解压后放在Python的安装位置</h4>
<p><img src="/2022/06/23/webdriver-config/img4.png" alt></p>
<h4 id="2-3-在Anaconda-Jupyter下进行测试">2.3 在Anaconda Jupyter下进行测试</h4>
<p><img src="/2022/06/23/webdriver-config/img5.png" alt><br>
代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.implicitly_wait(5)</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">time.sleep(3)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>
<h2 id="测试成功">测试成功</h2>
<p><img src="/2022/06/23/webdriver-config/img6.png" alt></p>
]]></content>
      <tags>
        <tag>安装</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转数字</title>
    <url>/2022/07/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<blockquote>
<p>如图：</p>
</blockquote>
<p><img src="/2022/07/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97/img1.PNG" alt></p>
<blockquote>
<p>代码:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; diffWaysToCompute(string expression) &#123;</span><br><span class="line">        vector&lt;int&gt; ops;</span><br><span class="line">        for (int i = 0; i &lt; expression.size();) &#123;</span><br><span class="line">            // 如果不是数字</span><br><span class="line">            if (!isdigit(expression[i])) &#123;</span><br><span class="line">                if (expression[i] == &#x27;+&#x27;) &#123;</span><br><span class="line">                    ops.push_back(ADDITION);</span><br><span class="line">                &#125; else if (expression[i] == &#x27;-&#x27;) &#123;</span><br><span class="line">                    ops.push_back(SUBTRACTION);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ops.push_back(MULTIPLICATION);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int t = 0;</span><br><span class="line">                while (i &lt; expression.size() &amp;&amp; isdigit(expression[i])) &#123;</span><br><span class="line">                    t = t * 10 + expression[i] - &#x27;0&#x27;; // 转换为数字w</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ops.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>C++ primer 第12章 动态内存与智能指针</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img1.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img2.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img3.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img4.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img5.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img6.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img7.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img8.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img9.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img10.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img11.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img12.PNG" alt></p>
<blockquote>
<p>编写函数，返回一个动态分配的 int 的vector。将此vector 传递给另一个函数，这个函数读取标准输入，将读入的值保存在 vector 元素中。再将vector传递给另一个函数，打印读入的值。记得在恰当的时刻delete vector。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;* alloc_vector()</span><br><span class="line">&#123;</span><br><span class="line">	return new vector&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assign_vector(vector&lt;int&gt;* p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (std::cin &gt;&gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_vector(vector&lt;int&gt;* p)</span><br><span class="line">&#123;</span><br><span class="line">	for (auto i : *p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto p = alloc_vector();</span><br><span class="line">	assign_vector(p);</span><br><span class="line">	print_vector(p);</span><br><span class="line">	delete p;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重做上一题，这次使用 shared_ptr 而不是内置指针。</p>
</blockquote>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;vector&lt;int&gt;&gt; alloc_vector()</span><br><span class="line">&#123;</span><br><span class="line">	return std::make_shared&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assign_vector(std::shared_ptr&lt;vector&lt;int&gt;&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (std::cin &gt;&gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_vector(std::shared_ptr&lt;vector&lt;int&gt;&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	for (auto i : *p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto p = alloc_vector();</span><br><span class="line">	assign_vector(p);</span><br><span class="line">	print_vector(p);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>水晶头连线</title>
    <url>/2022/07/10/%E6%B0%B4%E6%99%B6%E5%A4%B4%E8%BF%9E%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="颜色：">颜色：</h3>
<blockquote>
<p>白橙 橙 白绿 蓝 白蓝 绿 白棕 棕</p>
</blockquote>
<h3 id="图片：">图片：</h3>
<p><img src="/2022/07/10/%E6%B0%B4%E6%99%B6%E5%A4%B4%E8%BF%9E%E7%BA%BF/conn_img1.PNG" alt></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>流迭代器</title>
    <url>/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>C++ primer 第十章 泛型算法</p>
</blockquote>
<p><img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img1.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img2.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img3.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img4.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img5.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img6.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img7.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img8.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img9.PNG" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法</title>
    <url>/2022/07/14/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="一写文章就开始啰嗦…">一写文章就开始啰嗦…</h4>
<blockquote>
<p>感知机</p>
</blockquote>
<p>1.1 感知机详解链接：<a href="https://www.pkudodo.com/2018/11/18/1-4/">https://www.pkudodo.com/2018/11/18/1-4/</a></p>
<p>1.2 MNIST训练集下载：</p>
<pre><code>1.2.1 进入如下网址下载：
    https://github.com/Dod-o/Statistical-Learning-Method_Code
1.2.2 点击Mnist 解压即可
</code></pre>
<p>1.3 将csv放入文件夹<br>
1.4 贴代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def loadData(fileName):</span><br><span class="line">    </span><br><span class="line"># 加载Mnist数据集</span><br><span class="line"># :param fileName:要加载的数据集路径</span><br><span class="line"># :return: list形式的数据集及标记</span><br><span class="line"> </span><br><span class="line">print(&#x27;start to read data&#x27;)</span><br><span class="line"># 存放数据及标记的list</span><br><span class="line">dataArr = []; labelArr = []</span><br><span class="line"># 打开文件</span><br><span class="line">fr = open(fileName, &#x27;r&#x27;)</span><br><span class="line"># 将文件按行读取</span><br><span class="line">for line in fr.readlines():</span><br><span class="line">    # 对每一行数据按切割福&#x27;,&#x27;进行切割，返回字段列表</span><br><span class="line">    curLine = line.strip().split(&#x27;,&#x27;)</span><br><span class="line">    # 最左边的是标签</span><br><span class="line">    # Mnsit有0-9是个标记，由于是二分类任务，所以将&gt;=5的作为1，&lt;5为-1</span><br><span class="line">    if int(curLine[0]) &gt;= 5:</span><br><span class="line">        labelArr.append(1)</span><br><span class="line">    else:</span><br><span class="line">        labelArr.append(-1)</span><br><span class="line">    #存放标记</span><br><span class="line">    #[int(num) for num in curLine[1:]] -&gt; 遍历每一行中除了以第一个元素（标记）外将所有元素转换成int类型</span><br><span class="line">    #[int(num)/255 for num in curLine[1:]] -&gt; 将所有数据除255归一化(非必须步骤，可以不归一化)</span><br><span class="line">    dataArr.append([int(num)/255 for num in curLine[1:]])</span><br><span class="line"></span><br><span class="line">#返回data和label</span><br><span class="line">return dataArr, labelArr</span><br><span class="line"></span><br><span class="line">def perceptron(dataArr, labelArr, iter=50):</span><br><span class="line">    </span><br><span class="line">    # 感知器训练过程</span><br><span class="line">    # :param dataArr:训练集的数据 (list)</span><br><span class="line">    # :param labelArr: 训练集的标签(list)</span><br><span class="line">    # :param iter: 迭代次数，默认50</span><br><span class="line">    # :return: 训练好的w和b</span><br><span class="line"></span><br><span class="line">    print(&#x27;start to trans&#x27;)</span><br><span class="line">    #将数据转换成矩阵形式（在机器学习中因为通常都是向量的运算，转换称矩阵形式方便运算）</span><br><span class="line">    #转换后的数据中每一个样本的向量都是横向的</span><br><span class="line">    dataMat = np.mat(dataArr)</span><br><span class="line">    #将标签转换成矩阵，之后转置(.T为转置)。</span><br><span class="line">    #转置是因为在运算中需要单独取label中的某一个元素，如果是1xN的矩阵的话，无法用label[i]的方式读取</span><br><span class="line">    #对于只有1xN的label可以不转换成矩阵，直接label[i]即可，这里转换是为了格式上的统一</span><br><span class="line">    labelMat = np.mat(labelArr).T</span><br><span class="line">    #获取数据矩阵的大小，为m*n</span><br><span class="line">    m, n = np.shape(dataMat) # 60000 * 784</span><br><span class="line">    print(&#x27;------------&#x27;,m, n,&#x27;-------------------&#x27;)</span><br><span class="line">    #创建初始权重w，初始值全为0。</span><br><span class="line">    #np.shape(dataMat)的返回值为m，n -&gt; np.shape(dataMat)[1])的值即为n，与</span><br><span class="line">    #样本长度保持一致</span><br><span class="line">    # 1 * n</span><br><span class="line">    w = np.zeros((1, np.shape(dataMat)[1]))</span><br><span class="line">    #初始化偏置b为0</span><br><span class="line">    b = 0</span><br><span class="line">    #初始化步长，也就是梯度下降过程中的n，控制梯度下降速率</span><br><span class="line">    h = 0.0001</span><br><span class="line"></span><br><span class="line">    #进行iter次迭代计算</span><br><span class="line">    for k in range(iter):</span><br><span class="line">        #对于每一个样本进行梯度下降</span><br><span class="line">        #李航书中在2.3.1开头部分使用的梯度下降，是全部样本都算一遍以后，统一</span><br><span class="line">        #进行一次梯度下降</span><br><span class="line">        #在2.3.1的后半部分可以看到（例如公式2.6 2.7），求和符号没有了，此时用</span><br><span class="line">        #的是随机梯度下降，即计算一个样本就针对该样本进行一次梯度下降。</span><br><span class="line">        #两者的差异各有千秋，但较为常用的是随机梯度下降。</span><br><span class="line">        for i in range(m):</span><br><span class="line">            #获取当前样本的向量</span><br><span class="line">            xi = dataMat[i]</span><br><span class="line">            #获取当前样本所对应的标签</span><br><span class="line">            yi = labelMat[i]</span><br><span class="line">            #判断是否是误分类样本</span><br><span class="line">            #误分类样本特征为： -yi(w*xi+b)&gt;=0，详细可参考书中2.2.2小节</span><br><span class="line">            #在书的公式中写的是&gt;0，实际上如果=0，说明改点在超平面上，也是不正确的</span><br><span class="line">            if -1 * yi * (w * xi.T + b) &gt;= 0:</span><br><span class="line">                #对于误分类样本，进行梯度下降，更新w和b</span><br><span class="line">                #按公式进行更新</span><br><span class="line">                w = w + h *  yi * xi</span><br><span class="line">                b = b + h * yi</span><br><span class="line">        #打印训练进度</span><br><span class="line">        print(&#x27;Round %d:%d training&#x27; % (k, iter))</span><br><span class="line"></span><br><span class="line">    #返回训练完的w、b</span><br><span class="line">    return w, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test(dataArr, labelArr, w, b):</span><br><span class="line">   </span><br><span class="line">    # 测试准确率</span><br><span class="line">    # :param dataArr:测试集</span><br><span class="line">    # :param labelArr: 测试集标签</span><br><span class="line">    # :param w: 训练获得的权重w</span><br><span class="line">    # :param b: 训练获得的偏置b</span><br><span class="line">    # :return: 正确率</span><br><span class="line">    </span><br><span class="line">    print(&#x27;start to test&#x27;)</span><br><span class="line">    #将数据集转换为矩阵形式方便运算</span><br><span class="line">    dataMat = np.mat(dataArr)</span><br><span class="line">    #将label转换为矩阵并转置，详细信息参考上文perceptron中</span><br><span class="line">    #对于这部分的解说</span><br><span class="line">    labelMat = np.mat(labelArr).T</span><br><span class="line"></span><br><span class="line">    #获取测试数据集矩阵的大小</span><br><span class="line">    m, n = np.shape(dataMat)</span><br><span class="line">    #错误样本数计数</span><br><span class="line">    errorCnt = 0</span><br><span class="line">    #遍历所有测试样本</span><br><span class="line">    for i in range(m):</span><br><span class="line">        #获得单个样本向量</span><br><span class="line">        xi = dataMat[i]</span><br><span class="line">        #获得该样本标记</span><br><span class="line">        yi = labelMat[i]</span><br><span class="line">        #获得运算结果</span><br><span class="line">        result = -1 * yi * (w * xi.T + b)</span><br><span class="line">        #如果-yi(w*xi+b)&gt;=0，说明该样本被误分类，错误样本数加一</span><br><span class="line">        if result &gt;= 0:</span><br><span class="line">            errorCnt += 1</span><br><span class="line">    #正确率 = 1 - （样本分类错误数 / 样本总数）</span><br><span class="line">    accruRate = 1 - (errorCnt / m)</span><br><span class="line">    #返回正确率</span><br><span class="line">    return accruRate</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    #获取当前时间</span><br><span class="line">    #在文末同样获取当前时间，两时间差即为程序运行时间</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    #获取训练集及标签</span><br><span class="line">    trainData, trainLabel = loadData(&#x27;./mnist_train/mnist_train.csv&#x27;)</span><br><span class="line">    #print(&#x27;train_Data :&#123;0&#125;, train_Label : &#123;1&#125;&#x27;, trainData, trainLabel)</span><br><span class="line"></span><br><span class="line">    #获取测试集及标签</span><br><span class="line">    testData, testLabel = loadData(&#x27;./mnist_test/mnist_test.csv&#x27;)</span><br><span class="line"></span><br><span class="line">    #训练获得权重</span><br><span class="line">    w, b = perceptron(trainData, trainLabel, iter = 30)</span><br><span class="line">    #进行测试，获得正确率</span><br><span class="line">    accruRate = test(testData, testLabel, w, b)</span><br><span class="line"></span><br><span class="line">    #获取当前时间，作为结束时间</span><br><span class="line">    end = time.time()</span><br><span class="line">    #显示正确率</span><br><span class="line">    print(&#x27;accuracy rate is:&#x27;, accruRate)</span><br><span class="line">    #显示用时时长</span><br><span class="line">    print(&#x27;time span:&#x27;, end - start)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<blockquote>
<p>K近邻</p>
</blockquote>
<p>1.1 K近邻详解：<a href="https://www.pkudodo.com/2018/11/19/1-2/">https://www.pkudodo.com/2018/11/19/1-2/</a></p>
<p>1.2 MNIST训练集下载：</p>
<pre><code>1.2.1 进入如下网址下载：
    https://github.com/Dod-o/Statistical-Learning-Method_Code
1.2.2 点击Mnist 解压即可
</code></pre>
<p>1.3 将csv放入文件夹<br>
1.4 贴代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line"># Author:Dodo</span><br><span class="line"># Date:2018-11-16</span><br><span class="line"># Email:lvtengchao@pku.edu.cn</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">数据集：Mnist</span><br><span class="line">训练集数量：60000</span><br><span class="line">测试集数量：10000（实际使用：200）</span><br><span class="line">------------------------------</span><br><span class="line">运行结果：（邻近k数量：25）</span><br><span class="line">向量距离使用算法——欧式距离</span><br><span class="line">    正确率：97%</span><br><span class="line">    运行时长：308s</span><br><span class="line">向量距离使用算法——曼哈顿距离</span><br><span class="line">    正确率：14%</span><br><span class="line">    运行时长：246s</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import numpy as np</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loadData(fileName):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    加载文件</span><br><span class="line">    :param fileName:要加载的文件路径</span><br><span class="line">    :return: 数据集和标签集</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;start read file&#x27;)</span><br><span class="line">    # 存放数据及标记</span><br><span class="line">    dataArr = [];</span><br><span class="line">    labelArr = []</span><br><span class="line">    # 读取文件</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    # 遍历文件中的每一行</span><br><span class="line">    for line in fr.readlines():</span><br><span class="line">        # 获取当前行，并按“，”切割成字段放入列表中</span><br><span class="line">        # strip：去掉每行字符串首尾指定的字符（默认空格或换行符）</span><br><span class="line">        # split：按照指定的字符将字符串切割成每个字段，返回列表形式</span><br><span class="line">        curLine = line.strip().split(&#x27;,&#x27;)</span><br><span class="line">        # 将每行中除标记外的数据放入数据集中（curLine[0]为标记信息）</span><br><span class="line">        # 在放入的同时将原先字符串形式的数据转换为整型</span><br><span class="line">        dataArr.append([int(num) for num in curLine[1:]])</span><br><span class="line">        # 将标记信息放入标记集中</span><br><span class="line">        # 放入的同时将标记转换为整型</span><br><span class="line">        labelArr.append(int(curLine[0]))</span><br><span class="line">    # 返回数据集和标记</span><br><span class="line">    return dataArr, labelArr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def calcDist(x1, x2):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    计算两个样本点向量之间的距离</span><br><span class="line">    使用的是欧氏距离，即 样本点每个元素相减的平方  再求和  再开方</span><br><span class="line">    欧式举例公式这里不方便写，可以百度或谷歌欧式距离（也称欧几里得距离）</span><br><span class="line">    :param x1:向量1</span><br><span class="line">    :param x2:向量2</span><br><span class="line">    :return:向量之间的欧式距离</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    return np.sqrt(np.sum(np.square(x1 - x2)))</span><br><span class="line">    # 马哈顿距离计算公式</span><br><span class="line">    # return np.sum(x1 - x2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getClosest(trainDataMat, trainLabelMat, x, topK):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    预测样本x的标记。</span><br><span class="line">    获取方式通过找到与样本x最近的topK个点，并查看它们的标签。</span><br><span class="line">    查找里面占某类标签最多的那类标签</span><br><span class="line">    （书中3.1 3.2节）</span><br><span class="line">    :param trainDataMat:训练集数据集</span><br><span class="line">    :param trainLabelMat:训练集标签集</span><br><span class="line">    :param x:要预测的样本x</span><br><span class="line">    :param topK:选择参考最邻近样本的数目（样本数目的选择关系到正确率，详看3.2.3 K值的选择）</span><br><span class="line">    :return:预测的标记</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 建立一个存放向量x与每个训练集中样本距离的列表</span><br><span class="line">    # 列表的长度为训练集的长度，distList[i]表示x与训练集中第</span><br><span class="line">    ## i个样本的距离</span><br><span class="line">    distList = [0] * len(trainLabelMat)</span><br><span class="line">    # 遍历训练集中所有的样本点，计算与x的距离</span><br><span class="line">    for i in range(len(trainDataMat)):</span><br><span class="line">        # 获取训练集中当前样本的向量</span><br><span class="line">        x1 = trainDataMat[i]</span><br><span class="line">        # 计算向量x与训练集样本x的距离</span><br><span class="line">        curDist = calcDist(x1, x)</span><br><span class="line">        # 将距离放入对应的列表位置中</span><br><span class="line">        distList[i] = curDist</span><br><span class="line">    # 对距离列表进行排序</span><br><span class="line">    # argsort：函数将数组的值从小到大排序后，并按照其相对应的索引值输出</span><br><span class="line">    # 例如：</span><br><span class="line">    #   &gt;&gt;&gt; x = np.array([3, 1, 2])</span><br><span class="line">    #   &gt;&gt;&gt; np.argsort(x)</span><br><span class="line">    #   array([1, 2, 0])</span><br><span class="line">    # 返回的是列表中从小到大的元素索引值，对于我们这种需要查找最小距离的情况来说很合适</span><br><span class="line">    # array返回的是整个索引值列表，我们通过[:topK]取列表中前topL个放入list中。</span><br><span class="line">    # ----------------优化点-------------------</span><br><span class="line">    # 由于我们只取topK小的元素索引值，所以其实不需要对整个列表进行排序，而argsort是对整个</span><br><span class="line">    # 列表进行排序的，存在时间上的浪费。字典有现成的方法可以只排序top大或top小，可以自行查阅</span><br><span class="line">    # 对代码进行稍稍修改即可</span><br><span class="line">    # 这里没有对其进行优化主要原因是KNN的时间耗费大头在计算向量与向量之间的距离上，由于向量高维</span><br><span class="line">    # 所以计算时间需要很长，所以如果要提升时间，在这里优化的意义不大。</span><br><span class="line">    # 这边这么写是因为一维的数组，画张图就能理解</span><br><span class="line">    topKList = np.argsort(np.array(distList))[:topK]  # 升序排序</span><br><span class="line">    # 建立一个长度时的列表，用于选择数量最多的标记</span><br><span class="line">    # 3.2.4提到了分类决策使用的是投票表决，topK个标记每人有一票，在数组中每个标记代表的位置中投入</span><br><span class="line">    # 自己对应的地方，随后进行唱票选择最高票的标记</span><br><span class="line">    # 这里是分配10个空间，初始值为0</span><br><span class="line">    labelList = [0] * 10</span><br><span class="line">    # 对topK个索引进行遍历</span><br><span class="line">    for index in topKList:</span><br><span class="line">        # trainLabelMat[index]：在训练集标签中寻找topK元素索引对应的标记</span><br><span class="line">        # int(trainLabelMat[index])：将标记转换为int（实际上已经是int了，但是不int的话，报错）</span><br><span class="line">        # labelList[int(trainLabelMat[index])]：找到标记在labelList中对应的位置</span><br><span class="line">        # 最后加1，表示投了一票</span><br><span class="line">        labelList[int(trainLabelMat[index])] += 1</span><br><span class="line">    # max(labelList)：找到选票箱中票数最多的票数值</span><br><span class="line">    # labelList.index(max(labelList))：再根据最大值在列表中找到该值对应的索引，等同于预测的标记</span><br><span class="line">    return labelList.index(max(labelList))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test(trainDataArr, trainLabelArr, testDataArr, testLabelArr, topK):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    测试正确率</span><br><span class="line">    :param trainDataArr:训练集数据集</span><br><span class="line">    :param trainLabelArr: 训练集标记</span><br><span class="line">    :param testDataArr: 测试集数据集</span><br><span class="line">    :param testLabelArr: 测试集标记</span><br><span class="line">    :param topK: 选择多少个邻近点参考</span><br><span class="line">    :return: 正确率</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;start test&#x27;)</span><br><span class="line">    # 将所有列表转换为矩阵形式，方便运算</span><br><span class="line">    trainDataMat = np.mat(trainDataArr);</span><br><span class="line">    trainLabelMat = np.mat(trainLabelArr).T</span><br><span class="line">    testDataMat = np.mat(testDataArr);</span><br><span class="line">    testLabelMat = np.mat(testLabelArr).T</span><br><span class="line">    # 错误值技术</span><br><span class="line">    errorCnt = 0</span><br><span class="line">    # 遍历测试集，对每个测试集样本进行测试</span><br><span class="line">    # 由于计算向量与向量之间的时间耗费太大，测试集有6000个样本，所以这里人为改成了</span><br><span class="line">    # 测试200个样本点，如果要全跑，将行注释取消，再下一行for注释即可，同时下面的print</span><br><span class="line">    # 和return也要相应的更换注释行</span><br><span class="line">    # for i in range(len(testDataMat)):</span><br><span class="line">    for i in range(200):</span><br><span class="line">        # print(&#x27;test %d:%d&#x27;%(i, len(trainDataArr)))</span><br><span class="line">        print(&#x27;test %d:%d&#x27; % (i, 200))</span><br><span class="line">        # 读取测试集当前测试样本的向量</span><br><span class="line">        x = testDataMat[i]</span><br><span class="line">        # 获取预测的标记</span><br><span class="line">        y = getClosest(trainDataMat, trainLabelMat, x, topK)</span><br><span class="line">        # 如果预测标记与实际标记不符，错误值计数加1</span><br><span class="line">        if y != testLabelMat[i]: errorCnt += 1</span><br><span class="line">    # 返回正确率</span><br><span class="line">    # return 1 - (errorCnt / len(testDataMat))</span><br><span class="line">    return 1 - (errorCnt / 200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start = time.time()</span><br><span class="line">    # 获取训练集</span><br><span class="line">    trainDataArr, trainLabelArr = loadData(&#x27;./mnist_train/mnist_train.csv&#x27;)</span><br><span class="line">    # 获取测试集</span><br><span class="line">    testDataArr, testLabelArr = loadData(&#x27;./mnist_test/mnist_test.csv&#x27;)</span><br><span class="line">    # 计算测试集正确率</span><br><span class="line">    accur = test(trainDataArr, trainLabelArr, testDataArr, testLabelArr, 25)</span><br><span class="line">    # 打印正确率</span><br><span class="line">    print(&#x27;accur is:%d&#x27; % (accur * 100), &#x27;%&#x27;)</span><br><span class="line">    end = time.time()</span><br><span class="line">    # 显示花费时间</span><br><span class="line">print(&#x27;time span:&#x27;, end - start)</span><br></pre></td></tr></table></figure>
<p>KD树：<br>
还未实现，只找了外链</p>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=853980597&bvid=BV1EL4y1F7sz&cid=717808316&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</div>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>面试小知识: delete 和 delete[]</title>
    <url>/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/</url>
    <content><![CDATA[<blockquote>
<p>面试小知识 delete 和 delete[]的区别</p>
</blockquote>
<ol>
<li>区别是什么？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前提 ： 在自定义类型下</span><br><span class="line">delete用来释放new分配的单个对象指针指向的内存，</span><br><span class="line">delete[] : 用来释放new分配的对象数组指针指向的内存。</span><br></pre></td></tr></table></figure>
<p>可见网址:<br>
<a href="https://blog.csdn.net/heibao111728/article/details/84952023">https://blog.csdn.net/heibao111728/article/details/84952023</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试小知识： 取反符号~</title>
    <url>/2022/07/13/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86%EF%BC%9A-%E5%8F%96%E5%8F%8D%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h3 id="今天在力扣刷题的时候看到这么一个问题：-0-？">今天在力扣刷题的时候看到这么一个问题： ~ 0 = ？</h3>
<blockquote>
<p>按照公式：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~x = -(x + 1) </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
