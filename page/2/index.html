<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Gelasio:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wilson-xbort.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="none">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://wilson-xbort.github.io/page/2/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="none">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Willson-Xbort">
<meta property="article:tag" content="Hexo, NexT">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wilson-xbort.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

  <!--此处为建站时间 -->
  <!--<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("09/24/2018 23:45:01");
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML ="(ㆆᴗㆆ)本弱已菜菜的存活了"+dnum+"&thinsp;天"; 
        document.getElementById("times").innerHTML = hnum + "&thinsp;时" + mnum + "&thinsp;分" + snum + "&thinsp;秒"; 
    } 
  setInterval("createtime()",250);-->


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/26/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">Linux 高性能服务器理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 20:51:48" itemprop="dateCreated datePublished" datetime="2022-07-26T20:51:48+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-27 19:41:23" itemprop="dateModified" datetime="2022-07-27T19:41:23+08:00">2022-07-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">基本排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 20:50:26" itemprop="dateCreated datePublished" datetime="2022-07-26T20:50:26+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-24 08:53:30" itemprop="dateModified" datetime="2022-08-24T08:53:30+08:00">2022-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/basic_sort_img1.png" alt><br>
<img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/basic_sort_img2.png" alt></p>
<h1>冒泡排序</h1>
<h2 id="1-算法步骤">1. 算法步骤</h2>
<ol>
<li>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li>
<p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ol>
<h2 id="2-动图演示">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" alt="动图演示"></p>
<ol>
<li>代码:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt) </span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 每次确定一个最大值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vc[j] &gt; vc[j + <span class="number">1</span>]) <span class="built_in">swap</span>(vc[j], vc[j + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(vc, i);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;	</span><br><span class="line">	<span class="built_in">bubble_sort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>插入排序</h1>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h2 id="1-算法步骤-2">1. 算法步骤</h2>
<ol>
<li>
<p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
</li>
<li>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
</li>
</ol>
<h2 id="2-动图演示-2">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertionSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> key = vc[i];</span><br><span class="line">		<span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; (key &lt; vc[j])) &#123;</span><br><span class="line">			vc[j + <span class="number">1</span>] = vc[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// -1 + 1 = 0</span></span><br><span class="line">		vc[j + <span class="number">1</span>] = key;</span><br><span class="line">		<span class="built_in">print</span>(vc, i);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">insertion_sort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>选择排序</h1>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="1-算法步骤-3">1. 算法步骤</h2>
<ol>
<li>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
</li>
<li>
<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
</li>
<li>
<p>重复第二步，直到所有元素均排序完毕。</p>
</li>
</ol>
<h2 id="2-动图演示-3">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt) </span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort_min</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> min;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		min = i; </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) </span><br><span class="line">			<span class="keyword">if</span> (vc[j] &lt; vc[min])</span><br><span class="line">				min = j;</span><br><span class="line">		<span class="built_in">swap</span>(vc[min], vc[i]);</span><br><span class="line">		<span class="built_in">print</span>(vc, i + <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort_max</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		max = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vc[j] &gt; vc[max]) max = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(vc[i], vc[max]);</span><br><span class="line">		<span class="built_in">print</span>(vc, len - (i + <span class="number">1</span>));</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*vector&lt;int&gt; vc = &#123; 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 &#125;;	</span></span><br><span class="line"><span class="comment">	selection_sort_min(vc);*/</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc2 = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">selection_sort_max</span>(vc2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.希尔排序</p>
</blockquote>
<h1>希尔排序</h1>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h2 id="1-算法步骤-4">1. 算法步骤</h2>
<ol>
<li>
<p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>
</li>
<li>
<p>按增量序列个数 k，对序列进行 k 趟排序；</p>
</li>
<li>
<p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序的间隔序列不推荐用2的幂(1 2 4 8 16...)，</span></span><br><span class="line"><span class="comment">// 因为这样直到间隔为1之前，都不会将奇数位置与偶数位置的元素进行比较，这样是低效的。</span></span><br><span class="line"><span class="comment">// 希尔自己认为可以用2的幂 - 1序列(1 3 7 15...)，后来又有文章建议用3x + 1(1 4 13 40 121...)，都是可以的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 间隔为3x + 1</span></span><br><span class="line">	<span class="type">int</span> gap = vc.<span class="built_in">size</span>() / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; gap &gt;= <span class="number">1</span>; gap /= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gap; ++i) &#123;</span><br><span class="line">			<span class="comment">// 组内排序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + gap; j &lt; vc.<span class="built_in">size</span>(); j += gap) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = j; k - gap &gt;= <span class="number">0</span> &amp;&amp; vc[k] &lt; vc[k - gap]; k -= gap) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(vc[k], vc[k - gap]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">print</span>(vc, i + <span class="number">1</span>);</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">shellSort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5.归并排序</p>
</blockquote>
<h1>归并排序</h1>
<h2 id="1-算法步骤-5">1. 算法步骤</h2>
<ol>
<li>
<p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li>
<p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li>
<p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li>
<p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li>
<p>将另一序列剩下的所有元素直接复制到合并序列尾。</p>
</li>
</ol>
<h2 id="2…-动图演示">2… 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ptrL = l;</span><br><span class="line">    <span class="type">int</span> ptrR = mid;</span><br><span class="line">    <span class="type">static</span> vector&lt;<span class="type">int</span>&gt;tempary;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &gt; tempary.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        tempary.<span class="built_in">resize</span>(arr.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrL != mid &amp;&amp; ptrR != r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[ptrL] &lt; arr[ptrR]) &#123;</span><br><span class="line">            tempary[index++] = arr[ptrL++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tempary[index++] = arr[ptrR++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrL != mid) &#123;</span><br><span class="line">        tempary[index++] = arr[ptrL++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrR != r) &#123;</span><br><span class="line">        tempary[index++] = arr[ptrR++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(tempary.<span class="built_in">begin</span>(), tempary.<span class="built_in">begin</span>() + index, arr.<span class="built_in">begin</span>() + l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// sort the range [l, r) in arr</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, mid, r);</span><br><span class="line">    <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="built_in">mergeSort</span>(vc, <span class="number">0</span>, vc.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">print</span>(vc, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>6.堆排序</p>
</blockquote>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/heapSort.gif" alt="动图演示"></p>
<blockquote>
<p>对于一个完全二叉树，在填满的情况下（非叶子节点都有两个子节点），每一层的元素个数是上一层的二倍，根节点数量是1，所以最后一层的节点数量，一定是之前所有层节点总数+1，<br>
所以，我们能找到最后一层的第一个节点的索引，即节点总数/2（根节点索引为0），这也就是第一个叶子节点，所以第一个非叶子节点的索引就是第一个叶子结点的索引-1。<br>
那么对于填不满的二叉树呢？这个计算方式仍然适用，当我们从上往下，从左往右填充二叉树的过程中，第一个叶子节点，一定是序列长度/2，所以第一个非叶子节点的索引就是arr.length / 2 - 1。</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 父节点 * 2 + 1为左子节点</span></span><br><span class="line">	<span class="comment">// 从最后一个叶子节点开始</span></span><br><span class="line">	<span class="type">int</span> fa = start, so = fa * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (so &lt;= end) &#123;</span><br><span class="line">		<span class="comment">// 比较两个子节点大小，选大的那个</span></span><br><span class="line">		<span class="keyword">if</span> (so + <span class="number">1</span> &lt;= end &amp;&amp; vec[so] &lt; vec[so + <span class="number">1</span>]) </span><br><span class="line">			so++; <span class="comment">// so = so + 1;</span></span><br><span class="line">		<span class="keyword">if</span> (vec[fa] &gt; vec[so]) <span class="comment">// 父节点大于子节点则不需要调整</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">			<span class="built_in">swap</span>(vec[fa], vec[so]);</span><br><span class="line">			fa = so;</span><br><span class="line">			so = fa * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 这里是*2 不是/2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 索引从0开始，寻找第一个非叶子节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">max_heapify</span>(vec, i, len - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(vec[<span class="number">0</span>], vec[i]);</span><br><span class="line">		<span class="built_in">max_heapify</span>(vec, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// vector&lt;int&gt; vec = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">heap_sort</span>(vec, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>7.快速排序</p>
</blockquote>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> left = low;</span><br><span class="line">    <span class="type">int</span> right = high;</span><br><span class="line">    <span class="type">int</span> key = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*从左向右找比key大的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (left == high) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*从右向左找比key小的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (right == low)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*中枢值与j对应值交换*/</span></span><br><span class="line">    arr[low] = arr[right];</span><br><span class="line">    arr[right] = key;</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, low, right - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, right + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="built_in">Qsort</span>(vc, <span class="number">0</span>, vc.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(vc, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>8.基数排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>9.桶排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>10.计数排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/" class="post-title-link" itemprop="url">leetcode 303 场周赛复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-25 19:41:57" itemprop="dateCreated datePublished" datetime="2022-07-25T19:41:57+08:00">2022-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 18:16:16" itemprop="dateModified" datetime="2022-07-26T18:16:16+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>第一题</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img1.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">repeatedCharacter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i = <span class="string">&#x27;a&#x27;</span>;  i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(i, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ss : s) &#123;</span><br><span class="line">            ++m[ss];</span><br><span class="line">            <span class="keyword">if</span>(m[ss] == <span class="number">2</span>) <span class="keyword">return</span> ss;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img2.PNG" alt></p>
<blockquote>
<p>第二题</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img3.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img5.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">equalPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec_col</span>(m * m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec_row;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            vec_row.<span class="built_in">push_back</span>(grid[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                vec_col[j].<span class="built_in">push_back</span>(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(vec_row[i] == vec_col[j]) ++ cnt; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img4.PNG" alt></p>
<blockquote>
<p>tip: 前两题较简单，第三题有点难度</p>
</blockquote>
<blockquote>
<p>第三题</p>
</blockquote>
<blockquote>
<p>tips: 我觉得最妙的点在于评分取负号</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img6.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img7.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img8.PNG" alt></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line">    <span class="comment">// 修改食物评分时要影响到cs中set的结构</span></span><br><span class="line">    <span class="comment">// 想要获取set必须要知道key(烹饪方式)</span></span><br><span class="line">    <span class="comment">// 所以食物 -&gt;(评分， 烹饪方式)</span></span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">int</span>, string&gt;&gt; fs;</span><br><span class="line">    <span class="comment">// 烹饪方式 -&gt; (评分, 名字)</span></span><br><span class="line">    <span class="comment">// 需要通过烹饪方式查询评分和食物名字</span></span><br><span class="line">    <span class="comment">// 要返回评分最高的食物和返回字典序较小的名字</span></span><br><span class="line">    <span class="comment">// 所以先评分，后名字</span></span><br><span class="line">    unordered_map&lt;string, set&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;&gt; cs;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FoodRatings</span>(vector&lt;string&gt; &amp;foods, vector&lt;string&gt; &amp;cuisines, vector&lt;<span class="type">int</span>&gt; &amp;ratings) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; foods.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 食物, 烹饪方式</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;f = foods[i], &amp;c = cuisines[i];</span><br><span class="line">            <span class="comment">// 评分</span></span><br><span class="line">            <span class="type">int</span> r = ratings[i];</span><br><span class="line">            <span class="comment">// 评分， 烹饪方式赋值</span></span><br><span class="line">            fs[f] = &#123;r, c&#125;;</span><br><span class="line">            <span class="comment">// emplace就不需要make_pair</span></span><br><span class="line">            <span class="comment">// 因为要返回评分最高的食物和返回字典序较小的名字</span></span><br><span class="line">            <span class="comment">// 序列是相反的</span></span><br><span class="line">            <span class="comment">// 评分取负号，保证最小对应最高评分</span></span><br><span class="line">            cs[c].<span class="built_in">emplace</span>(-r, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeRating</span><span class="params">(string food, <span class="type">int</span> newRating)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出食物对应的 (评分，烹饪方式)</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;[r, c] = fs[food];</span><br><span class="line">        <span class="comment">// 获取评分和名字</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;s = cs[c];</span><br><span class="line">        s.<span class="built_in">erase</span>(&#123;-r, food&#125;); <span class="comment">// 移除旧数据</span></span><br><span class="line">        s.<span class="built_in">emplace</span>(-newRating, food); <span class="comment">// 添加新数据</span></span><br><span class="line">        <span class="comment">// 修改评分</span></span><br><span class="line">        r = newRating;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">highestRated</span><span class="params">(string cuisine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少有一种，所以取begin()-&gt;第二项（名字）</span></span><br><span class="line">        <span class="keyword">return</span> cs[cuisine].<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第四题</p>
</blockquote>
<blockquote>
<p>看不懂的可以看视频 , 韦恩图</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img9.PNG" alt></p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数：                  1      2      3</span></span><br><span class="line">    <span class="comment">// 二进制为1的个数：     1      1      2</span></span><br><span class="line">    <span class="comment">// 表格：</span></span><br><span class="line">    <span class="comment">// |-------------------------------------------------|</span></span><br><span class="line">    <span class="comment">// cx(去重后):        |   1   |   2    |</span></span><br><span class="line">    <span class="comment">// cnt:               |   2   |   1    |</span></span><br><span class="line">    <span class="comment">// |-------------------------------------------------|</span></span><br><span class="line">    <span class="comment">// 五种：                1 + 2  -&gt; 从c(x) = 1的集合中取一个, c(x) = 2 中取一个  || 2 * 1  -&gt; 有两个1</span></span><br><span class="line">    <span class="comment">//                       1 * 2  -&gt; (2, 1) 和 （1，2）</span></span><br><span class="line">    <span class="comment">//                       1 * 1  -&gt; 自己和自己</span></span><br><span class="line">    <span class="comment">// 遍历去重后的 nums\textit&#123;nums&#125;nums，统计 c(nums[i])c(nums[i])的个数，记录在 cnt 中，</span></span><br><span class="line">    <span class="comment">// 然后写一个二重循环遍历 cnt，对于所有的 c(x)+c(y)≥k，</span></span><br><span class="line">    <span class="comment">// 累加 cnt[c(x)]⋅cnt[c(y)]，表示从这两组中各选一个 x 和 y 组成优质数对的个数。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countExcellentPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="comment">// 获取cnt表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())) <span class="comment">// 去重</span></span><br><span class="line">            ++cnt[__builtin_popcount(x)];</span><br><span class="line">        <span class="type">long</span> ans = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// cx -&gt; x中1的个数， ccx -&gt; 值为x的个数</span></span><br><span class="line">        <span class="comment">// cy -&gt; y中1的个数， ccy -&gt; 值为y的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cx, ccx] : cnt)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cy, ccy] : cnt)</span><br><span class="line">                <span class="keyword">if</span> (cx + cy &gt;= k) <span class="comment">// (x,y) 是优质数对</span></span><br><span class="line">                    ans += (<span class="type">long</span>) ccx * ccy; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=258805927&bvid=BV14a411U7QZ&cid=782543429&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>


<hr>
</div>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/25/STL%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/25/STL%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">STL底层实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-25 19:33:43" itemprop="dateCreated datePublished" datetime="2022-07-25T19:33:43+08:00">2022-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 20:46:42" itemprop="dateModified" datetime="2022-07-26T20:46:42+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>vector</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">底层实现是数组。</span><br><span class="line">1.由于数组的特性,vector也可以使用下标快速访问。</span><br><span class="line">2.顺序存储，插入/删除到非尾结点位置所需时间复杂度0(n)</span><br><span class="line">3.新建vector时，和数组一样分配一片连续内存空间，当添加元素时，如果初始分配的空间满了，将会重新申请一个2倍质数大小左右的空间，</span><br><span class="line">将原空间的内容拷贝过来后释放原空间内存。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>map, unordered_map, multimap, unordered_multimap</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map 和 multimap 的底层数据结构是红黑树，根据红黑树的原理，map和multimap可以实现0(lgn)的查找，删除，插入，实现key为序列的排序，并且map和multimap是有序的。</span><br><span class="line">unordered_map, unordered_map 的底层数据结构是哈希表。</span><br><span class="line">multimap 和 map 的区别在于，multimap允许关键字重复，而map不允许重复。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>list</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">底层实现是双向链表。拥有链表的特性。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>deque</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">底层实现是双向队列，可以在头尾插入和删除元素。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set &amp; multiset &amp; unordered_set &amp; unordered_multiset</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上四种容器也都是关联容器，set系与map系的区别在于map中存储的是&lt;key-value&gt;，而set可以理解为关键字即值，即只保存关键字的容器。</span><br><span class="line">set 的底层实现是红黑树(平衡树),。</span><br><span class="line">unordered_set, unordered_multiset底层实现为哈希表。</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">数据结构-二叉树复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-22 07:44:24" itemprop="dateCreated datePublished" datetime="2022-07-22T07:44:24+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 20:31:20" itemprop="dateModified" datetime="2022-07-26T20:31:20+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>二叉树复习 -&gt; 树的遍历 (重要)</p>
</blockquote>
<ol>
<li>建立二叉树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>前序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img1.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img2.PNG" alt></li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归实现（使用栈）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res; </span><br><span class="line">        stack&lt;TreeNode*&gt;stc;</span><br><span class="line">        stc.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stc.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(stc.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">            TreeNode* tmp = stc.<span class="built_in">top</span>();</span><br><span class="line">            stc.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 因为是stack(栈),需要先右后左</span></span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right) stc.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left) stc.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>中序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img3.PNG" alt></li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, vc);</span><br><span class="line">        vc.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, vc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line">        <span class="built_in">inorder</span>(root, vc);</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="comment">// 非叶子节点 || 栈不为空</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是root!</span></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>后序遍历</li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left, vc);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right, vc);</span><br><span class="line">    vc.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line">    <span class="built_in">postorder</span>(root, vc);</span><br><span class="line">    <span class="keyword">return</span> vc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代实现 暂时没看懂</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>层序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img4.PNG" alt></li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">//创建返回数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="comment">//若空</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">//根节点压入队列</span></span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">//若队列不为空，循环</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//当前队列长度</span></span><br><span class="line">            <span class="type">int</span> queLen = que.<span class="built_in">size</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            <span class="comment">//循环遍历当前层所有节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; queLen; ++i)&#123;</span><br><span class="line">                <span class="comment">//选择节点</span></span><br><span class="line">                <span class="keyword">auto</span> node = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">//选择的当前节点弹出队列</span></span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//将选择的当前节点的值压入数组</span></span><br><span class="line">                ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//寻找当前节点的下一层节点压入队列</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树复习 -&gt; 运用递归解决树的问题</p>
</blockquote>
<ol>
<li>二叉树的最大深度<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img5.PNG" alt></li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left_depth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right_depth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_depth, right_depth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.对称二叉树<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img6.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img7.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetricHelper</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果左右节点都为空, 说明当前节点是叶子节点，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点只有一个子节点或者有两个子节点，但两个子节点的值不相同，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span> || left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//然后左子节点的左子节点和右子节点的右子节点比较，左子节点的右子节点和右子节点的左子节点比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetricHelper</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isSymmetricHelper</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//从两个子节点开始判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetricHelper</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>路径总和（这题也是很妙的做法）</li>
</ol>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img8.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img9.PNG" alt></p>
<blockquote>
<p>递归法，没递归到一个节点，就拿target-当前节点值，如果存在路径总和等于target，那么最后一个叶子节点一定等于target剩下的值。<br>
如果递归到叶子节点后，剩余的target值不等于叶子节点，说明不存在路径总和等于target。<br>
时间复杂度O（n），空间复杂度O（1）。</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==null &amp;&amp; root.right==null)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root.left,targetSum - root.val) || <span class="built_in">hasPathSum</span>(root.right,targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树复习 -&gt; 总结</p>
</blockquote>
<ol>
<li>从中序与后序遍历序列构造二叉树</li>
</ol>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img10.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> head1, <span class="type">int</span> tail1, <span class="type">int</span> head2, <span class="type">int</span> tail2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断什么时候停止递归</span></span><br><span class="line">        <span class="keyword">if</span>(head2 &gt; tail2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> last_elem = postorder[tail2];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(last_elem);</span><br><span class="line">        <span class="keyword">if</span>(head2 == tail2) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找分割点</span></span><br><span class="line">        <span class="type">int</span> spilit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(inorder[head1 + spilit] != last_elem) spilit++; </span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(inorder, postorder, head1, head1 + spilit - <span class="number">1</span>, head2, head2 + spilit - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(inorder, postorder, head1 + spilit + <span class="number">1</span>, tail1, head2 + spilit, tail2 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 如果是空树,返回nullptr</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(inorder, postorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>从前序与中序遍历序列构造二叉树<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img11.PNG" alt></li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="type">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="type">int</span> inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        <span class="comment">// 建立根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 获取左子树的节点数</span></span><br><span class="line">        <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        root-&gt;left = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span> + size_left_subtree, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">         <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">             index[inorder[i]] = i;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.填充每个节点的下一个右侧节点指针<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img12.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node*&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                Node* node = Q.<span class="built_in">front</span>();</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 因为最后一个节点的next不需要赋值</span></span><br><span class="line">                <span class="keyword">if</span>(i &lt; size - <span class="number">1</span>) node-&gt;next = Q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) Q.<span class="built_in">push</span>(node-&gt;left) ;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.填充每个节点的下一个右侧节点指针 II<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img13.PNG" alt></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i &lt; size - <span class="number">1</span>) node-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.二叉树的最近公共祖先</p>
<blockquote>
<p>tip: 这题也是挺巧的,如果left为空，说明这两个节点在cur结点的右子树上，我们只需要返回右子树查找的结果即可，反之<br>
查找左子树，如果left和right都不为空，说明这两个节点一个在cur的左子树上一个在cur的右子树上，我们只需要返回cur结点<br>
即可</p>
</blockquote>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img14.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">       TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">       TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">       <span class="comment">// 公共节点在根节点的右子树上</span></span><br><span class="line">       <span class="keyword">if</span>(left == <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">       <span class="comment">// 公共节点在根节点的左子树上</span></span><br><span class="line">       <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6.二叉树的序列化与反序列化</p>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img15.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img16.PNG" alt></p>
<p>链接： <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/</a></p>
<blockquote>
<p>tips: 条例非常清晰，代码可阅读性很高</p>
</blockquote>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserialize</span><span class="params">(TreeNode* root, string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            str += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            str += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            <span class="built_in">reserialize</span>(root-&gt;left, str);</span><br><span class="line">            <span class="built_in">reserialize</span>(root-&gt;right, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="built_in">reserialize</span>(root, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">rdeserialize</span><span class="params">(list&lt;string&gt;&amp; dataArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dataArray.<span class="built_in">front</span>() == <span class="string">&quot;None&quot;</span>)&#123;</span><br><span class="line">            dataArray.<span class="built_in">erase</span>(dataArray.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(dataArray.<span class="built_in">front</span>()));</span><br><span class="line">        dataArray.<span class="built_in">erase</span>(dataArray.<span class="built_in">begin</span>());</span><br><span class="line">        root-&gt;left = <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">        root-&gt;right = <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        list&lt;string&gt; dataArray;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : data) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                dataArray.<span class="built_in">push_back</span>(str);</span><br><span class="line">                str.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> str.<span class="built_in">push_back</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            dataArray.<span class="built_in">push_back</span>(str);</span><br><span class="line">            str.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>
<hr>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">数据结构: 链表复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-17 20:10:43" itemprop="dateCreated datePublished" datetime="2022-07-17T20:10:43+08:00">2022-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 20:38:52" itemprop="dateModified" datetime="2022-08-22T20:38:52+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>链表复习 -&gt; leetcode/牛客快速测试模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode* next;</span><br><span class="line">	<span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode* next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		cout &lt;&lt; head-&gt;val &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">	ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">	ListNode* cur = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">		cur-&gt;next = tmp;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ShowList</span>(head-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 设计链表 (重要)</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img1.PNG" alt></p>
<h2 id="代码：-注意点：新节点next一定设置为nullptr">代码： 注意点：新节点next一定设置为nullptr</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">val</span>(x) &#123;&#125; <span class="comment">// 初始化</span></span><br><span class="line">        Node* next; <span class="comment">// 指针域</span></span><br><span class="line">        <span class="type">int</span> val; <span class="comment">// 数据域</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        nHead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 初始化头指针</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表中第 index 个节点的值。如果索引无效，则返回-1。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引比0小或者比最大索引大，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; (len - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* tmp = nHead-&gt;next; <span class="comment">// 辅助指针指向第一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(index--) tmp = tmp-&gt;next; <span class="comment">// 循环index次遍历到第index个节点</span></span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(val);  <span class="comment">// 创建新节点</span></span><br><span class="line">        tmp-&gt;next = nHead-&gt;next; </span><br><span class="line">        nHead-&gt;next = tmp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tmp = nHead;</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next) tmp = tmp-&gt;next;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        newNode-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 赋值为nullptr</span></span><br><span class="line">        tmp-&gt;next = newNode;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span> ) <span class="built_in">addAtHead</span>(val); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index == len) <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">            Node* cur = nHead;</span><br><span class="line">            <span class="keyword">while</span>(index--) cur = cur-&gt;next;</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span>;</span><br><span class="line">        Node* cur = nHead;</span><br><span class="line">        <span class="keyword">while</span>(index--)  cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Node* nHead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 环形链表（基础）</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img2.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img3.PNG" alt></p>
<h2 id="代码：-注意点：循环条件应该是next指针不为空">代码： 注意点：循环条件应该是next指针不为空</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="或者-如下方这种使用do-while">或者 如下方这种使用do-while</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *f=head;</span><br><span class="line">        ListNode *s=head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(f-&gt;next==<span class="literal">nullptr</span>||f-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            f=f-&gt;next-&gt;next;</span><br><span class="line">            s=s-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(f!=s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 环形链表（进阶）</p>
</blockquote>
<blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>
不允许修改 链表。</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img4.PNG" alt></p>
<h3 id="方法一-哈希表-注意：-unordered-set-ListNode-内部是一个指针">方法一. 哈希表 注意： unordered_set&lt;ListNode*&gt; 内部是一个指针</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; unset;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span>(unset.<span class="built_in">count</span>(head)) <span class="keyword">return</span> head;</span><br><span class="line">            unset.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二-快慢指针-此方法需要手算，思路清晰-最后要移动c个next">方法二. 快慢指针: 此方法需要手算，思路清晰,最后要移动c个next</h3>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img5.PNG" alt></p>
<h2 id="代码：-4">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 相交链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img6.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img7.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img8.PNG" alt></p>
<h2 id="代码：-非常巧妙的想法">代码： 非常巧妙的想法</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = headA, *p2 = headB;</span><br><span class="line">        <span class="comment">//变轨次数</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span> p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            <span class="comment">//p1变轨</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">2</span> &amp;&amp; p1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p1 = headB;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p2变轨</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">2</span> &amp;&amp; p2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p2 = headA;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 删除链表的倒数第N个节点</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img9.PNG" alt></p>
<h2 id="代码：-使用的依旧是快慢指针">代码： 使用的依旧是快慢指针</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">nullptr</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> slow-&gt;next = (slow-&gt;next)-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 反转链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img10.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img11.PNG" alt></p>
<h2 id="代码：老算法了">代码：老算法了</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head, *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 移除链表元素</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img12.PNG" alt></p>
<h2 id="代码：加个头结点-之后的代码都是常规代码">代码：加个头结点,之后的代码都是常规代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* no_val_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        no_val_head-&gt;next = head;</span><br><span class="line">        ListNode* p = no_val_head, *q = no_val_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = q;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> no_val_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 奇偶链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img13.PNG" alt></p>
<h2 id="代码：分两个部分-奇数部分和偶数部分-头结点不变">代码：分两个部分,奇数部分和偶数部分,头结点不变</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* odd = head, *evenHead = head-&gt;next;</span><br><span class="line">        ListNode* even = evenHead;</span><br><span class="line">        <span class="keyword">while</span>(even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 回文链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img14.PNG" alt></p>
<h2 id="代码：-很妙的构思-采用递归">代码： 很妙的构思,采用递归</h2>
<h3 id="正常解法">正常解法</h3>
<h3 id="巧妙的解法">巧妙的解法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode *t;</span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        res = <span class="built_in">recursivelyCheck</span>(head-&gt;next) &amp;&amp; (t-&gt;val==head-&gt;val);</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        t = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双链表 -&gt; 设计链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img15.PNG" alt></p>
<h2 id="代码：-5">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Node* prev;</span><br><span class="line">        Node* next;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">val</span>(x) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>()&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 头结点</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* tm = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--) </span><br><span class="line">            tm = tm-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> tm-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tm = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            head-&gt;next-&gt;prev = tm;</span><br><span class="line">        tm-&gt;prev = head;</span><br><span class="line">        tm-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = tm;</span><br><span class="line">        len ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = len;</span><br><span class="line">        Node* tmp = head;</span><br><span class="line">        Node * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next) </span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        tmp-&gt;next = newNode;</span><br><span class="line">        newNode-&gt;prev = tmp;</span><br><span class="line">        newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) <span class="built_in">addAtHead</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index == len) <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* tmp = head-&gt;next;</span><br><span class="line">            Node * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">            <span class="keyword">while</span>(index--) </span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            </span><br><span class="line">            newNode-&gt;next = tmp;</span><br><span class="line">            newNode-&gt;prev = tmp-&gt;prev;</span><br><span class="line">            tmp-&gt;prev-&gt;next = newNode;</span><br><span class="line">            tmp-&gt;prev = newNode;</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span>;</span><br><span class="line">         Node * tmp = head-&gt;next;</span><br><span class="line">         <span class="keyword">while</span>(index--) </span><br><span class="line">             tmp = tmp-&gt;next;</span><br><span class="line">         <span class="keyword">if</span>(tmp-&gt;next) &#123;</span><br><span class="line">            tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">            tmp-&gt;prev-&gt;next = tmp-&gt;next;    </span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             tmp-&gt;prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">delete</span> tmp;</span><br><span class="line">         len--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Node* prev;</span></span><br><span class="line">    Node* head, *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 合并两个有序链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img16.PNG" alt></p>
<h2 id="代码：-6">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list1 &amp;&amp; !list2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* nHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* p = nHead, *lA = list1, *lB = list2;</span><br><span class="line">        <span class="keyword">while</span>(lA &amp;&amp; lB) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lA-&gt;val &lt;= lB-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = lA;</span><br><span class="line">                p = lA;</span><br><span class="line">                lA = lA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = lB;</span><br><span class="line">                p = lB;</span><br><span class="line">                lB = lB-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lA) p-&gt;next = lA;</span><br><span class="line">        <span class="keyword">if</span>(lB) p-&gt;next = lB;</span><br><span class="line">        <span class="keyword">return</span> nHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 两数相加</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img17.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img18.PNG" alt></p>
<h2 id="代码：-7">代码：</h2>
<h3 id="正常方法：">正常方法：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * @param head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reserve</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">addInList</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> head2;</span><br><span class="line">        <span class="keyword">if</span>(head2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> head1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转链表</span></span><br><span class="line">        <span class="comment">// 9-&gt;3-&gt;7   =&gt;  7-&gt;3-&gt;9</span></span><br><span class="line">        <span class="comment">// 6-&gt;3      =&gt;  3-&gt;6</span></span><br><span class="line">        head1 = <span class="built_in">reserve</span>(head1);</span><br><span class="line">        head2 = <span class="built_in">reserve</span>(head2);</span><br><span class="line">        <span class="comment">// 创建新的表头节点</span></span><br><span class="line">        ListNode* res= <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p = res;</span><br><span class="line">        <span class="comment">// 进位的值</span></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 || head2 ) &#123;</span><br><span class="line">            <span class="comment">// 累加值(head1-&gt;val + head2-&gt;val + tmp)</span></span><br><span class="line">            <span class="type">int</span> total = carry;</span><br><span class="line">            <span class="keyword">if</span>(head1) &#123;</span><br><span class="line">                <span class="comment">// 节点不为空，加上当前节点值</span></span><br><span class="line">                total += head1-&gt;val;</span><br><span class="line">                head1 = head1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head2) &#123;</span><br><span class="line">                total += head2-&gt;val;</span><br><span class="line">                head2 = head2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求进位</span></span><br><span class="line">            carry = total / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 求余后的值为当前节点的值</span></span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(total % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 下一个节点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后两条链表都加完，且当进位不为0的时候，加上进位位</span></span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加上进位</span></span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reserve</span>(res-&gt;next);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="巧方法">巧方法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(l1 || l2 || sum)&#123;</span><br><span class="line">             <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                 sum += l1-&gt;val;</span><br><span class="line">                 l1 = l1-&gt;next;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">                 sum += l2-&gt;val;</span><br><span class="line">                 l2 = l2-&gt;next;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">             cur = cur-&gt;next;</span><br><span class="line">             sum /= <span class="number">10</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 扁平化多级双向链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img19.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img20.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img21.PNG" alt></p>
<h2 id="代码：-p-next-r是点睛之笔">代码： p-&gt;next = r是点睛之笔</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">       Node* p = head, *q, *r;</span><br><span class="line">       <span class="keyword">while</span>(p) &#123;</span><br><span class="line">           <span class="keyword">if</span>(p-&gt;child != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">               q = p-&gt;next;</span><br><span class="line">               r = p-&gt;child;</span><br><span class="line">               p-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">               p-&gt;next = r; <span class="comment">// 为下次递归做铺垫</span></span><br><span class="line">               r-&gt;prev = p;</span><br><span class="line">               <span class="keyword">while</span>(r-&gt;next) r = r-&gt;next;</span><br><span class="line">               r-&gt;next = q;</span><br><span class="line">               <span class="keyword">if</span> (q != <span class="literal">NULL</span>) q-&gt;prev = r;</span><br><span class="line">           &#125;</span><br><span class="line">           p = p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 复制带随机指针的链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img22.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img23.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img26.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img27.PNG" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next)  <span class="comment">//复制每个节点，并将原链表和复制链表连在一起。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next)   <span class="comment">//复制random指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;random)</span><br><span class="line">              p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拆分两个链表，并复原原链表</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>), cur = dummy; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            cur = cur-&gt;next = q;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img28.PNG" alt></p>
<h2 id="代码：使用的unordered-map">代码：使用的unordered_map</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; unmap;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        unmap[head] = newNode;</span><br><span class="line">        newNode-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;random) newNode-&gt;random = unmap[head-&gt;random];</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 旋转链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img24.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img25.PNG" alt></p>
<h2 id="代码-先变成循环链表再确定位置断开">代码: 先变成循环链表再确定位置断开</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        <span class="comment">// n - k % len是新链表头节点的索引</span></span><br><span class="line">        <span class="comment">// n - k % len - 1是新链表尾节点的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - k % len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt; 判断链表是否为回文结构</p>
</blockquote>
<h2 id="描述：">描述：</h2>
<blockquote>
<p>给定一个链表，请判断该链表是否为回文结构。<br>
回文是指该字符串正序逆序完全一致。</p>
</blockquote>
<h3 id="示例1-2">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;1&#125;</span><br><span class="line">返回值：true</span><br></pre></td></tr></table></figure>
<h3 id="示例2-2">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;2,1&#125;</span><br><span class="line">返回值：false</span><br><span class="line">说明：2-&gt;1   </span><br></pre></td></tr></table></figure>
<h3 id="示例3">示例3</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;1,2,2,1&#125;</span><br><span class="line">返回值：true</span><br><span class="line">说明：1-&gt;2-&gt;2-&gt;1      </span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reserve</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPail</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="comment">// 找中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中点处翻转</span></span><br><span class="line">        slow = <span class="built_in">reserve</span>(slow);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow) &#123;</span><br><span class="line">            <span class="comment">// 比较值是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != fast-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt;  删除有序链表中重复的元素-I</p>
</blockquote>
<h2 id="描述">描述</h2>
<blockquote>
<p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>
例如：<br>
给出的链表为1→1→2,返回1→2。<br>
给出的链表为1→1→2→3→3,返回1→2→3。</p>
</blockquote>
<h3 id="示例1-3">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;1,1,2&#125;</span><br><span class="line">返回值：&#123;1,2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例2-3">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;&#125;</span><br><span class="line">返回值：&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码：-8">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* nHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode*p = head, *q = nHead;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(p-&gt;val) == set.<span class="built_in">end</span>())</span><br><span class="line">                set.<span class="built_in">emplace</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : set) &#123;</span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">            q-&gt;next = tmp;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt;  删除有序链表中重复的元素-II</p>
</blockquote>
<h2 id="描述-2">描述</h2>
<blockquote>
<p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>
例如：<br>
给出的链表为1→2→3→3→4→4→5,返回1→2→5.<br>
给出的链表为1→1→1→2→3, 返回2→3.</p>
</blockquote>
<h3 id="示例1-4">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;1,2,2&#125;</span><br><span class="line">返回值：&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例2-4">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;&#125;</span><br><span class="line">返回值：&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码：-9">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> tmp = cur-&gt;next-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val == tmp) </span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">流迭代器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-16 13:36:06 / 修改时间：16:58:46" itemprop="dateCreated datePublished" datetime="2022-07-16T13:36:06+08:00">2022-07-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>C++ primer 第十章 泛型算法</p>
</blockquote>
<p><img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img1.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img2.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img3.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img4.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img5.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img6.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img7.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img8.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img9.PNG" alt></p>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-14 20:24:13" itemprop="dateCreated datePublished" datetime="2022-07-14T20:24:13+08:00">2022-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-17 13:50:11" itemprop="dateModified" datetime="2022-07-17T13:50:11+08:00">2022-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>C++ primer 第12章 动态内存与智能指针</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img1.PNG" alt></p>
<blockquote>
<p>shared_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img2.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img3.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img4.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img5.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img6.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img7.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img8.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img9.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img10.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img11.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img12.PNG" alt></p>
<blockquote>
<p>编写函数，返回一个动态分配的 int 的vector。将此vector 传递给另一个函数，这个函数读取标准输入，将读入的值保存在 vector 元素中。再将vector传递给另一个函数，打印读入的值。记得在恰当的时刻delete vector。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;* alloc_vector()</span><br><span class="line">&#123;</span><br><span class="line">	return new vector&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assign_vector(vector&lt;int&gt;* p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (std::cin &gt;&gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_vector(vector&lt;int&gt;* p)</span><br><span class="line">&#123;</span><br><span class="line">	for (auto i : *p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto p = alloc_vector();</span><br><span class="line">	assign_vector(p);</span><br><span class="line">	print_vector(p);</span><br><span class="line">	delete p;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重做上一题，这次使用 shared_ptr 而不是内置指针。</p>
</blockquote>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;vector&lt;int&gt;&gt; alloc_vector()</span><br><span class="line">&#123;</span><br><span class="line">	return std::make_shared&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assign_vector(std::shared_ptr&lt;vector&lt;int&gt;&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (std::cin &gt;&gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_vector(std::shared_ptr&lt;vector&lt;int&gt;&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	for (auto i : *p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto p = alloc_vector();</span><br><span class="line">	assign_vector(p);</span><br><span class="line">	print_vector(p);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>unique_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img13.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img14.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img15.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img16.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img17.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img18.PNG" alt></p>
<blockquote>
<p>如果你试图拷贝或赋值 unique_ptr，编译器并不总是能给出易于理解的错误信息。编写包含这种错误的程序，观察编译器如何诊断这种错误。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using std::string; using std::unique_ptr;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;string&gt; p1(new string(&quot;pezy&quot;));</span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;</span><br><span class="line">    p1.reset(nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>shared_ptr 为什么没有 release 成员？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">release 成员的作用是放弃控制权并返回指针，因为在某一时刻只能有一个 unique_ptr 指向某个对象，unique_ptr 不能被赋值，所以要使用 release 成员将一个 unique_ptr 的指针的所有权传递给另一个 unique_ptr。而 shared_ptr 允许有多个 shared_ptr 指向同一个对象，因此不需要 release 成员。</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>weak_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img19.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img20.PNG" alt></p>
<blockquote>
<p>定义你自己版本的 StrBlobPtr，更新 StrBlob 类，加入恰当的 friend 声明以及 begin 和 end 成员。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using std::vector; using std::string;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class StrBlobPtr;</span><br><span class="line">class ConstStrBlobStr;</span><br><span class="line"></span><br><span class="line">class StrBlob &#123;</span><br><span class="line">public:</span><br><span class="line">    friend class StrBlobPtr;</span><br><span class="line">    friend class ConstStrBlobPtr;</span><br><span class="line">    using size_type = vector&lt;string&gt;::size_type;</span><br><span class="line"></span><br><span class="line">    StrBlobPtr begin();</span><br><span class="line">    StrBlobPtr end();</span><br><span class="line">    ConstStrBlobPtr cbegin();</span><br><span class="line">    ConstStrBlobPtr cend();</span><br><span class="line">    StrBlob() :data(std::make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">    StrBlob(std::initializer_list&lt;string&gt; il) :data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">    bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const string&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">    void pop_back() &#123;</span><br><span class="line">        check(0, &quot;pop_back on empty StrBlob&quot;);</span><br><span class="line">        data-&gt;pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; front() &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; back() &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const std::string&amp; front() const &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line">    const std::string&amp; back() const &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void check(size_type i, const string&amp; msg) const &#123;</span><br><span class="line">        if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;vector&lt;string&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConstStrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    ConstStrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    ConstStrBlobPtr(const StrBlob&amp; a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    ConstStrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const ConstStrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    StrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConstStrBlobPtr StrBlob::cbegin()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">ConstStrBlobPtr StrBlob::cend()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::ifstream is(&quot;test.txt&quot;);</span><br><span class="line">    StrBlob sb;</span><br><span class="line">    string s;</span><br><span class="line">    while (getline(is, s)) &#123;</span><br><span class="line">        sb.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    for (StrBlobPtr sbp = sb.begin(); sbp != sb.end(); sbp.incr()) &#123;</span><br><span class="line">        cout &lt;&lt; sbp.deref() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写程序，逐行读入一个输入文件，将内容存入一个 StrBlob 中，用一个 StrBlobPtr 打印出 StrBlob 中的每个元素。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using std::vector; using std::string;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class StrBlobPtr;</span><br><span class="line">class ConstStrBlobStr;</span><br><span class="line"></span><br><span class="line">class StrBlob &#123;</span><br><span class="line">public:</span><br><span class="line">    friend class StrBlobPtr;</span><br><span class="line">    friend class ConstStrBlobPtr;</span><br><span class="line">    using size_type = vector&lt;string&gt;::size_type;</span><br><span class="line"></span><br><span class="line">    StrBlobPtr begin();</span><br><span class="line">    StrBlobPtr end();</span><br><span class="line">    ConstStrBlobPtr cbegin();</span><br><span class="line">    ConstStrBlobPtr cend();</span><br><span class="line">    StrBlob() :data(std::make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">    StrBlob(std::initializer_list&lt;string&gt; il) :data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">    bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const string&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">    void pop_back() &#123;</span><br><span class="line">        check(0, &quot;pop_back on empty StrBlob&quot;);</span><br><span class="line">        data-&gt;pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; front() &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; back() &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const std::string&amp; front() const &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line">    const std::string&amp; back() const &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void check(size_type i, const string&amp; msg) const &#123;</span><br><span class="line">        if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;vector&lt;string&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConstStrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    ConstStrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    ConstStrBlobPtr(const StrBlob&amp; a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    ConstStrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const ConstStrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    StrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConstStrBlobPtr StrBlob::cbegin()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">ConstStrBlobPtr StrBlob::cend()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs(&quot;books.txt&quot;);</span><br><span class="line">	StrBlob sb;</span><br><span class="line">	string s;</span><br><span class="line">	while (getline(ifs, s))</span><br><span class="line">	&#123;</span><br><span class="line">		sb.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	for (StrBlobPtr sbp = sb.begin(); sbp != sb.end(); sbp.incr())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; sbp.deref() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>智能指针最后练习</p>
</blockquote>
<h1>12.27：</h1>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img21.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img22.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img23.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img24.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img25.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img26.PNG" alt></p>
<blockquote>
<p>代码：</p>
</blockquote>
<ol>
<li>头文件：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#ifndef EX12_27_H</span><br><span class="line">#define EX12_27_H</span><br><span class="line"></span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">class QueryResult;</span><br><span class="line"></span><br><span class="line">class TextQuery</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// 类型定义</span><br><span class="line">	using line_no = std::vector&lt;std::string&gt;::size_type;</span><br><span class="line">	// 构造函数</span><br><span class="line">	TextQuery(std::ifstream&amp;);</span><br><span class="line">	QueryResult query(const std::string&amp; s) const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	// 保存输入文件的一份拷贝，输入文件中的每行保存为vector中的一个元素。当需要打印一行时，</span><br><span class="line">	// 可以用行号作为下标来提取行文本</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</span><br><span class="line">	// 使用一个map来将每个单词与它出现的行号set关联起来，可以方便地提取任意单词的set</span><br><span class="line">	std::map&lt;std::string, std::shared_ptr&lt;std::set&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class QueryResult</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	friend std::ostream&amp; print(std::ostream&amp;, const QueryResult&amp;);</span><br><span class="line"></span><br><span class="line">	QueryResult(std::string s,</span><br><span class="line">		std::shared_ptr&lt;std::set&lt;TextQuery::line_no&gt;&gt; p,</span><br><span class="line">		std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; f) :</span><br><span class="line">		sought(s), lines(p), file(f)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	std::string sought;</span><br><span class="line">	// 使用set来保存每个单词在输入文本中出现的行号，保证每行只出现一次且行号按升序保存</span><br><span class="line">	std::shared_ptr&lt;std::set&lt;TextQuery::line_no&gt;&gt; lines;</span><br><span class="line">	// 保存输入文件的一份拷贝，输入文件中的每行保存为vector中的一个元素。当需要打印一行时，</span><br><span class="line">	// 可以用行号作为下标来提取行文本</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; print(std::ostream&amp;, const QueryResult&amp;);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>功能实现</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ex12_27.h&quot;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">TextQuery::TextQuery(ifstream&amp; ifs) : file(new vector&lt;string&gt;)</span><br><span class="line">&#123;</span><br><span class="line">	string text;</span><br><span class="line">	// 获取一行</span><br><span class="line">	while (getline(ifs, text))</span><br><span class="line">	&#123;</span><br><span class="line">		// 输入文件中的每行保存为vector中的一个元素</span><br><span class="line">		file-&gt;push_back(text);</span><br><span class="line">		// 从0开始, file-&gt;size()从1开始</span><br><span class="line">		int n = file-&gt;size() - 1;</span><br><span class="line">		cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">		istringstream line(text);</span><br><span class="line">		string word;</span><br><span class="line">		while (line &gt;&gt; word)</span><br><span class="line">		&#123;</span><br><span class="line">			// 获取行号,wm[word] -&gt; size_t</span><br><span class="line">			auto&amp; lines = wm[word];</span><br><span class="line">			// cout &lt;&lt; &quot; [word] = &quot; &lt;&lt; word;</span><br><span class="line">			if (!lines)</span><br><span class="line">				lines.reset(new set&lt;line_no&gt;);</span><br><span class="line">			// cout &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">			lines-&gt;insert(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueryResult TextQuery::query(const string&amp; s) const</span><br><span class="line">&#123;</span><br><span class="line">	static shared_ptr&lt;set&lt;line_no&gt;&gt; nodata(new set&lt;line_no&gt;);</span><br><span class="line">	auto loc = wm.find(s);</span><br><span class="line">	// 如果找到返回行数</span><br><span class="line">	if (loc == wm.end())</span><br><span class="line">		return QueryResult(s, nodata, file);</span><br><span class="line">	else</span><br><span class="line">		return QueryResult(s, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印</span><br><span class="line">std::ostream&amp; print(std::ostream&amp; os, const QueryResult&amp; qr)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; qr.sought &lt;&lt; &quot; occurs &quot; &lt;&lt; qr.lines-&gt;size() &lt;&lt; &quot; &quot;</span><br><span class="line">		&lt;&lt; &quot;time&quot; &lt;&lt; (qr.lines-&gt;size() &gt; 1 ? &quot;s&quot; : &quot;&quot;) &lt;&lt; endl;</span><br><span class="line">	for (auto num : *qr.lines)</span><br><span class="line">		os &lt;&lt; &quot;\t(line &quot; &lt;&lt; num + 1 &lt;&lt; &quot;) &quot; &lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; endl;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>main函数实现</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &quot;ex12_27.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void runQueries(ifstream&amp; infile)</span><br><span class="line">&#123;</span><br><span class="line">	TextQuery tq(infile);</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;enter word to look for, or q to quit: &quot;;</span><br><span class="line">		string s;</span><br><span class="line">		if (!(cin &gt;&gt; s) || s == &quot;q&quot;) break;</span><br><span class="line">		print(cout, tq.query(s)) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs(&quot;test.txt&quot;);</span><br><span class="line">	runQueries(ifs);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>12.28</h1>
<blockquote>
<p>编写程序实现文本查询，不要定义类来管理数据。你的程序应该接受一个文件，并与用户交互来查询单词。使用vector、map 和 set 容器来保存来自文件的数据并生成查询结果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using std::string;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using std::shared_ptr;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::ifstream file(&quot;test.txt&quot;);</span><br><span class="line">	vector&lt;string&gt; input;</span><br><span class="line">	std::map&lt;string, std::set&lt;decltype(input.size())&gt;&gt; dictionary;</span><br><span class="line">	// size_t</span><br><span class="line">	decltype(input.size()) lineNo&#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">	for (string line; std::getline(file, line); ++lineNo)</span><br><span class="line">	&#123;</span><br><span class="line">		input.push_back(line);</span><br><span class="line">		std::istringstream line_stream(line);</span><br><span class="line">		for (string text, word; line_stream &gt;&gt; text; word.clear())</span><br><span class="line">		&#123;</span><br><span class="line">			// ispunct检查参数c是否为标点符号或特殊符号</span><br><span class="line">			// 将text不符合ispunct复制到word后</span><br><span class="line">			std::cout &lt;&lt; &quot;word-before : &quot; &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">			std::remove_copy_if(text.begin(), text.end(), std::back_inserter(word), ispunct);</span><br><span class="line">			std::cout &lt;&lt; &quot;word_after : &quot; &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">			dictionary[word].insert(lineNo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;enter word to look for, or q to quit: &quot;;</span><br><span class="line">		string s;</span><br><span class="line">		if (!(std::cin &gt;&gt; s) || s == &quot;q&quot;) break;</span><br><span class="line">		auto found = dictionary.find(s);</span><br><span class="line">		if (found != dictionary.end())</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; s &lt;&lt; &quot; occurs &quot; &lt;&lt; found-&gt;second.size() &lt;&lt; (found-&gt;second.size() &gt; 1 ? &quot; times&quot; : &quot; time&quot;) &lt;&lt; std::endl;</span><br><span class="line">			for (auto i : found-&gt;second)</span><br><span class="line">				std::cout &lt;&lt; &quot;\t(line &quot; &lt;&lt; i + 1 &lt;&lt; &quot;) &quot; &lt;&lt; input.at(i) &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else std::cout &lt;&lt; s &lt;&lt; &quot; occurs 0 time&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/" class="post-title-link" itemprop="url">面试小知识: delete 和 delete[]</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-14 20:05:28" itemprop="dateCreated datePublished" datetime="2022-07-14T20:05:28+08:00">2022-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-17 09:54:22" itemprop="dateModified" datetime="2022-07-17T09:54:22+08:00">2022-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>面试小知识 delete 和 delete[]的区别</p>
</blockquote>
<ol>
<li>区别是什么？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前提 ： 在自定义类型下</span><br><span class="line">delete用来释放new分配的单个对象指针指向的内存，</span><br><span class="line">delete[] : 用来释放new分配的对象数组指针指向的内存。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img5.PNG" alt></p>
<blockquote>
<p>可见网址: <a target="_blank" rel="noopener" href="https://blog.csdn.net/heibao111728/article/details/84952023">https://blog.csdn.net/heibao111728/article/details/84952023</a></p>
</blockquote>
<hr>
<p>追加： 动态数组</p>
<blockquote>
<ol>
<li>new</li>
</ol>
</blockquote>
<p><img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img1.PNG" alt><br>
等同于<br>
<img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img2.PNG" alt></p>
<hr>
<p><img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img3.PNG" alt><br>
<img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img4.PNG" alt></p>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/14/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">统计学习方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-14 18:30:28" itemprop="dateCreated datePublished" datetime="2022-07-14T18:30:28+08:00">2022-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 16:16:20" itemprop="dateModified" datetime="2022-07-26T16:16:20+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一写文章就开始啰嗦…">一写文章就开始啰嗦…</h4>
<blockquote>
<p>感知机</p>
</blockquote>
<p>1.1 感知机详解链接：<a target="_blank" rel="noopener" href="https://www.pkudodo.com/2018/11/18/1-4/">https://www.pkudodo.com/2018/11/18/1-4/</a></p>
<p>1.2 MNIST训练集下载：</p>
<pre><code>1.2.1 进入如下网址下载：
    https://github.com/Dod-o/Statistical-Learning-Method_Code
1.2.2 点击Mnist 解压即可
</code></pre>
<p>1.3 将csv放入文件夹<br>
1.4 贴代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def loadData(fileName):</span><br><span class="line">    </span><br><span class="line"># 加载Mnist数据集</span><br><span class="line"># :param fileName:要加载的数据集路径</span><br><span class="line"># :return: list形式的数据集及标记</span><br><span class="line"> </span><br><span class="line">print(&#x27;start to read data&#x27;)</span><br><span class="line"># 存放数据及标记的list</span><br><span class="line">dataArr = []; labelArr = []</span><br><span class="line"># 打开文件</span><br><span class="line">fr = open(fileName, &#x27;r&#x27;)</span><br><span class="line"># 将文件按行读取</span><br><span class="line">for line in fr.readlines():</span><br><span class="line">    # 对每一行数据按切割福&#x27;,&#x27;进行切割，返回字段列表</span><br><span class="line">    curLine = line.strip().split(&#x27;,&#x27;)</span><br><span class="line">    # 最左边的是标签</span><br><span class="line">    # Mnsit有0-9是个标记，由于是二分类任务，所以将&gt;=5的作为1，&lt;5为-1</span><br><span class="line">    if int(curLine[0]) &gt;= 5:</span><br><span class="line">        labelArr.append(1)</span><br><span class="line">    else:</span><br><span class="line">        labelArr.append(-1)</span><br><span class="line">    #存放标记</span><br><span class="line">    #[int(num) for num in curLine[1:]] -&gt; 遍历每一行中除了以第一个元素（标记）外将所有元素转换成int类型</span><br><span class="line">    #[int(num)/255 for num in curLine[1:]] -&gt; 将所有数据除255归一化(非必须步骤，可以不归一化)</span><br><span class="line">    dataArr.append([int(num)/255 for num in curLine[1:]])</span><br><span class="line"></span><br><span class="line">#返回data和label</span><br><span class="line">return dataArr, labelArr</span><br><span class="line"></span><br><span class="line">def perceptron(dataArr, labelArr, iter=50):</span><br><span class="line">    </span><br><span class="line">    # 感知器训练过程</span><br><span class="line">    # :param dataArr:训练集的数据 (list)</span><br><span class="line">    # :param labelArr: 训练集的标签(list)</span><br><span class="line">    # :param iter: 迭代次数，默认50</span><br><span class="line">    # :return: 训练好的w和b</span><br><span class="line"></span><br><span class="line">    print(&#x27;start to trans&#x27;)</span><br><span class="line">    #将数据转换成矩阵形式（在机器学习中因为通常都是向量的运算，转换称矩阵形式方便运算）</span><br><span class="line">    #转换后的数据中每一个样本的向量都是横向的</span><br><span class="line">    dataMat = np.mat(dataArr)</span><br><span class="line">    #将标签转换成矩阵，之后转置(.T为转置)。</span><br><span class="line">    #转置是因为在运算中需要单独取label中的某一个元素，如果是1xN的矩阵的话，无法用label[i]的方式读取</span><br><span class="line">    #对于只有1xN的label可以不转换成矩阵，直接label[i]即可，这里转换是为了格式上的统一</span><br><span class="line">    labelMat = np.mat(labelArr).T</span><br><span class="line">    #获取数据矩阵的大小，为m*n</span><br><span class="line">    m, n = np.shape(dataMat) # 60000 * 784</span><br><span class="line">    print(&#x27;------------&#x27;,m, n,&#x27;-------------------&#x27;)</span><br><span class="line">    #创建初始权重w，初始值全为0。</span><br><span class="line">    #np.shape(dataMat)的返回值为m，n -&gt; np.shape(dataMat)[1])的值即为n，与</span><br><span class="line">    #样本长度保持一致</span><br><span class="line">    # 1 * n</span><br><span class="line">    w = np.zeros((1, np.shape(dataMat)[1]))</span><br><span class="line">    #初始化偏置b为0</span><br><span class="line">    b = 0</span><br><span class="line">    #初始化步长，也就是梯度下降过程中的n，控制梯度下降速率</span><br><span class="line">    h = 0.0001</span><br><span class="line"></span><br><span class="line">    #进行iter次迭代计算</span><br><span class="line">    for k in range(iter):</span><br><span class="line">        #对于每一个样本进行梯度下降</span><br><span class="line">        #李航书中在2.3.1开头部分使用的梯度下降，是全部样本都算一遍以后，统一</span><br><span class="line">        #进行一次梯度下降</span><br><span class="line">        #在2.3.1的后半部分可以看到（例如公式2.6 2.7），求和符号没有了，此时用</span><br><span class="line">        #的是随机梯度下降，即计算一个样本就针对该样本进行一次梯度下降。</span><br><span class="line">        #两者的差异各有千秋，但较为常用的是随机梯度下降。</span><br><span class="line">        for i in range(m):</span><br><span class="line">            #获取当前样本的向量</span><br><span class="line">            xi = dataMat[i]</span><br><span class="line">            #获取当前样本所对应的标签</span><br><span class="line">            yi = labelMat[i]</span><br><span class="line">            #判断是否是误分类样本</span><br><span class="line">            #误分类样本特征为： -yi(w*xi+b)&gt;=0，详细可参考书中2.2.2小节</span><br><span class="line">            #在书的公式中写的是&gt;0，实际上如果=0，说明改点在超平面上，也是不正确的</span><br><span class="line">            if -1 * yi * (w * xi.T + b) &gt;= 0:</span><br><span class="line">                #对于误分类样本，进行梯度下降，更新w和b</span><br><span class="line">                #按公式进行更新</span><br><span class="line">                w = w + h *  yi * xi</span><br><span class="line">                b = b + h * yi</span><br><span class="line">        #打印训练进度</span><br><span class="line">        print(&#x27;Round %d:%d training&#x27; % (k, iter))</span><br><span class="line"></span><br><span class="line">    #返回训练完的w、b</span><br><span class="line">    return w, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test(dataArr, labelArr, w, b):</span><br><span class="line">   </span><br><span class="line">    # 测试准确率</span><br><span class="line">    # :param dataArr:测试集</span><br><span class="line">    # :param labelArr: 测试集标签</span><br><span class="line">    # :param w: 训练获得的权重w</span><br><span class="line">    # :param b: 训练获得的偏置b</span><br><span class="line">    # :return: 正确率</span><br><span class="line">    </span><br><span class="line">    print(&#x27;start to test&#x27;)</span><br><span class="line">    #将数据集转换为矩阵形式方便运算</span><br><span class="line">    dataMat = np.mat(dataArr)</span><br><span class="line">    #将label转换为矩阵并转置，详细信息参考上文perceptron中</span><br><span class="line">    #对于这部分的解说</span><br><span class="line">    labelMat = np.mat(labelArr).T</span><br><span class="line"></span><br><span class="line">    #获取测试数据集矩阵的大小</span><br><span class="line">    m, n = np.shape(dataMat)</span><br><span class="line">    #错误样本数计数</span><br><span class="line">    errorCnt = 0</span><br><span class="line">    #遍历所有测试样本</span><br><span class="line">    for i in range(m):</span><br><span class="line">        #获得单个样本向量</span><br><span class="line">        xi = dataMat[i]</span><br><span class="line">        #获得该样本标记</span><br><span class="line">        yi = labelMat[i]</span><br><span class="line">        #获得运算结果</span><br><span class="line">        result = -1 * yi * (w * xi.T + b)</span><br><span class="line">        #如果-yi(w*xi+b)&gt;=0，说明该样本被误分类，错误样本数加一</span><br><span class="line">        if result &gt;= 0:</span><br><span class="line">            errorCnt += 1</span><br><span class="line">    #正确率 = 1 - （样本分类错误数 / 样本总数）</span><br><span class="line">    accruRate = 1 - (errorCnt / m)</span><br><span class="line">    #返回正确率</span><br><span class="line">    return accruRate</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    #获取当前时间</span><br><span class="line">    #在文末同样获取当前时间，两时间差即为程序运行时间</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    #获取训练集及标签</span><br><span class="line">    trainData, trainLabel = loadData(&#x27;./mnist_train/mnist_train.csv&#x27;)</span><br><span class="line">    #print(&#x27;train_Data :&#123;0&#125;, train_Label : &#123;1&#125;&#x27;, trainData, trainLabel)</span><br><span class="line"></span><br><span class="line">    #获取测试集及标签</span><br><span class="line">    testData, testLabel = loadData(&#x27;./mnist_test/mnist_test.csv&#x27;)</span><br><span class="line"></span><br><span class="line">    #训练获得权重</span><br><span class="line">    w, b = perceptron(trainData, trainLabel, iter = 30)</span><br><span class="line">    #进行测试，获得正确率</span><br><span class="line">    accruRate = test(testData, testLabel, w, b)</span><br><span class="line"></span><br><span class="line">    #获取当前时间，作为结束时间</span><br><span class="line">    end = time.time()</span><br><span class="line">    #显示正确率</span><br><span class="line">    print(&#x27;accuracy rate is:&#x27;, accruRate)</span><br><span class="line">    #显示用时时长</span><br><span class="line">    print(&#x27;time span:&#x27;, end - start)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<blockquote>
<p>K近邻</p>
</blockquote>
<p>1.1 K近邻详解：<a target="_blank" rel="noopener" href="https://www.pkudodo.com/2018/11/19/1-2/">https://www.pkudodo.com/2018/11/19/1-2/</a></p>
<p>1.2 MNIST训练集下载：</p>
<pre><code>1.2.1 进入如下网址下载：
    https://github.com/Dod-o/Statistical-Learning-Method_Code
1.2.2 点击Mnist 解压即可
</code></pre>
<p>1.3 将csv放入文件夹<br>
1.4 贴代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line"># Author:Dodo</span><br><span class="line"># Date:2018-11-16</span><br><span class="line"># Email:lvtengchao@pku.edu.cn</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">数据集：Mnist</span><br><span class="line">训练集数量：60000</span><br><span class="line">测试集数量：10000（实际使用：200）</span><br><span class="line">------------------------------</span><br><span class="line">运行结果：（邻近k数量：25）</span><br><span class="line">向量距离使用算法——欧式距离</span><br><span class="line">    正确率：97%</span><br><span class="line">    运行时长：308s</span><br><span class="line">向量距离使用算法——曼哈顿距离</span><br><span class="line">    正确率：14%</span><br><span class="line">    运行时长：246s</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import numpy as np</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loadData(fileName):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    加载文件</span><br><span class="line">    :param fileName:要加载的文件路径</span><br><span class="line">    :return: 数据集和标签集</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;start read file&#x27;)</span><br><span class="line">    # 存放数据及标记</span><br><span class="line">    dataArr = [];</span><br><span class="line">    labelArr = []</span><br><span class="line">    # 读取文件</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    # 遍历文件中的每一行</span><br><span class="line">    for line in fr.readlines():</span><br><span class="line">        # 获取当前行，并按“，”切割成字段放入列表中</span><br><span class="line">        # strip：去掉每行字符串首尾指定的字符（默认空格或换行符）</span><br><span class="line">        # split：按照指定的字符将字符串切割成每个字段，返回列表形式</span><br><span class="line">        curLine = line.strip().split(&#x27;,&#x27;)</span><br><span class="line">        # 将每行中除标记外的数据放入数据集中（curLine[0]为标记信息）</span><br><span class="line">        # 在放入的同时将原先字符串形式的数据转换为整型</span><br><span class="line">        dataArr.append([int(num) for num in curLine[1:]])</span><br><span class="line">        # 将标记信息放入标记集中</span><br><span class="line">        # 放入的同时将标记转换为整型</span><br><span class="line">        labelArr.append(int(curLine[0]))</span><br><span class="line">    # 返回数据集和标记</span><br><span class="line">    return dataArr, labelArr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def calcDist(x1, x2):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    计算两个样本点向量之间的距离</span><br><span class="line">    使用的是欧氏距离，即 样本点每个元素相减的平方  再求和  再开方</span><br><span class="line">    欧式举例公式这里不方便写，可以百度或谷歌欧式距离（也称欧几里得距离）</span><br><span class="line">    :param x1:向量1</span><br><span class="line">    :param x2:向量2</span><br><span class="line">    :return:向量之间的欧式距离</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    return np.sqrt(np.sum(np.square(x1 - x2)))</span><br><span class="line">    # 马哈顿距离计算公式</span><br><span class="line">    # return np.sum(x1 - x2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getClosest(trainDataMat, trainLabelMat, x, topK):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    预测样本x的标记。</span><br><span class="line">    获取方式通过找到与样本x最近的topK个点，并查看它们的标签。</span><br><span class="line">    查找里面占某类标签最多的那类标签</span><br><span class="line">    （书中3.1 3.2节）</span><br><span class="line">    :param trainDataMat:训练集数据集</span><br><span class="line">    :param trainLabelMat:训练集标签集</span><br><span class="line">    :param x:要预测的样本x</span><br><span class="line">    :param topK:选择参考最邻近样本的数目（样本数目的选择关系到正确率，详看3.2.3 K值的选择）</span><br><span class="line">    :return:预测的标记</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 建立一个存放向量x与每个训练集中样本距离的列表</span><br><span class="line">    # 列表的长度为训练集的长度，distList[i]表示x与训练集中第</span><br><span class="line">    ## i个样本的距离</span><br><span class="line">    distList = [0] * len(trainLabelMat)</span><br><span class="line">    # 遍历训练集中所有的样本点，计算与x的距离</span><br><span class="line">    for i in range(len(trainDataMat)):</span><br><span class="line">        # 获取训练集中当前样本的向量</span><br><span class="line">        x1 = trainDataMat[i]</span><br><span class="line">        # 计算向量x与训练集样本x的距离</span><br><span class="line">        curDist = calcDist(x1, x)</span><br><span class="line">        # 将距离放入对应的列表位置中</span><br><span class="line">        distList[i] = curDist</span><br><span class="line">    # 对距离列表进行排序</span><br><span class="line">    # argsort：函数将数组的值从小到大排序后，并按照其相对应的索引值输出</span><br><span class="line">    # 例如：</span><br><span class="line">    #   &gt;&gt;&gt; x = np.array([3, 1, 2])</span><br><span class="line">    #   &gt;&gt;&gt; np.argsort(x)</span><br><span class="line">    #   array([1, 2, 0])</span><br><span class="line">    # 返回的是列表中从小到大的元素索引值，对于我们这种需要查找最小距离的情况来说很合适</span><br><span class="line">    # array返回的是整个索引值列表，我们通过[:topK]取列表中前topL个放入list中。</span><br><span class="line">    # ----------------优化点-------------------</span><br><span class="line">    # 由于我们只取topK小的元素索引值，所以其实不需要对整个列表进行排序，而argsort是对整个</span><br><span class="line">    # 列表进行排序的，存在时间上的浪费。字典有现成的方法可以只排序top大或top小，可以自行查阅</span><br><span class="line">    # 对代码进行稍稍修改即可</span><br><span class="line">    # 这里没有对其进行优化主要原因是KNN的时间耗费大头在计算向量与向量之间的距离上，由于向量高维</span><br><span class="line">    # 所以计算时间需要很长，所以如果要提升时间，在这里优化的意义不大。</span><br><span class="line">    # 这边这么写是因为一维的数组，画张图就能理解</span><br><span class="line">    topKList = np.argsort(np.array(distList))[:topK]  # 升序排序</span><br><span class="line">    # 建立一个长度时的列表，用于选择数量最多的标记</span><br><span class="line">    # 3.2.4提到了分类决策使用的是投票表决，topK个标记每人有一票，在数组中每个标记代表的位置中投入</span><br><span class="line">    # 自己对应的地方，随后进行唱票选择最高票的标记</span><br><span class="line">    # 这里是分配10个空间，初始值为0</span><br><span class="line">    labelList = [0] * 10</span><br><span class="line">    # 对topK个索引进行遍历</span><br><span class="line">    for index in topKList:</span><br><span class="line">        # trainLabelMat[index]：在训练集标签中寻找topK元素索引对应的标记</span><br><span class="line">        # int(trainLabelMat[index])：将标记转换为int（实际上已经是int了，但是不int的话，报错）</span><br><span class="line">        # labelList[int(trainLabelMat[index])]：找到标记在labelList中对应的位置</span><br><span class="line">        # 最后加1，表示投了一票</span><br><span class="line">        labelList[int(trainLabelMat[index])] += 1</span><br><span class="line">    # max(labelList)：找到选票箱中票数最多的票数值</span><br><span class="line">    # labelList.index(max(labelList))：再根据最大值在列表中找到该值对应的索引，等同于预测的标记</span><br><span class="line">    return labelList.index(max(labelList))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test(trainDataArr, trainLabelArr, testDataArr, testLabelArr, topK):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    测试正确率</span><br><span class="line">    :param trainDataArr:训练集数据集</span><br><span class="line">    :param trainLabelArr: 训练集标记</span><br><span class="line">    :param testDataArr: 测试集数据集</span><br><span class="line">    :param testLabelArr: 测试集标记</span><br><span class="line">    :param topK: 选择多少个邻近点参考</span><br><span class="line">    :return: 正确率</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;start test&#x27;)</span><br><span class="line">    # 将所有列表转换为矩阵形式，方便运算</span><br><span class="line">    trainDataMat = np.mat(trainDataArr);</span><br><span class="line">    trainLabelMat = np.mat(trainLabelArr).T</span><br><span class="line">    testDataMat = np.mat(testDataArr);</span><br><span class="line">    testLabelMat = np.mat(testLabelArr).T</span><br><span class="line">    # 错误值技术</span><br><span class="line">    errorCnt = 0</span><br><span class="line">    # 遍历测试集，对每个测试集样本进行测试</span><br><span class="line">    # 由于计算向量与向量之间的时间耗费太大，测试集有6000个样本，所以这里人为改成了</span><br><span class="line">    # 测试200个样本点，如果要全跑，将行注释取消，再下一行for注释即可，同时下面的print</span><br><span class="line">    # 和return也要相应的更换注释行</span><br><span class="line">    # for i in range(len(testDataMat)):</span><br><span class="line">    for i in range(200):</span><br><span class="line">        # print(&#x27;test %d:%d&#x27;%(i, len(trainDataArr)))</span><br><span class="line">        print(&#x27;test %d:%d&#x27; % (i, 200))</span><br><span class="line">        # 读取测试集当前测试样本的向量</span><br><span class="line">        x = testDataMat[i]</span><br><span class="line">        # 获取预测的标记</span><br><span class="line">        y = getClosest(trainDataMat, trainLabelMat, x, topK)</span><br><span class="line">        # 如果预测标记与实际标记不符，错误值计数加1</span><br><span class="line">        if y != testLabelMat[i]: errorCnt += 1</span><br><span class="line">    # 返回正确率</span><br><span class="line">    # return 1 - (errorCnt / len(testDataMat))</span><br><span class="line">    return 1 - (errorCnt / 200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start = time.time()</span><br><span class="line">    # 获取训练集</span><br><span class="line">    trainDataArr, trainLabelArr = loadData(&#x27;./mnist_train/mnist_train.csv&#x27;)</span><br><span class="line">    # 获取测试集</span><br><span class="line">    testDataArr, testLabelArr = loadData(&#x27;./mnist_test/mnist_test.csv&#x27;)</span><br><span class="line">    # 计算测试集正确率</span><br><span class="line">    accur = test(trainDataArr, trainLabelArr, testDataArr, testLabelArr, 25)</span><br><span class="line">    # 打印正确率</span><br><span class="line">    print(&#x27;accur is:%d&#x27; % (accur * 100), &#x27;%&#x27;)</span><br><span class="line">    end = time.time()</span><br><span class="line">    # 显示花费时间</span><br><span class="line">print(&#x27;time span:&#x27;, end - start)</span><br></pre></td></tr></table></figure>
<p>KD树：</p>
<blockquote>
<p>还未实现，只找了外链</p>
</blockquote>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=853980597&bvid=BV1EL4y1F7sz&cid=717808316&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</div>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Willson-Xbort"
      src="/images/ico.jpg">
  <p class="site-author-name" itemprop="name">Willson-Xbort</p>
  <div class="site-description" itemprop="description">none</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wilson-xbort" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wilson-xbort" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Willson-Xbort</span>

  <!-- after add-->
  <!---->
</div>





        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
