<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Gelasio:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wilson-xbort.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="none">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://wilson-xbort.github.io/page/2/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="none">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Willson-Xbort">
<meta property="article:tag" content="Hexo, NexT">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wilson-xbort.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

  <!--此处为建站时间 -->
  <!--<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("09/24/2018 23:45:01");
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML ="(ㆆᴗㆆ)本弱已菜菜的存活了"+dnum+"&thinsp;天"; 
        document.getElementById("times").innerHTML = hnum + "&thinsp;时" + mnum + "&thinsp;分" + snum + "&thinsp;秒"; 
    } 
  setInterval("createtime()",250);-->


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/08/git%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/git%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">git使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-08 13:37:18 / 修改时间：14:04:20" itemprop="dateCreated datePublished" datetime="2022-08-08T13:37:18+08:00">2022-08-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>快速入门</h1>
<h2 id="1-找到要上传的文件夹（Win10">1. 找到要上传的文件夹（Win10)</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.1 右击出现 Git Bash Here</span><br><span class="line">1.2 配置好邮箱，用户名，密码</span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx&quot;</span><br><span class="line">git config --global user.password &quot;xxx&quot;</span><br></pre></td></tr></table></figure>
<h2 id="2-基本指令">2.基本指令</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 初始化git, 会出现.git的文件夹</span><br><span class="line">git init</span><br><span class="line">// 可加可不加</span><br><span class="line">git add README.md </span><br><span class="line">// git commit 命令将暂存区内容添加到本地仓库</span><br><span class="line">git commit -m &quot;first commit&quot; </span><br><span class="line">// 创建一个新的本地分支main, 不进行切换</span><br><span class="line">git branch -M main</span><br><span class="line">// 添加远程仓库地址</span><br><span class="line">git remote add origin https://github.com/Wilson-Xbort/test.git </span><br><span class="line">// 将本地的 main 分支推送到 origin 主机的 main 分支。</span><br><span class="line">git push -u origin main</span><br><span class="line">// 压缩成.bundle</span><br><span class="line">git bundle create xxx.bundle HEAD main</span><br><span class="line">// 验证校验是否合法</span><br><span class="line">git bundle verify ./xxx.bundle</span><br><span class="line">// 删除远程库</span><br><span class="line">git remote rm origin</span><br><span class="line">// 解压.bundle</span><br><span class="line">git clone xxx.bundle</span><br></pre></td></tr></table></figure>
<h2 id="3-error和解决方式">3. error和解决方式</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. error: failed to push some refs to &#x27;https://github.com/xxx/xxx.git&#x27;</span><br><span class="line">2. Git:nothing added to commit but untracked files present</span><br><span class="line">3. fatal: Updating an unborn branch with changes added to the index.</span><br></pre></td></tr></table></figure>
<h2 id="解决方法">解决方法</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add -A 或者 git add --all</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">虚函数复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-05 08:52:47" itemprop="dateCreated datePublished" datetime="2022-08-05T08:52:47+08:00">2022-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 20:03:10" itemprop="dateModified" datetime="2022-08-22T20:03:10+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>C++ primer 第15章 面向对象程序设计</h1>
<h1>虚函数</h1>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img1.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img2.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img3.PNG" alt></p>
<h2 id="final-和-override">final 和 override</h2>
<blockquote>
<p>final 不允许后续的其他类覆盖<br>
override 帮助编译器说明派生类中的虚函数</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img4.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img5.PNG" alt></p>
<h2 id="抽象基类-含有纯虚函数）">抽象基类(含有纯虚函数）</h2>
<blockquote>
<p>有纯虚函数的类才称之为抽象类</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img6.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img7.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img8.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img9.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img10.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img11.PNG" alt></p>
<h2 id="虚析构函数">虚析构函数</h2>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img12.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img13.PNG" alt></p>
<h2 id="重载和隐藏">重载和隐藏</h2>
<blockquote>
<p>同一作用域，那就是重载。不同作用域，那就是隐藏。</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img14.PNG" alt></p>
<h1>虚继承</h1>
<h2 id="前置：">前置：</h2>
<blockquote>
<p>IO标准库的istream 和 ostream分别继承了base_ios的抽象基类。改抽象基类负责保存流的缓冲内容并管理流的条件状态。iostream是另外一个类，<br>
它从istream和ostream直接继承而来，可以同时读写流的内容。因为istream和ostream都继承自base_ios，所以iostream继承了base_ios两次，一次是通过<br>
istream，另一次通过ostream。<br>
在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了很多次，则派生类中将包含该类的多个子对象。<br>
这种默认的情况对某些形如iostream的类显然是行不通的。一个iostream对象肯定希望在同一个缓冲区中进行读写操作，也会要求条件状态能同时反映输入和输出操作的情况。<br>
加入在iostream对象中真的包含了base_ios的两份拷贝，则上述的共享行为就无法实现。</p>
</blockquote>
<h2 id="实现：">实现：</h2>
<h3 id="如图：-3">如图：</h3>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img15.PNG" alt></p>
<blockquote>
<p>对于Panda进行修改，使其同时继承Raccoon科和Bear科，此时，为了避免赋予Panda两份ZooAnimal的子对象，我们将Bear和Raccoon继承ZooAnimal的方式定义为虚继承。</p>
</blockquote>
<h3 id="使用虚基类：">使用虚基类：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码我们将ZooAnimal定义为Raccoon和Bear的虚基类。<br>
virtual说明符表面了一种愿望，即在后续派生类中共享虚基类的同一份实例。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span> : <span class="keyword">public</span> Bear,</span><br><span class="line">			  <span class="keyword">public</span> Raccoon, <span class="keyword">public</span> Endangered&#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Panda通过Raccoon和Bear继承了ZooAnimal,因为Raccoon和Bear继承ZooAnimal的方式都是虚继承，所以Panda中只有一个ZooAnimal基类部分。</p>
</blockquote>
<h3 id="构造函数和虚继承">构造函数和虚继承</h3>
<blockquote>
<p>在虚派生中，虚基类是由最底层的派生类初始化的。<br>
只要我们能创建虚基类的派生类对象(Bear/Raccoon),该派生类的构造函数就必须初始化它的虚基类。当创建一个Bear/Raccoon对象时，它已经位于派生的最底层，因此<br>
Bear/Raccoon的构造函数将直接初始化其ZooAnimal基类部分</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bear::<span class="built_in">Bear</span>(std::string name, <span class="type">bool</span> onExhibit):</span><br><span class="line">	<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Bear&quot;</span>) &#123; &#125;</span><br><span class="line">Raccoon::<span class="built_in">Raccoon</span>(std::string name, <span class="type">bool</span> onExhibit):</span><br><span class="line">	<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Raccoon&quot;</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而当创建一个Panda对象时，Panda位于派生类的最底层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Panda::<span class="built_in">Panda</span>(std::string name, <span class="type">bool</span> onExhibit)</span><br><span class="line">	:<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Panda&quot;</span>),</span><br><span class="line">	<span class="built_in">Bear</span>(name, onExhibit),</span><br><span class="line">	<span class="built_in">Raccoon</span>(name, onExhibit),</span><br><span class="line">	<span class="built_in">Endangered</span>(Endangered::critical),</span><br><span class="line">	<span class="built_in">sleeping_flag</span>(<span class="literal">false</span>) &#123; .. &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。</span><br><span class="line">2. 接下来构造Bear部分</span><br><span class="line">3. 构造Raccoon部分</span><br><span class="line">4. 构造第三直接基类Endangered</span><br><span class="line">5. 最后构造Panda部分</span><br><span class="line"></span><br><span class="line">如果Panda没有显示地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/27/const-%E5%92%8C-static/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/27/const-%E5%92%8C-static/" class="post-title-link" itemprop="url">const 和 static</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-27 08:32:51 / 修改时间：09:43:53" itemprop="dateCreated datePublished" datetime="2022-07-27T08:32:51+08:00">2022-07-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>const 复习</p>
</blockquote>
<p>1.const 有哪些用法？</p>
<pre><code>1.const修饰变量，使得变量成为一个常量
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img1.PNG" alt><br>
注意点：const 变量要初始化</p>
<pre><code>2.默认情况下,const对象只在文件内有效
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img2.PNG" alt></p>
<pre><code>3.const 可以引用
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img3.PNG" alt><br>
注意点：const不能改变</p>
<pre><code>4.const 指针
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img4.PNG" alt><br>
有以下几种形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span>* p; <span class="comment">//指针本身可以修改，指向的内容不能修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p; <span class="comment">//指针本身可以修改，指向的内容不能修改 -》 指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p; <span class="comment">// 指针本身不能修改，指向的内容可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* <span class="type">const</span> p; <span class="comment">// 指针本身不能修改，指向的内容不能修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p; <span class="comment">// 指针本身不能修改，指向的内容不能修改</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img5.PNG" alt><br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img6.PNG" alt></p>
<pre><code>5. const 加在函数后方，不能修改成员变量
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img7.PNG" alt><br>
提示：只允许在类的非static成员函数后加const<br>
注意点：函数后加的const其实this指针进行修饰，即const *this</p>
<blockquote>
<p>static 复习</p>
</blockquote>
<p>2.static 有哪些用法？</p>
<pre><code>1. 修饰局部变量
</code></pre>
<p>看代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img8.PNG" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img9.PNG" alt></p>
<blockquote>
<p>static 修饰的局部变量(静态变量)是存储在静态区内部，而不再是本来的栈区，它的生命周期和程序的生命周期已经一样长。<br>
也就是说 静态变量出了作用域{} 也不会被销毁，除非程序结束。</p>
</blockquote>
<pre><code>2.修饰全局变量
</code></pre>
<p>测试：头文件不影响extern<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img10.PNG" alt><br>
和<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img11.PNG" alt></p>
<p>但是在源文件影响extern<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img12.PNG" alt><br>
和<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img13.PNG" alt></p>
<blockquote>
<p>全局变量是具有外部链接属性的，而static修饰的全局变量的时候就把这个外部链接属性变成了内部链接属性。生命周期是整个工程。</p>
</blockquote>
<pre><code>3. 修饰函数
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img14.PNG" alt><br>
和<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img15.PNG" alt></p>
<p>发现和上方是同一个问题</p>
<blockquote>
<p>static修饰函数其实和全局变量差不多，因为函数也具有外部链接属性，被static修饰后就变成内部链接属性了，其他源文件不能再使用。</p>
</blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_66769266/article/details/124247596">https://blog.csdn.net/m0_66769266/article/details/124247596</a></p>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">基本排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 20:50:26" itemprop="dateCreated datePublished" datetime="2022-07-26T20:50:26+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-24 08:53:30" itemprop="dateModified" datetime="2022-08-24T08:53:30+08:00">2022-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/basic_sort_img1.png" alt><br>
<img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/basic_sort_img2.png" alt></p>
<h1>冒泡排序</h1>
<h2 id="1-算法步骤">1. 算法步骤</h2>
<ol>
<li>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li>
<p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ol>
<h2 id="2-动图演示">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" alt="动图演示"></p>
<ol>
<li>代码:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt) </span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 每次确定一个最大值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vc[j] &gt; vc[j + <span class="number">1</span>]) <span class="built_in">swap</span>(vc[j], vc[j + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(vc, i);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;	</span><br><span class="line">	<span class="built_in">bubble_sort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>插入排序</h1>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h2 id="1-算法步骤-2">1. 算法步骤</h2>
<ol>
<li>
<p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
</li>
<li>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
</li>
</ol>
<h2 id="2-动图演示-2">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertionSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> key = vc[i];</span><br><span class="line">		<span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; (key &lt; vc[j])) &#123;</span><br><span class="line">			vc[j + <span class="number">1</span>] = vc[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// -1 + 1 = 0</span></span><br><span class="line">		vc[j + <span class="number">1</span>] = key;</span><br><span class="line">		<span class="built_in">print</span>(vc, i);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">insertion_sort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>选择排序</h1>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="1-算法步骤-3">1. 算法步骤</h2>
<ol>
<li>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
</li>
<li>
<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
</li>
<li>
<p>重复第二步，直到所有元素均排序完毕。</p>
</li>
</ol>
<h2 id="2-动图演示-3">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt) </span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort_min</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> min;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		min = i; </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) </span><br><span class="line">			<span class="keyword">if</span> (vc[j] &lt; vc[min])</span><br><span class="line">				min = j;</span><br><span class="line">		<span class="built_in">swap</span>(vc[min], vc[i]);</span><br><span class="line">		<span class="built_in">print</span>(vc, i + <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort_max</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		max = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vc[j] &gt; vc[max]) max = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(vc[i], vc[max]);</span><br><span class="line">		<span class="built_in">print</span>(vc, len - (i + <span class="number">1</span>));</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*vector&lt;int&gt; vc = &#123; 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 &#125;;	</span></span><br><span class="line"><span class="comment">	selection_sort_min(vc);*/</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc2 = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">selection_sort_max</span>(vc2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.希尔排序</p>
</blockquote>
<h1>希尔排序</h1>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h2 id="1-算法步骤-4">1. 算法步骤</h2>
<ol>
<li>
<p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>
</li>
<li>
<p>按增量序列个数 k，对序列进行 k 趟排序；</p>
</li>
<li>
<p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序的间隔序列不推荐用2的幂(1 2 4 8 16...)，</span></span><br><span class="line"><span class="comment">// 因为这样直到间隔为1之前，都不会将奇数位置与偶数位置的元素进行比较，这样是低效的。</span></span><br><span class="line"><span class="comment">// 希尔自己认为可以用2的幂 - 1序列(1 3 7 15...)，后来又有文章建议用3x + 1(1 4 13 40 121...)，都是可以的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 间隔为3x + 1</span></span><br><span class="line">	<span class="type">int</span> gap = vc.<span class="built_in">size</span>() / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; gap &gt;= <span class="number">1</span>; gap /= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gap; ++i) &#123;</span><br><span class="line">			<span class="comment">// 组内排序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + gap; j &lt; vc.<span class="built_in">size</span>(); j += gap) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = j; k - gap &gt;= <span class="number">0</span> &amp;&amp; vc[k] &lt; vc[k - gap]; k -= gap) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(vc[k], vc[k - gap]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">print</span>(vc, i + <span class="number">1</span>);</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">shellSort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5.归并排序</p>
</blockquote>
<h1>归并排序</h1>
<h2 id="1-算法步骤-5">1. 算法步骤</h2>
<ol>
<li>
<p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li>
<p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li>
<p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li>
<p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li>
<p>将另一序列剩下的所有元素直接复制到合并序列尾。</p>
</li>
</ol>
<h2 id="2…-动图演示">2… 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ptrL = l;</span><br><span class="line">    <span class="type">int</span> ptrR = mid;</span><br><span class="line">    <span class="type">static</span> vector&lt;<span class="type">int</span>&gt;tempary;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &gt; tempary.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        tempary.<span class="built_in">resize</span>(arr.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrL != mid &amp;&amp; ptrR != r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[ptrL] &lt; arr[ptrR]) &#123;</span><br><span class="line">            tempary[index++] = arr[ptrL++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tempary[index++] = arr[ptrR++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrL != mid) &#123;</span><br><span class="line">        tempary[index++] = arr[ptrL++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrR != r) &#123;</span><br><span class="line">        tempary[index++] = arr[ptrR++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(tempary.<span class="built_in">begin</span>(), tempary.<span class="built_in">begin</span>() + index, arr.<span class="built_in">begin</span>() + l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// sort the range [l, r) in arr</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, mid, r);</span><br><span class="line">    <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="built_in">mergeSort</span>(vc, <span class="number">0</span>, vc.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">print</span>(vc, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>6.堆排序</p>
</blockquote>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/heapSort.gif" alt="动图演示"></p>
<blockquote>
<p>对于一个完全二叉树，在填满的情况下（非叶子节点都有两个子节点），每一层的元素个数是上一层的二倍，根节点数量是1，所以最后一层的节点数量，一定是之前所有层节点总数+1，<br>
所以，我们能找到最后一层的第一个节点的索引，即节点总数/2（根节点索引为0），这也就是第一个叶子节点，所以第一个非叶子节点的索引就是第一个叶子结点的索引-1。<br>
那么对于填不满的二叉树呢？这个计算方式仍然适用，当我们从上往下，从左往右填充二叉树的过程中，第一个叶子节点，一定是序列长度/2，所以第一个非叶子节点的索引就是arr.length / 2 - 1。</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 父节点 * 2 + 1为左子节点</span></span><br><span class="line">	<span class="comment">// 从最后一个叶子节点开始</span></span><br><span class="line">	<span class="type">int</span> fa = start, so = fa * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (so &lt;= end) &#123;</span><br><span class="line">		<span class="comment">// 比较两个子节点大小，选大的那个</span></span><br><span class="line">		<span class="keyword">if</span> (so + <span class="number">1</span> &lt;= end &amp;&amp; vec[so] &lt; vec[so + <span class="number">1</span>]) </span><br><span class="line">			so++; <span class="comment">// so = so + 1;</span></span><br><span class="line">		<span class="keyword">if</span> (vec[fa] &gt; vec[so]) <span class="comment">// 父节点大于子节点则不需要调整</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">			<span class="built_in">swap</span>(vec[fa], vec[so]);</span><br><span class="line">			fa = so;</span><br><span class="line">			so = fa * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 这里是*2 不是/2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 索引从0开始，寻找第一个非叶子节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">max_heapify</span>(vec, i, len - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(vec[<span class="number">0</span>], vec[i]);</span><br><span class="line">		<span class="built_in">max_heapify</span>(vec, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// vector&lt;int&gt; vec = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">heap_sort</span>(vec, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>7.快速排序</p>
</blockquote>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> left = low;</span><br><span class="line">    <span class="type">int</span> right = high;</span><br><span class="line">    <span class="type">int</span> key = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*从左向右找比key大的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (left == high) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*从右向左找比key小的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (right == low)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*中枢值与j对应值交换*/</span></span><br><span class="line">    arr[low] = arr[right];</span><br><span class="line">    arr[right] = key;</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, low, right - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, right + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="built_in">Qsort</span>(vc, <span class="number">0</span>, vc.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(vc, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>8.基数排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>9.桶排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>10.计数排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/" class="post-title-link" itemprop="url">leetcode 303 场周赛复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-25 19:41:57" itemprop="dateCreated datePublished" datetime="2022-07-25T19:41:57+08:00">2022-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 18:16:16" itemprop="dateModified" datetime="2022-07-26T18:16:16+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>第一题</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img1.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">repeatedCharacter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i = <span class="string">&#x27;a&#x27;</span>;  i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(i, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ss : s) &#123;</span><br><span class="line">            ++m[ss];</span><br><span class="line">            <span class="keyword">if</span>(m[ss] == <span class="number">2</span>) <span class="keyword">return</span> ss;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img2.PNG" alt></p>
<blockquote>
<p>第二题</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img3.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img5.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">equalPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec_col</span>(m * m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec_row;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            vec_row.<span class="built_in">push_back</span>(grid[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                vec_col[j].<span class="built_in">push_back</span>(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(vec_row[i] == vec_col[j]) ++ cnt; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img4.PNG" alt></p>
<blockquote>
<p>tip: 前两题较简单，第三题有点难度</p>
</blockquote>
<blockquote>
<p>第三题</p>
</blockquote>
<blockquote>
<p>tips: 我觉得最妙的点在于评分取负号</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img6.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img7.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img8.PNG" alt></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line">    <span class="comment">// 修改食物评分时要影响到cs中set的结构</span></span><br><span class="line">    <span class="comment">// 想要获取set必须要知道key(烹饪方式)</span></span><br><span class="line">    <span class="comment">// 所以食物 -&gt;(评分， 烹饪方式)</span></span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">int</span>, string&gt;&gt; fs;</span><br><span class="line">    <span class="comment">// 烹饪方式 -&gt; (评分, 名字)</span></span><br><span class="line">    <span class="comment">// 需要通过烹饪方式查询评分和食物名字</span></span><br><span class="line">    <span class="comment">// 要返回评分最高的食物和返回字典序较小的名字</span></span><br><span class="line">    <span class="comment">// 所以先评分，后名字</span></span><br><span class="line">    unordered_map&lt;string, set&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;&gt; cs;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FoodRatings</span>(vector&lt;string&gt; &amp;foods, vector&lt;string&gt; &amp;cuisines, vector&lt;<span class="type">int</span>&gt; &amp;ratings) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; foods.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 食物, 烹饪方式</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;f = foods[i], &amp;c = cuisines[i];</span><br><span class="line">            <span class="comment">// 评分</span></span><br><span class="line">            <span class="type">int</span> r = ratings[i];</span><br><span class="line">            <span class="comment">// 评分， 烹饪方式赋值</span></span><br><span class="line">            fs[f] = &#123;r, c&#125;;</span><br><span class="line">            <span class="comment">// emplace就不需要make_pair</span></span><br><span class="line">            <span class="comment">// 因为要返回评分最高的食物和返回字典序较小的名字</span></span><br><span class="line">            <span class="comment">// 序列是相反的</span></span><br><span class="line">            <span class="comment">// 评分取负号，保证最小对应最高评分</span></span><br><span class="line">            cs[c].<span class="built_in">emplace</span>(-r, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeRating</span><span class="params">(string food, <span class="type">int</span> newRating)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出食物对应的 (评分，烹饪方式)</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;[r, c] = fs[food];</span><br><span class="line">        <span class="comment">// 获取评分和名字</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;s = cs[c];</span><br><span class="line">        s.<span class="built_in">erase</span>(&#123;-r, food&#125;); <span class="comment">// 移除旧数据</span></span><br><span class="line">        s.<span class="built_in">emplace</span>(-newRating, food); <span class="comment">// 添加新数据</span></span><br><span class="line">        <span class="comment">// 修改评分</span></span><br><span class="line">        r = newRating;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">highestRated</span><span class="params">(string cuisine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少有一种，所以取begin()-&gt;第二项（名字）</span></span><br><span class="line">        <span class="keyword">return</span> cs[cuisine].<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第四题</p>
</blockquote>
<blockquote>
<p>看不懂的可以看视频 , 韦恩图</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img9.PNG" alt></p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数：                  1      2      3</span></span><br><span class="line">    <span class="comment">// 二进制为1的个数：     1      1      2</span></span><br><span class="line">    <span class="comment">// 表格：</span></span><br><span class="line">    <span class="comment">// |-------------------------------------------------|</span></span><br><span class="line">    <span class="comment">// cx(去重后):        |   1   |   2    |</span></span><br><span class="line">    <span class="comment">// cnt:               |   2   |   1    |</span></span><br><span class="line">    <span class="comment">// |-------------------------------------------------|</span></span><br><span class="line">    <span class="comment">// 五种：                1 + 2  -&gt; 从c(x) = 1的集合中取一个, c(x) = 2 中取一个  || 2 * 1  -&gt; 有两个1</span></span><br><span class="line">    <span class="comment">//                       1 * 2  -&gt; (2, 1) 和 （1，2）</span></span><br><span class="line">    <span class="comment">//                       1 * 1  -&gt; 自己和自己</span></span><br><span class="line">    <span class="comment">// 遍历去重后的 nums\textit&#123;nums&#125;nums，统计 c(nums[i])c(nums[i])的个数，记录在 cnt 中，</span></span><br><span class="line">    <span class="comment">// 然后写一个二重循环遍历 cnt，对于所有的 c(x)+c(y)≥k，</span></span><br><span class="line">    <span class="comment">// 累加 cnt[c(x)]⋅cnt[c(y)]，表示从这两组中各选一个 x 和 y 组成优质数对的个数。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countExcellentPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="comment">// 获取cnt表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())) <span class="comment">// 去重</span></span><br><span class="line">            ++cnt[__builtin_popcount(x)];</span><br><span class="line">        <span class="type">long</span> ans = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// cx -&gt; x中1的个数， ccx -&gt; 值为x的个数</span></span><br><span class="line">        <span class="comment">// cy -&gt; y中1的个数， ccy -&gt; 值为y的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cx, ccx] : cnt)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cy, ccy] : cnt)</span><br><span class="line">                <span class="keyword">if</span> (cx + cy &gt;= k) <span class="comment">// (x,y) 是优质数对</span></span><br><span class="line">                    ans += (<span class="type">long</span>) ccx * ccy; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=258805927&bvid=BV14a411U7QZ&cid=782543429&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>


<hr>
</div>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/25/STL%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/25/STL%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">STL底层实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-25 19:33:43" itemprop="dateCreated datePublished" datetime="2022-07-25T19:33:43+08:00">2022-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 20:46:42" itemprop="dateModified" datetime="2022-07-26T20:46:42+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>vector</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">底层实现是数组。</span><br><span class="line">1.由于数组的特性,vector也可以使用下标快速访问。</span><br><span class="line">2.顺序存储，插入/删除到非尾结点位置所需时间复杂度0(n)</span><br><span class="line">3.新建vector时，和数组一样分配一片连续内存空间，当添加元素时，如果初始分配的空间满了，将会重新申请一个2倍质数大小左右的空间，</span><br><span class="line">将原空间的内容拷贝过来后释放原空间内存。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>map, unordered_map, multimap, unordered_multimap</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map 和 multimap 的底层数据结构是红黑树，根据红黑树的原理，map和multimap可以实现0(lgn)的查找，删除，插入，实现key为序列的排序，并且map和multimap是有序的。</span><br><span class="line">unordered_map, unordered_map 的底层数据结构是哈希表。</span><br><span class="line">multimap 和 map 的区别在于，multimap允许关键字重复，而map不允许重复。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>list</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">底层实现是双向链表。拥有链表的特性。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>deque</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">底层实现是双向队列，可以在头尾插入和删除元素。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set &amp; multiset &amp; unordered_set &amp; unordered_multiset</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上四种容器也都是关联容器，set系与map系的区别在于map中存储的是&lt;key-value&gt;，而set可以理解为关键字即值，即只保存关键字的容器。</span><br><span class="line">set 的底层实现是红黑树(平衡树),。</span><br><span class="line">unordered_set, unordered_multiset底层实现为哈希表。</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">数据结构-二叉树复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-22 07:44:24" itemprop="dateCreated datePublished" datetime="2022-07-22T07:44:24+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 20:31:20" itemprop="dateModified" datetime="2022-07-26T20:31:20+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>二叉树复习 -&gt; 树的遍历 (重要)</p>
</blockquote>
<ol>
<li>建立二叉树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>前序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img1.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img2.PNG" alt></li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归实现（使用栈）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res; </span><br><span class="line">        stack&lt;TreeNode*&gt;stc;</span><br><span class="line">        stc.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stc.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(stc.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">            TreeNode* tmp = stc.<span class="built_in">top</span>();</span><br><span class="line">            stc.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 因为是stack(栈),需要先右后左</span></span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right) stc.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left) stc.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>中序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img3.PNG" alt></li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, vc);</span><br><span class="line">        vc.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, vc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line">        <span class="built_in">inorder</span>(root, vc);</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="comment">// 非叶子节点 || 栈不为空</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是root!</span></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>后序遍历</li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left, vc);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right, vc);</span><br><span class="line">    vc.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line">    <span class="built_in">postorder</span>(root, vc);</span><br><span class="line">    <span class="keyword">return</span> vc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代实现 暂时没看懂</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>层序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img4.PNG" alt></li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">//创建返回数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="comment">//若空</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">//根节点压入队列</span></span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">//若队列不为空，循环</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//当前队列长度</span></span><br><span class="line">            <span class="type">int</span> queLen = que.<span class="built_in">size</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            <span class="comment">//循环遍历当前层所有节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; queLen; ++i)&#123;</span><br><span class="line">                <span class="comment">//选择节点</span></span><br><span class="line">                <span class="keyword">auto</span> node = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">//选择的当前节点弹出队列</span></span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//将选择的当前节点的值压入数组</span></span><br><span class="line">                ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//寻找当前节点的下一层节点压入队列</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树复习 -&gt; 运用递归解决树的问题</p>
</blockquote>
<ol>
<li>二叉树的最大深度<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img5.PNG" alt></li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left_depth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right_depth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_depth, right_depth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.对称二叉树<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img6.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img7.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetricHelper</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果左右节点都为空, 说明当前节点是叶子节点，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点只有一个子节点或者有两个子节点，但两个子节点的值不相同，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span> || left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//然后左子节点的左子节点和右子节点的右子节点比较，左子节点的右子节点和右子节点的左子节点比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetricHelper</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isSymmetricHelper</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//从两个子节点开始判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetricHelper</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>路径总和（这题也是很妙的做法）</li>
</ol>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img8.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img9.PNG" alt></p>
<blockquote>
<p>递归法，没递归到一个节点，就拿target-当前节点值，如果存在路径总和等于target，那么最后一个叶子节点一定等于target剩下的值。<br>
如果递归到叶子节点后，剩余的target值不等于叶子节点，说明不存在路径总和等于target。<br>
时间复杂度O（n），空间复杂度O（1）。</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==null &amp;&amp; root.right==null)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root.left,targetSum - root.val) || <span class="built_in">hasPathSum</span>(root.right,targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树复习 -&gt; 总结</p>
</blockquote>
<ol>
<li>从中序与后序遍历序列构造二叉树</li>
</ol>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img10.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> head1, <span class="type">int</span> tail1, <span class="type">int</span> head2, <span class="type">int</span> tail2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断什么时候停止递归</span></span><br><span class="line">        <span class="keyword">if</span>(head2 &gt; tail2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> last_elem = postorder[tail2];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(last_elem);</span><br><span class="line">        <span class="keyword">if</span>(head2 == tail2) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找分割点</span></span><br><span class="line">        <span class="type">int</span> spilit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(inorder[head1 + spilit] != last_elem) spilit++; </span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(inorder, postorder, head1, head1 + spilit - <span class="number">1</span>, head2, head2 + spilit - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(inorder, postorder, head1 + spilit + <span class="number">1</span>, tail1, head2 + spilit, tail2 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 如果是空树,返回nullptr</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(inorder, postorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>从前序与中序遍历序列构造二叉树<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img11.PNG" alt></li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="type">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="type">int</span> inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        <span class="comment">// 建立根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 获取左子树的节点数</span></span><br><span class="line">        <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        root-&gt;left = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span> + size_left_subtree, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">         <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">             index[inorder[i]] = i;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.填充每个节点的下一个右侧节点指针<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img12.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node*&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                Node* node = Q.<span class="built_in">front</span>();</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 因为最后一个节点的next不需要赋值</span></span><br><span class="line">                <span class="keyword">if</span>(i &lt; size - <span class="number">1</span>) node-&gt;next = Q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) Q.<span class="built_in">push</span>(node-&gt;left) ;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.填充每个节点的下一个右侧节点指针 II<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img13.PNG" alt></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i &lt; size - <span class="number">1</span>) node-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.二叉树的最近公共祖先</p>
<blockquote>
<p>tip: 这题也是挺巧的,如果left为空，说明这两个节点在cur结点的右子树上，我们只需要返回右子树查找的结果即可，反之<br>
查找左子树，如果left和right都不为空，说明这两个节点一个在cur的左子树上一个在cur的右子树上，我们只需要返回cur结点<br>
即可</p>
</blockquote>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img14.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">       TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">       TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">       <span class="comment">// 公共节点在根节点的右子树上</span></span><br><span class="line">       <span class="keyword">if</span>(left == <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">       <span class="comment">// 公共节点在根节点的左子树上</span></span><br><span class="line">       <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6.二叉树的序列化与反序列化</p>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img15.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img16.PNG" alt></p>
<p>链接： <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/</a></p>
<blockquote>
<p>tips: 条例非常清晰，代码可阅读性很高</p>
</blockquote>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserialize</span><span class="params">(TreeNode* root, string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            str += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            str += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            <span class="built_in">reserialize</span>(root-&gt;left, str);</span><br><span class="line">            <span class="built_in">reserialize</span>(root-&gt;right, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="built_in">reserialize</span>(root, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">rdeserialize</span><span class="params">(list&lt;string&gt;&amp; dataArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dataArray.<span class="built_in">front</span>() == <span class="string">&quot;None&quot;</span>)&#123;</span><br><span class="line">            dataArray.<span class="built_in">erase</span>(dataArray.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(dataArray.<span class="built_in">front</span>()));</span><br><span class="line">        dataArray.<span class="built_in">erase</span>(dataArray.<span class="built_in">begin</span>());</span><br><span class="line">        root-&gt;left = <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">        root-&gt;right = <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        list&lt;string&gt; dataArray;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : data) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                dataArray.<span class="built_in">push_back</span>(str);</span><br><span class="line">                str.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> str.<span class="built_in">push_back</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            dataArray.<span class="built_in">push_back</span>(str);</span><br><span class="line">            str.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>
<hr>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">数据结构: 链表复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-17 20:10:43" itemprop="dateCreated datePublished" datetime="2022-07-17T20:10:43+08:00">2022-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 20:38:52" itemprop="dateModified" datetime="2022-08-22T20:38:52+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>链表复习 -&gt; leetcode/牛客快速测试模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode* next;</span><br><span class="line">	<span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode* next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		cout &lt;&lt; head-&gt;val &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">	ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">	ListNode* cur = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">		cur-&gt;next = tmp;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ShowList</span>(head-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 设计链表 (重要)</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img1.PNG" alt></p>
<h2 id="代码：-注意点：新节点next一定设置为nullptr">代码： 注意点：新节点next一定设置为nullptr</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">val</span>(x) &#123;&#125; <span class="comment">// 初始化</span></span><br><span class="line">        Node* next; <span class="comment">// 指针域</span></span><br><span class="line">        <span class="type">int</span> val; <span class="comment">// 数据域</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        nHead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 初始化头指针</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表中第 index 个节点的值。如果索引无效，则返回-1。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引比0小或者比最大索引大，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; (len - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* tmp = nHead-&gt;next; <span class="comment">// 辅助指针指向第一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(index--) tmp = tmp-&gt;next; <span class="comment">// 循环index次遍历到第index个节点</span></span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(val);  <span class="comment">// 创建新节点</span></span><br><span class="line">        tmp-&gt;next = nHead-&gt;next; </span><br><span class="line">        nHead-&gt;next = tmp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tmp = nHead;</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next) tmp = tmp-&gt;next;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        newNode-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 赋值为nullptr</span></span><br><span class="line">        tmp-&gt;next = newNode;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span> ) <span class="built_in">addAtHead</span>(val); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index == len) <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">            Node* cur = nHead;</span><br><span class="line">            <span class="keyword">while</span>(index--) cur = cur-&gt;next;</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span>;</span><br><span class="line">        Node* cur = nHead;</span><br><span class="line">        <span class="keyword">while</span>(index--)  cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Node* nHead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 环形链表（基础）</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img2.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img3.PNG" alt></p>
<h2 id="代码：-注意点：循环条件应该是next指针不为空">代码： 注意点：循环条件应该是next指针不为空</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="或者-如下方这种使用do-while">或者 如下方这种使用do-while</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *f=head;</span><br><span class="line">        ListNode *s=head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(f-&gt;next==<span class="literal">nullptr</span>||f-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            f=f-&gt;next-&gt;next;</span><br><span class="line">            s=s-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(f!=s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 环形链表（进阶）</p>
</blockquote>
<blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>
不允许修改 链表。</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img4.PNG" alt></p>
<h3 id="方法一-哈希表-注意：-unordered-set-ListNode-内部是一个指针">方法一. 哈希表 注意： unordered_set&lt;ListNode*&gt; 内部是一个指针</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; unset;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span>(unset.<span class="built_in">count</span>(head)) <span class="keyword">return</span> head;</span><br><span class="line">            unset.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二-快慢指针-此方法需要手算，思路清晰-最后要移动c个next">方法二. 快慢指针: 此方法需要手算，思路清晰,最后要移动c个next</h3>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img5.PNG" alt></p>
<h2 id="代码：-7">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 相交链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img6.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img7.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img8.PNG" alt></p>
<h2 id="代码：-非常巧妙的想法">代码： 非常巧妙的想法</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = headA, *p2 = headB;</span><br><span class="line">        <span class="comment">//变轨次数</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span> p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            <span class="comment">//p1变轨</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">2</span> &amp;&amp; p1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p1 = headB;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p2变轨</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">2</span> &amp;&amp; p2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p2 = headA;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 删除链表的倒数第N个节点</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img9.PNG" alt></p>
<h2 id="代码：-使用的依旧是快慢指针">代码： 使用的依旧是快慢指针</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">nullptr</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> slow-&gt;next = (slow-&gt;next)-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 反转链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img10.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img11.PNG" alt></p>
<h2 id="代码：老算法了">代码：老算法了</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head, *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 移除链表元素</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img12.PNG" alt></p>
<h2 id="代码：加个头结点-之后的代码都是常规代码">代码：加个头结点,之后的代码都是常规代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* no_val_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        no_val_head-&gt;next = head;</span><br><span class="line">        ListNode* p = no_val_head, *q = no_val_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = q;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> no_val_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 奇偶链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img13.PNG" alt></p>
<h2 id="代码：分两个部分-奇数部分和偶数部分-头结点不变">代码：分两个部分,奇数部分和偶数部分,头结点不变</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* odd = head, *evenHead = head-&gt;next;</span><br><span class="line">        ListNode* even = evenHead;</span><br><span class="line">        <span class="keyword">while</span>(even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 回文链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img14.PNG" alt></p>
<h2 id="代码：-很妙的构思-采用递归">代码： 很妙的构思,采用递归</h2>
<h3 id="正常解法">正常解法</h3>
<h3 id="巧妙的解法">巧妙的解法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode *t;</span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        res = <span class="built_in">recursivelyCheck</span>(head-&gt;next) &amp;&amp; (t-&gt;val==head-&gt;val);</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        t = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双链表 -&gt; 设计链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img15.PNG" alt></p>
<h2 id="代码：-8">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Node* prev;</span><br><span class="line">        Node* next;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">val</span>(x) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>()&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 头结点</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* tm = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--) </span><br><span class="line">            tm = tm-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> tm-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tm = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            head-&gt;next-&gt;prev = tm;</span><br><span class="line">        tm-&gt;prev = head;</span><br><span class="line">        tm-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = tm;</span><br><span class="line">        len ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = len;</span><br><span class="line">        Node* tmp = head;</span><br><span class="line">        Node * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next) </span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        tmp-&gt;next = newNode;</span><br><span class="line">        newNode-&gt;prev = tmp;</span><br><span class="line">        newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) <span class="built_in">addAtHead</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index == len) <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* tmp = head-&gt;next;</span><br><span class="line">            Node * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">            <span class="keyword">while</span>(index--) </span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            </span><br><span class="line">            newNode-&gt;next = tmp;</span><br><span class="line">            newNode-&gt;prev = tmp-&gt;prev;</span><br><span class="line">            tmp-&gt;prev-&gt;next = newNode;</span><br><span class="line">            tmp-&gt;prev = newNode;</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span>;</span><br><span class="line">         Node * tmp = head-&gt;next;</span><br><span class="line">         <span class="keyword">while</span>(index--) </span><br><span class="line">             tmp = tmp-&gt;next;</span><br><span class="line">         <span class="keyword">if</span>(tmp-&gt;next) &#123;</span><br><span class="line">            tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">            tmp-&gt;prev-&gt;next = tmp-&gt;next;    </span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             tmp-&gt;prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">delete</span> tmp;</span><br><span class="line">         len--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Node* prev;</span></span><br><span class="line">    Node* head, *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 合并两个有序链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img16.PNG" alt></p>
<h2 id="代码：-9">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list1 &amp;&amp; !list2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* nHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* p = nHead, *lA = list1, *lB = list2;</span><br><span class="line">        <span class="keyword">while</span>(lA &amp;&amp; lB) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lA-&gt;val &lt;= lB-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = lA;</span><br><span class="line">                p = lA;</span><br><span class="line">                lA = lA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = lB;</span><br><span class="line">                p = lB;</span><br><span class="line">                lB = lB-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lA) p-&gt;next = lA;</span><br><span class="line">        <span class="keyword">if</span>(lB) p-&gt;next = lB;</span><br><span class="line">        <span class="keyword">return</span> nHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 两数相加</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img17.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img18.PNG" alt></p>
<h2 id="代码：-10">代码：</h2>
<h3 id="正常方法：">正常方法：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * @param head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reserve</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">addInList</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> head2;</span><br><span class="line">        <span class="keyword">if</span>(head2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> head1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转链表</span></span><br><span class="line">        <span class="comment">// 9-&gt;3-&gt;7   =&gt;  7-&gt;3-&gt;9</span></span><br><span class="line">        <span class="comment">// 6-&gt;3      =&gt;  3-&gt;6</span></span><br><span class="line">        head1 = <span class="built_in">reserve</span>(head1);</span><br><span class="line">        head2 = <span class="built_in">reserve</span>(head2);</span><br><span class="line">        <span class="comment">// 创建新的表头节点</span></span><br><span class="line">        ListNode* res= <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p = res;</span><br><span class="line">        <span class="comment">// 进位的值</span></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 || head2 ) &#123;</span><br><span class="line">            <span class="comment">// 累加值(head1-&gt;val + head2-&gt;val + tmp)</span></span><br><span class="line">            <span class="type">int</span> total = carry;</span><br><span class="line">            <span class="keyword">if</span>(head1) &#123;</span><br><span class="line">                <span class="comment">// 节点不为空，加上当前节点值</span></span><br><span class="line">                total += head1-&gt;val;</span><br><span class="line">                head1 = head1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head2) &#123;</span><br><span class="line">                total += head2-&gt;val;</span><br><span class="line">                head2 = head2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求进位</span></span><br><span class="line">            carry = total / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 求余后的值为当前节点的值</span></span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(total % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 下一个节点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后两条链表都加完，且当进位不为0的时候，加上进位位</span></span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加上进位</span></span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reserve</span>(res-&gt;next);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="巧方法">巧方法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(l1 || l2 || sum)&#123;</span><br><span class="line">             <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                 sum += l1-&gt;val;</span><br><span class="line">                 l1 = l1-&gt;next;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">                 sum += l2-&gt;val;</span><br><span class="line">                 l2 = l2-&gt;next;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">             cur = cur-&gt;next;</span><br><span class="line">             sum /= <span class="number">10</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 扁平化多级双向链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img19.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img20.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img21.PNG" alt></p>
<h2 id="代码：-p-next-r是点睛之笔">代码： p-&gt;next = r是点睛之笔</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">       Node* p = head, *q, *r;</span><br><span class="line">       <span class="keyword">while</span>(p) &#123;</span><br><span class="line">           <span class="keyword">if</span>(p-&gt;child != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">               q = p-&gt;next;</span><br><span class="line">               r = p-&gt;child;</span><br><span class="line">               p-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">               p-&gt;next = r; <span class="comment">// 为下次递归做铺垫</span></span><br><span class="line">               r-&gt;prev = p;</span><br><span class="line">               <span class="keyword">while</span>(r-&gt;next) r = r-&gt;next;</span><br><span class="line">               r-&gt;next = q;</span><br><span class="line">               <span class="keyword">if</span> (q != <span class="literal">NULL</span>) q-&gt;prev = r;</span><br><span class="line">           &#125;</span><br><span class="line">           p = p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 复制带随机指针的链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img22.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img23.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img26.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img27.PNG" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next)  <span class="comment">//复制每个节点，并将原链表和复制链表连在一起。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next)   <span class="comment">//复制random指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;random)</span><br><span class="line">              p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拆分两个链表，并复原原链表</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>), cur = dummy; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            cur = cur-&gt;next = q;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img28.PNG" alt></p>
<h2 id="代码：使用的unordered-map">代码：使用的unordered_map</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; unmap;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        unmap[head] = newNode;</span><br><span class="line">        newNode-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;random) newNode-&gt;random = unmap[head-&gt;random];</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 旋转链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img24.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img25.PNG" alt></p>
<h2 id="代码-先变成循环链表再确定位置断开">代码: 先变成循环链表再确定位置断开</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        <span class="comment">// n - k % len是新链表头节点的索引</span></span><br><span class="line">        <span class="comment">// n - k % len - 1是新链表尾节点的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - k % len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt; 判断链表是否为回文结构</p>
</blockquote>
<h2 id="描述：">描述：</h2>
<blockquote>
<p>给定一个链表，请判断该链表是否为回文结构。<br>
回文是指该字符串正序逆序完全一致。</p>
</blockquote>
<h3 id="示例1-4">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;1&#125;</span><br><span class="line">返回值：true</span><br></pre></td></tr></table></figure>
<h3 id="示例2-3">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;2,1&#125;</span><br><span class="line">返回值：false</span><br><span class="line">说明：2-&gt;1   </span><br></pre></td></tr></table></figure>
<h3 id="示例3">示例3</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;1,2,2,1&#125;</span><br><span class="line">返回值：true</span><br><span class="line">说明：1-&gt;2-&gt;2-&gt;1      </span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reserve</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPail</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="comment">// 找中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中点处翻转</span></span><br><span class="line">        slow = <span class="built_in">reserve</span>(slow);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow) &#123;</span><br><span class="line">            <span class="comment">// 比较值是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != fast-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt;  删除有序链表中重复的元素-I</p>
</blockquote>
<h2 id="描述">描述</h2>
<blockquote>
<p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>
例如：<br>
给出的链表为1→1→2,返回1→2。<br>
给出的链表为1→1→2→3→3,返回1→2→3。</p>
</blockquote>
<h3 id="示例1-5">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;1,1,2&#125;</span><br><span class="line">返回值：&#123;1,2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例2-4">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;&#125;</span><br><span class="line">返回值：&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码：-11">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* nHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode*p = head, *q = nHead;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(p-&gt;val) == set.<span class="built_in">end</span>())</span><br><span class="line">                set.<span class="built_in">emplace</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : set) &#123;</span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">            q-&gt;next = tmp;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt;  删除有序链表中重复的元素-II</p>
</blockquote>
<h2 id="描述-2">描述</h2>
<blockquote>
<p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>
例如：<br>
给出的链表为1→2→3→3→4→4→5,返回1→2→5.<br>
给出的链表为1→1→1→2→3, 返回2→3.</p>
</blockquote>
<h3 id="示例1-6">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;1,2,2&#125;</span><br><span class="line">返回值：&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例2-5">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;&#125;</span><br><span class="line">返回值：&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码：-12">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> tmp = cur-&gt;next-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val == tmp) </span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">流迭代器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-16 13:36:06 / 修改时间：16:58:46" itemprop="dateCreated datePublished" datetime="2022-07-16T13:36:06+08:00">2022-07-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>C++ primer 第十章 泛型算法</p>
</blockquote>
<p><img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img1.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img2.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img3.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img4.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img5.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img6.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img7.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img8.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img9.PNG" alt></p>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-14 20:24:13" itemprop="dateCreated datePublished" datetime="2022-07-14T20:24:13+08:00">2022-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-17 13:50:11" itemprop="dateModified" datetime="2022-07-17T13:50:11+08:00">2022-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>C++ primer 第12章 动态内存与智能指针</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img1.PNG" alt></p>
<blockquote>
<p>shared_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img2.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img3.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img4.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img5.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img6.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img7.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img8.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img9.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img10.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img11.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img12.PNG" alt></p>
<blockquote>
<p>编写函数，返回一个动态分配的 int 的vector。将此vector 传递给另一个函数，这个函数读取标准输入，将读入的值保存在 vector 元素中。再将vector传递给另一个函数，打印读入的值。记得在恰当的时刻delete vector。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;* alloc_vector()</span><br><span class="line">&#123;</span><br><span class="line">	return new vector&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assign_vector(vector&lt;int&gt;* p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (std::cin &gt;&gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_vector(vector&lt;int&gt;* p)</span><br><span class="line">&#123;</span><br><span class="line">	for (auto i : *p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto p = alloc_vector();</span><br><span class="line">	assign_vector(p);</span><br><span class="line">	print_vector(p);</span><br><span class="line">	delete p;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重做上一题，这次使用 shared_ptr 而不是内置指针。</p>
</blockquote>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;vector&lt;int&gt;&gt; alloc_vector()</span><br><span class="line">&#123;</span><br><span class="line">	return std::make_shared&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assign_vector(std::shared_ptr&lt;vector&lt;int&gt;&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (std::cin &gt;&gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_vector(std::shared_ptr&lt;vector&lt;int&gt;&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	for (auto i : *p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto p = alloc_vector();</span><br><span class="line">	assign_vector(p);</span><br><span class="line">	print_vector(p);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>unique_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img13.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img14.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img15.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img16.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img17.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img18.PNG" alt></p>
<blockquote>
<p>如果你试图拷贝或赋值 unique_ptr，编译器并不总是能给出易于理解的错误信息。编写包含这种错误的程序，观察编译器如何诊断这种错误。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using std::string; using std::unique_ptr;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;string&gt; p1(new string(&quot;pezy&quot;));</span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;</span><br><span class="line">    p1.reset(nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>shared_ptr 为什么没有 release 成员？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">release 成员的作用是放弃控制权并返回指针，因为在某一时刻只能有一个 unique_ptr 指向某个对象，unique_ptr 不能被赋值，所以要使用 release 成员将一个 unique_ptr 的指针的所有权传递给另一个 unique_ptr。而 shared_ptr 允许有多个 shared_ptr 指向同一个对象，因此不需要 release 成员。</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>weak_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img19.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img20.PNG" alt></p>
<blockquote>
<p>定义你自己版本的 StrBlobPtr，更新 StrBlob 类，加入恰当的 friend 声明以及 begin 和 end 成员。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using std::vector; using std::string;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class StrBlobPtr;</span><br><span class="line">class ConstStrBlobStr;</span><br><span class="line"></span><br><span class="line">class StrBlob &#123;</span><br><span class="line">public:</span><br><span class="line">    friend class StrBlobPtr;</span><br><span class="line">    friend class ConstStrBlobPtr;</span><br><span class="line">    using size_type = vector&lt;string&gt;::size_type;</span><br><span class="line"></span><br><span class="line">    StrBlobPtr begin();</span><br><span class="line">    StrBlobPtr end();</span><br><span class="line">    ConstStrBlobPtr cbegin();</span><br><span class="line">    ConstStrBlobPtr cend();</span><br><span class="line">    StrBlob() :data(std::make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">    StrBlob(std::initializer_list&lt;string&gt; il) :data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">    bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const string&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">    void pop_back() &#123;</span><br><span class="line">        check(0, &quot;pop_back on empty StrBlob&quot;);</span><br><span class="line">        data-&gt;pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; front() &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; back() &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const std::string&amp; front() const &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line">    const std::string&amp; back() const &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void check(size_type i, const string&amp; msg) const &#123;</span><br><span class="line">        if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;vector&lt;string&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConstStrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    ConstStrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    ConstStrBlobPtr(const StrBlob&amp; a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    ConstStrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const ConstStrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    StrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConstStrBlobPtr StrBlob::cbegin()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">ConstStrBlobPtr StrBlob::cend()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::ifstream is(&quot;test.txt&quot;);</span><br><span class="line">    StrBlob sb;</span><br><span class="line">    string s;</span><br><span class="line">    while (getline(is, s)) &#123;</span><br><span class="line">        sb.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    for (StrBlobPtr sbp = sb.begin(); sbp != sb.end(); sbp.incr()) &#123;</span><br><span class="line">        cout &lt;&lt; sbp.deref() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写程序，逐行读入一个输入文件，将内容存入一个 StrBlob 中，用一个 StrBlobPtr 打印出 StrBlob 中的每个元素。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using std::vector; using std::string;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class StrBlobPtr;</span><br><span class="line">class ConstStrBlobStr;</span><br><span class="line"></span><br><span class="line">class StrBlob &#123;</span><br><span class="line">public:</span><br><span class="line">    friend class StrBlobPtr;</span><br><span class="line">    friend class ConstStrBlobPtr;</span><br><span class="line">    using size_type = vector&lt;string&gt;::size_type;</span><br><span class="line"></span><br><span class="line">    StrBlobPtr begin();</span><br><span class="line">    StrBlobPtr end();</span><br><span class="line">    ConstStrBlobPtr cbegin();</span><br><span class="line">    ConstStrBlobPtr cend();</span><br><span class="line">    StrBlob() :data(std::make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">    StrBlob(std::initializer_list&lt;string&gt; il) :data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">    bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const string&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">    void pop_back() &#123;</span><br><span class="line">        check(0, &quot;pop_back on empty StrBlob&quot;);</span><br><span class="line">        data-&gt;pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; front() &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; back() &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const std::string&amp; front() const &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line">    const std::string&amp; back() const &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void check(size_type i, const string&amp; msg) const &#123;</span><br><span class="line">        if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;vector&lt;string&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConstStrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    ConstStrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    ConstStrBlobPtr(const StrBlob&amp; a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    ConstStrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const ConstStrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    StrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConstStrBlobPtr StrBlob::cbegin()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">ConstStrBlobPtr StrBlob::cend()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs(&quot;books.txt&quot;);</span><br><span class="line">	StrBlob sb;</span><br><span class="line">	string s;</span><br><span class="line">	while (getline(ifs, s))</span><br><span class="line">	&#123;</span><br><span class="line">		sb.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	for (StrBlobPtr sbp = sb.begin(); sbp != sb.end(); sbp.incr())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; sbp.deref() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>智能指针最后练习</p>
</blockquote>
<h1>12.27：</h1>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img21.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img22.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img23.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img24.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img25.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img26.PNG" alt></p>
<blockquote>
<p>代码：</p>
</blockquote>
<ol>
<li>头文件：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#ifndef EX12_27_H</span><br><span class="line">#define EX12_27_H</span><br><span class="line"></span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">class QueryResult;</span><br><span class="line"></span><br><span class="line">class TextQuery</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// 类型定义</span><br><span class="line">	using line_no = std::vector&lt;std::string&gt;::size_type;</span><br><span class="line">	// 构造函数</span><br><span class="line">	TextQuery(std::ifstream&amp;);</span><br><span class="line">	QueryResult query(const std::string&amp; s) const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	// 保存输入文件的一份拷贝，输入文件中的每行保存为vector中的一个元素。当需要打印一行时，</span><br><span class="line">	// 可以用行号作为下标来提取行文本</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</span><br><span class="line">	// 使用一个map来将每个单词与它出现的行号set关联起来，可以方便地提取任意单词的set</span><br><span class="line">	std::map&lt;std::string, std::shared_ptr&lt;std::set&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class QueryResult</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	friend std::ostream&amp; print(std::ostream&amp;, const QueryResult&amp;);</span><br><span class="line"></span><br><span class="line">	QueryResult(std::string s,</span><br><span class="line">		std::shared_ptr&lt;std::set&lt;TextQuery::line_no&gt;&gt; p,</span><br><span class="line">		std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; f) :</span><br><span class="line">		sought(s), lines(p), file(f)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	std::string sought;</span><br><span class="line">	// 使用set来保存每个单词在输入文本中出现的行号，保证每行只出现一次且行号按升序保存</span><br><span class="line">	std::shared_ptr&lt;std::set&lt;TextQuery::line_no&gt;&gt; lines;</span><br><span class="line">	// 保存输入文件的一份拷贝，输入文件中的每行保存为vector中的一个元素。当需要打印一行时，</span><br><span class="line">	// 可以用行号作为下标来提取行文本</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; print(std::ostream&amp;, const QueryResult&amp;);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>功能实现</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ex12_27.h&quot;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">TextQuery::TextQuery(ifstream&amp; ifs) : file(new vector&lt;string&gt;)</span><br><span class="line">&#123;</span><br><span class="line">	string text;</span><br><span class="line">	// 获取一行</span><br><span class="line">	while (getline(ifs, text))</span><br><span class="line">	&#123;</span><br><span class="line">		// 输入文件中的每行保存为vector中的一个元素</span><br><span class="line">		file-&gt;push_back(text);</span><br><span class="line">		// 从0开始, file-&gt;size()从1开始</span><br><span class="line">		int n = file-&gt;size() - 1;</span><br><span class="line">		cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">		istringstream line(text);</span><br><span class="line">		string word;</span><br><span class="line">		while (line &gt;&gt; word)</span><br><span class="line">		&#123;</span><br><span class="line">			// 获取行号,wm[word] -&gt; size_t</span><br><span class="line">			auto&amp; lines = wm[word];</span><br><span class="line">			// cout &lt;&lt; &quot; [word] = &quot; &lt;&lt; word;</span><br><span class="line">			if (!lines)</span><br><span class="line">				lines.reset(new set&lt;line_no&gt;);</span><br><span class="line">			// cout &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">			lines-&gt;insert(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueryResult TextQuery::query(const string&amp; s) const</span><br><span class="line">&#123;</span><br><span class="line">	static shared_ptr&lt;set&lt;line_no&gt;&gt; nodata(new set&lt;line_no&gt;);</span><br><span class="line">	auto loc = wm.find(s);</span><br><span class="line">	// 如果找到返回行数</span><br><span class="line">	if (loc == wm.end())</span><br><span class="line">		return QueryResult(s, nodata, file);</span><br><span class="line">	else</span><br><span class="line">		return QueryResult(s, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印</span><br><span class="line">std::ostream&amp; print(std::ostream&amp; os, const QueryResult&amp; qr)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; qr.sought &lt;&lt; &quot; occurs &quot; &lt;&lt; qr.lines-&gt;size() &lt;&lt; &quot; &quot;</span><br><span class="line">		&lt;&lt; &quot;time&quot; &lt;&lt; (qr.lines-&gt;size() &gt; 1 ? &quot;s&quot; : &quot;&quot;) &lt;&lt; endl;</span><br><span class="line">	for (auto num : *qr.lines)</span><br><span class="line">		os &lt;&lt; &quot;\t(line &quot; &lt;&lt; num + 1 &lt;&lt; &quot;) &quot; &lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; endl;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>main函数实现</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &quot;ex12_27.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void runQueries(ifstream&amp; infile)</span><br><span class="line">&#123;</span><br><span class="line">	TextQuery tq(infile);</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;enter word to look for, or q to quit: &quot;;</span><br><span class="line">		string s;</span><br><span class="line">		if (!(cin &gt;&gt; s) || s == &quot;q&quot;) break;</span><br><span class="line">		print(cout, tq.query(s)) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs(&quot;test.txt&quot;);</span><br><span class="line">	runQueries(ifs);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>12.28</h1>
<blockquote>
<p>编写程序实现文本查询，不要定义类来管理数据。你的程序应该接受一个文件，并与用户交互来查询单词。使用vector、map 和 set 容器来保存来自文件的数据并生成查询结果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using std::string;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using std::shared_ptr;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::ifstream file(&quot;test.txt&quot;);</span><br><span class="line">	vector&lt;string&gt; input;</span><br><span class="line">	std::map&lt;string, std::set&lt;decltype(input.size())&gt;&gt; dictionary;</span><br><span class="line">	// size_t</span><br><span class="line">	decltype(input.size()) lineNo&#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">	for (string line; std::getline(file, line); ++lineNo)</span><br><span class="line">	&#123;</span><br><span class="line">		input.push_back(line);</span><br><span class="line">		std::istringstream line_stream(line);</span><br><span class="line">		for (string text, word; line_stream &gt;&gt; text; word.clear())</span><br><span class="line">		&#123;</span><br><span class="line">			// ispunct检查参数c是否为标点符号或特殊符号</span><br><span class="line">			// 将text不符合ispunct复制到word后</span><br><span class="line">			std::cout &lt;&lt; &quot;word-before : &quot; &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">			std::remove_copy_if(text.begin(), text.end(), std::back_inserter(word), ispunct);</span><br><span class="line">			std::cout &lt;&lt; &quot;word_after : &quot; &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">			dictionary[word].insert(lineNo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;enter word to look for, or q to quit: &quot;;</span><br><span class="line">		string s;</span><br><span class="line">		if (!(std::cin &gt;&gt; s) || s == &quot;q&quot;) break;</span><br><span class="line">		auto found = dictionary.find(s);</span><br><span class="line">		if (found != dictionary.end())</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; s &lt;&lt; &quot; occurs &quot; &lt;&lt; found-&gt;second.size() &lt;&lt; (found-&gt;second.size() &gt; 1 ? &quot; times&quot; : &quot; time&quot;) &lt;&lt; std::endl;</span><br><span class="line">			for (auto i : found-&gt;second)</span><br><span class="line">				std::cout &lt;&lt; &quot;\t(line &quot; &lt;&lt; i + 1 &lt;&lt; &quot;) &quot; &lt;&lt; input.at(i) &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else std::cout &lt;&lt; s &lt;&lt; &quot; occurs 0 time&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Willson-Xbort"
      src="/images/ico.jpg">
  <p class="site-author-name" itemprop="name">Willson-Xbort</p>
  <div class="site-description" itemprop="description">none</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wilson-xbort" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wilson-xbort" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Willson-Xbort</span>

  <!-- after add-->
  <!---->
</div>





        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
