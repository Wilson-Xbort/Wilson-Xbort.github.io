<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022-8-4面试整理</title>
    <url>/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="算法题1：">算法题1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设有从小到大顺序排列，不一定连续但没有重复的整数序列A=&#123;a1, a2, a3,...am-1,am,am+1,...an-1,an&#125;,</span><br><span class="line">将该序列重新排列为B&#123;am,am+1,...an-1,an,a1,a2,...am-1&#125;。试给出一个程序从符合B序列的数组中找到a1的</span><br><span class="line">位置，要求算法复杂度&lt;O(N).</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这题我没有好好审题，一看a1，没有想到是求最小值，确实应该使用二分法</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">		<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (B[mid] &gt; B[right]) &#123;</span><br><span class="line">			<span class="comment">// 中间点要比右边界大，很有可能min值在中间点右边</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (B[mid] &lt; B[right]) &#123;</span><br><span class="line">			<span class="comment">// 中间点比右边界小，那最小值应该在中间值的左侧</span></span><br><span class="line">			right = mid;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			right -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">25</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; B = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func</span>(B);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法题2：">算法题2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现以下函数，中间不能调用其他任何标准库中的函数（返回一个指针指向第一次出现在字符串中的StrSearch)</span><br><span class="line">Returns a pointer to the first occurrence of strSearch in string</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* string, <span class="type">const</span> <span class="type">char</span>* strSearch, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (string[i] != strSearch[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* _strstr(<span class="type">const</span> <span class="type">char</span>* string, <span class="type">const</span> <span class="type">char</span>* strSearch) &#123;</span><br><span class="line">	<span class="type">int</span> len_str = <span class="built_in">strlen</span>(string);</span><br><span class="line">	<span class="type">int</span> len_compare = <span class="built_in">strlen</span>(strSearch);</span><br><span class="line">	<span class="keyword">if</span> (len_str &lt; len_compare) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* pos = string;</span><br><span class="line">	<span class="comment">// 去除&#x27;\0&#x27;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* pos_end = string + len_str - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos &lt;= pos_end - len_compare; pos++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">judge</span>(pos, strSearch, len_compare) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> pos;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> a[] = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, _strstr(a, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚函数程序题">虚函数程序题</h2>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> iValue;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">fun2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base fun2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pValue;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">fun2</span>();</span><br><span class="line">		Base::<span class="built_in">fun1</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived fun2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoreDerived</span> : <span class="keyword">public</span> Derived &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">double</span> dValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; endl	 </span><br><span class="line">		&lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; endl</span><br><span class="line">		&lt;&lt; <span class="built_in">sizeof</span>(MoreDerived) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Derived d;</span><br><span class="line"></span><br><span class="line">	Base&amp; rB = d;</span><br><span class="line">	rB.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Base* pB = &amp;d;</span><br><span class="line">	pB-&gt;<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下3种写法一样</span></span><br><span class="line">	pB = (Base*)&amp;d;</span><br><span class="line">	<span class="comment">// pB = &amp;d;</span></span><br><span class="line">	<span class="comment">// pB = &amp;(Base&amp;)d; // (Base)是个临时变量，而取地址符&amp;右边必须是左值，所以（Base&amp;)引用</span></span><br><span class="line">	pB-&gt;<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="首先要知道的知识">首先要知道的知识</h2>
<ol>
<li>字节对齐：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类的默认的对齐方式：规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。</span><br><span class="line">各成员变量在存放的时候根据在结构中出现的顺序依次申请空间结构的字节边界数。</span><br><span class="line">结构中占用最大空间的类型所占用的字节数的倍数。</span><br></pre></td></tr></table></figure>
<p>常用类型的对齐方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.	char 1的倍数</span><br><span class="line">2.	int 4的倍数</span><br><span class="line">3.	float 4的倍数</span><br><span class="line">4.	double 8的倍数</span><br><span class="line">5.	short 2的倍数</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>虚指针：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多态是由虚函数实现的，而虚函数主要通过虚函数表（V-Table） 来实现。</span><br><span class="line">虚函数表每一项存储的一个虚函数的地址。  </span><br><span class="line">类的每一个对象都会包含一个虚指针，这个虚指针指向虚函数表。</span><br><span class="line"></span><br><span class="line">在32位下，虚指针占4个字节，在64位下，虚指针占8个字节。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>C++ 对象的内存布局查看</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 打开vs2022自带的【x86 Native Tools Command Prompt for VS 2022】</span><br><span class="line">2. 转入到要调试的cpp目录下： 例如C:\\Users\\Administrator\\source\\repos\\test</span><br><span class="line">3. 输入cl -d1reportSingleClassLayoutXXX MMM.cpp 【xxx为类名，MMM是文件名】</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>左值和右值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左值（L-value）：表示存储在计算机内存的对象，可寻址，相当于地址值</span><br><span class="line"></span><br><span class="line">右值（R-value）：代表的为真实值，可读，即数据值</span><br><span class="line"></span><br><span class="line">因为左值是一个地址值，因此可以对左值进行赋值操作，而右值本身就是同一个数据值，就不存在对一个数据值就行赋值的操作。</span><br><span class="line"></span><br><span class="line">int a,b;</span><br><span class="line">a=5;//为合法的操作，因为a是个地址值；</span><br><span class="line">b=a;//这个也是个合法操作，在这里b为地址值，a取其数据值即5(注意这里不是取地址值，因为a是作为一个右值)</span><br><span class="line">5=5;//这是一个非法操作，因为左值是个数据值，右值也是个数据值</span><br></pre></td></tr></table></figure>
<h2 id="开始调试">开始调试</h2>
<table>
<thead>
<tr>
<th><img src="/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/virtual_interview_img2.PNG" alt></th>
<th><img src="/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/virtual_interview_img3.PNG" alt="controller"></th>
<th><img src="/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/virtual_interview_img4.PNG" alt="Analysis"></th>
</tr>
</thead>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; sizeof(Base) &lt;&lt; endl	// 	虚指针8字节，int字节对齐=8 =》 16</span><br><span class="line">     &lt;&lt; sizeof(Derived) &lt;&lt; endl //  继承后pValue 字节对齐 + 8 =》 16 + 8 = 24</span><br><span class="line">	 &lt;&lt; sizeof(MoreDerived) &lt;&lt; endl; // 因为是static在静态区，不变还是24</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"></span><br><span class="line">Base&amp; rB = d;</span><br><span class="line">rB.fun1();	// 不管谁指向/引用谁，都是自动识别调子类自己的函数(调用被重写过的函数）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Base* pB = &amp;d;</span><br><span class="line">pB-&gt;fun1(); // 不管谁指向/引用谁，都是自动识别调子类自己的函数(调用被重写过的函数）</span><br><span class="line"></span><br><span class="line">pB = (Base*)&amp;d;</span><br><span class="line">//pB = &amp;(Base&amp;)d;</span><br><span class="line">// pB = &amp;d;</span><br><span class="line">pB-&gt;fun3(); // 强转后还是先调用被重写的函数，如果没有再往基类找</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>307场周赛复盘</title>
    <url>/2022/08/26/307%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h1>Leetcode 第307场周赛复盘</h1>
<h2 id="1-赢得比赛需要的最少训练时长">1.赢得比赛需要的最少训练时长</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。</span><br><span class="line"></span><br><span class="line">另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。</span><br><span class="line"></span><br><span class="line">你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。</span><br><span class="line"></span><br><span class="line">击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少  energy[i] 。</span><br><span class="line"></span><br><span class="line">在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。</span><br><span class="line"></span><br><span class="line">返回击败全部 n 个对手需要训练的 最少 小时数目。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。</span><br><span class="line">按以下顺序与对手比赛：</span><br><span class="line">- 你的精力与经验都超过第 0 个对手，所以获胜。</span><br><span class="line">  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。</span><br><span class="line">- 你的精力与经验都超过第 1 个对手，所以获胜。</span><br><span class="line">  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。</span><br><span class="line">- 你的精力与经验都超过第 2 个对手，所以获胜。</span><br><span class="line">  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。</span><br><span class="line">- 你的精力与经验都超过第 3 个对手，所以获胜。</span><br><span class="line">  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。</span><br><span class="line">在比赛前进行了 8 小时训练，所以返回 8 。</span><br><span class="line">可以证明不存在更小的答案。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]</span><br><span class="line">输出：0</span><br><span class="line">解释：你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。</span><br></pre></td></tr></table></figure>
<h3 id="我的题解：">我的题解：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, vector&lt;<span class="type">int</span>&gt;&amp; energy, vector&lt;<span class="type">int</span>&gt;&amp; experience)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> energy_len = energy.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> experience_len = energy.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 经验训练次数，精力训练次数</span></span><br><span class="line">        <span class="type">int</span> exp_time_experience = <span class="number">0</span>, exp_time_energy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 训练</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; experience_len; ) &#123;</span><br><span class="line">            <span class="comment">// 必须是经验和精力严格大于敌人才能击败敌人</span></span><br><span class="line">            <span class="keyword">if</span>(initialExperience &gt; experience[i] &amp;&amp; initialEnergy &gt; energy[i]) &#123;</span><br><span class="line">                initialExperience += experience[i];</span><br><span class="line">                initialEnergy -= energy[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="comment">// 如果精力不大于敌人，我们就训练精力</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(initialEnergy - energy[i] &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                exp_time_energy++;</span><br><span class="line">                initialEnergy++;</span><br><span class="line">            &#125; <span class="comment">// 如果经验不大于敌人，我们就训练经验</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                exp_time_experience++;</span><br><span class="line">                initialExperience++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后返回经验和精力的训练次数之和</span></span><br><span class="line">        <span class="keyword">return</span> exp_time_experience + exp_time_energy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-最大回文数字">2.最大回文数字</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个仅由数字（0 - 9）组成的字符串 num 。</span><br><span class="line"></span><br><span class="line">请你找出能够使用 num 中数字形成的 最大回文 整数，并以字符串形式返回。该整数不含 前导零 。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">    你 无需 使用 num 中的所有数字，但你必须使用 至少 一个数字。</span><br><span class="line">    数字可以重新排序。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-2">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;444947137&quot;</span><br><span class="line">输出：&quot;7449447&quot;</span><br><span class="line">解释：</span><br><span class="line">从 &quot;444947137&quot; 中选用数字 &quot;4449477&quot;，可以形成回文整数 &quot;7449447&quot; 。</span><br><span class="line">可以证明 &quot;7449447&quot; 是能够形成的最大回文整数。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-2">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;00009&quot;</span><br><span class="line">输出：&quot;9&quot;</span><br><span class="line">解释：</span><br><span class="line">可以证明 &quot;9&quot; 能够形成的最大回文整数。</span><br><span class="line">注意返回的整数不应含前导零。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们要考虑的情况：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路： 先构造左半部分，最后填充镜像字符串</span><br><span class="line">1. 前导 ‘0’： 比如 0000。 -&gt; 【字符串长度超过1的情况，你的第一个字母不能是0】</span><br><span class="line">2. 例如 100  ： 如果安装每次取偶数个数填左右，可能变成 010。 -&gt;【从9开始枚举到1，单独考虑0】</span><br><span class="line">3. 考虑从中间填一个字符串 -&gt; [从9开始枚举到0]</span><br><span class="line">4. 最后填充镜像字符串</span><br></pre></td></tr></table></figure>
<h1>我的题解：</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestPalindromic</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : num) cnt[c - <span class="string">&#x27;0&#x27;</span>]++;   </span><br><span class="line">        <span class="comment">// 特殊情况 0000</span></span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>] == num.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="comment">// 从9枚举到1,单独考虑0</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 找出成对的最大数字</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt[i] / <span class="number">2</span>; j++)</span><br><span class="line">                res += (i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">0</span>] / <span class="number">2</span>; i++)</span><br><span class="line">                res += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        string tmp = res;</span><br><span class="line">        <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 考虑中间填一个字符，遍历num选择最大数,[0, 9]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res += i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="感染二叉树需要的总时间">感染二叉树需要的总时间</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。</span><br><span class="line"></span><br><span class="line">每分钟，如果节点满足以下全部条件，就会被感染：</span><br><span class="line"></span><br><span class="line">    节点此前还没有感染。</span><br><span class="line">    节点与一个已感染节点相邻。</span><br><span class="line"></span><br><span class="line">返回感染整棵树需要的分钟数。</span><br></pre></td></tr></table></figure>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,5,3,null,4,10,6,9,2], start = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：节点按以下过程被感染：</span><br><span class="line">- 第 0 分钟：节点 3</span><br><span class="line">- 第 1 分钟：节点 1、10、6</span><br><span class="line">- 第 2 分钟：节点5</span><br><span class="line">- 第 3 分钟：节点 4</span><br><span class="line">- 第 4 分钟：节点 9 和 2</span><br><span class="line">感染整棵树需要 4 分钟，所以返回 4 。</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1], start = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。</span><br></pre></td></tr></table></figure>
<h3 id="题解：（没看懂）">题解：（没看懂）</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int max = 0;</span><br><span class="line">    int dfs(TreeNode* root, int start, int sum) &#123;</span><br><span class="line">        // 没感染返回-1,为nullptr自然不会被感染</span><br><span class="line">        if(root == NULL) return -1;</span><br><span class="line">        if(sum == -1 &amp;&amp; root-&gt;val == start) &#123; // 本节点为感染节点</span><br><span class="line">            sum = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum != -1) &#123;</span><br><span class="line">            // 本节点已经感染，传递到子树中</span><br><span class="line">            dfs(root-&gt;left, start, sum + 1);</span><br><span class="line">            dfs(root-&gt;right, start, sum + 1);</span><br><span class="line">            if(sum &gt; max) max = sum;</span><br><span class="line">            return sum + 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int tem = dfs(root-&gt;left, start, sum);</span><br><span class="line">            if(tem != -1) &#123; // 左子树被感染，传递到右子树</span><br><span class="line">                sum = tem;</span><br><span class="line">                dfs(root-&gt;right, start, sum + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                sum = dfs(root-&gt;right, start, sum);</span><br><span class="line">                dfs(root-&gt;left, start, sum + 1);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &gt; max) max = sum;</span><br><span class="line">        if(sum != -1) return sum + 1;</span><br><span class="line">        return -1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int amountOfTime(TreeNode* root, int start) &#123;</span><br><span class="line">        // 一个节点被感染，可以分为四种方向, 本身感染，从父节点感染，从左子树感染，从右子树感染</span><br><span class="line">        dfs(root, start, -1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="找出数组的第-K-大和">找出数组的第 K 大和</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个 正 整数 k 。你可以选择数组的任一 子序列 并且对其全部元素求和。</span><br><span class="line"></span><br><span class="line">数组的 第 k 大和 定义为：可以获得的第 k 个 最大 子序列和（子序列和允许出现重复）</span><br><span class="line"></span><br><span class="line">返回数组的 第 k 大和 。</span><br><span class="line"></span><br><span class="line">子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</span><br><span class="line"></span><br><span class="line">注意：空子序列的和视作 0 。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-3">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,-2], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：所有可能获得的子序列和列出如下，按递减顺序排列：</span><br><span class="line">- 6、4、4、2、2、0、0、-2</span><br><span class="line">数组的第 5 大和是 2 。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>子序列：序列中的一个元素可选可不选。</code></p>
</blockquote>
<h3 id="示例2：-3">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,-2,3,4,-10,12], k = 16</span><br><span class="line">输出：10</span><br><span class="line">解释：数组的第 16 大和是 10 。</span><br></pre></td></tr></table></figure>
<h3 id="方法一、堆">方法一、堆</h3>
<h4 id="提示一">提示一</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">记 nums 中所有非负数的和为 sum。</span><br><span class="line"></span><br><span class="line">任意一个子序列的和，都等价于从 sum 中减去某些非负数 / 加上某些负数得到。</span><br></pre></td></tr></table></figure>
<h4 id="提示二">提示二</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 nums 所有数取绝对值，这样可以统一成从 sum 中减去某些数。</span><br><span class="line"></span><br><span class="line">我们需要按照从小到大的顺序取出 sum 要减去的子序列，如何做到？</span><br></pre></td></tr></table></figure>
<h4 id="提示三">提示三</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 nums 所有数取绝对值后排序，然后用最大堆来实现。</span><br></pre></td></tr></table></figure>
<h4 id="提示四">提示四</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体来说，最大堆维护子序列的和，以及（后续需要减去的）数字的下标 i。</span><br><span class="line"></span><br><span class="line">初始时，将 sum 和下标 0 入堆。</span><br><span class="line"></span><br><span class="line">每次弹出堆顶时，将子序列的和减去 nums[i]，并考虑是否保留 nums[i−1]，从而满足子序列每个元素「选或不选」的要求。</span><br><span class="line"></span><br><span class="line">这一做法可以不重不漏地生成所有子序列的和，再配合堆，就可以从大到小生成。</span><br><span class="line">循环 k−1k-1k−1 次后，堆顶的和就是答案。</span><br></pre></td></tr></table></figure>
<h4 id="提示五">提示五</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> 1. 从最大的子序列和来考虑，那么这个序列和就是所有正数的和 sum。</span><br><span class="line"> 2. 怎么找到第二大的子序列和？从最大的子序列和中减去最小的正数或加上最大的负数。</span><br><span class="line"> 3. 为了统一操作，将负数取反，然后排序，每次取最小的数，得到的就是最小的正数或最大的负数。</span><br><span class="line"> sum 中减去它，就可以得到下一个更小的子序列和。</span><br><span class="line"> 4. 被减去的数们实际上也是组成了一个子序列。按照生成子序列的模板，就是依次对每个数，考虑</span><br><span class="line"> 选择它，还是不选择它。</span><br><span class="line"></span><br><span class="line">这样分析之后，就可以回答大家的两个问题：</span><br><span class="line"></span><br><span class="line">Q：怎么保证 pq 的顶就是答案？A：因为是用当前值最大和减去最小值，所以得到的一定是下一个略小的最大和。</span><br><span class="line">Q：保留和不保留 nums[i-1] 是不是写反了？A：是否保留指的是在被 *减去* 的子序列中是否保留此数。所以，如果不保留的话，反而是要加回来，因为它不该被从 sum 里减去。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="解法：">解法：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">kSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;x : nums)</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) sum += x;</span><br><span class="line">            <span class="keyword">else</span> x = -x;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">long</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (--k) &#123;</span><br><span class="line">            <span class="keyword">auto</span>[sum, i] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(sum - nums[i], i + <span class="number">1</span>); <span class="comment">// 保留 nums[i-1]</span></span><br><span class="line">                <span class="keyword">if</span> (i) pq.<span class="built_in">emplace</span>(sum - nums[i] + nums[i - <span class="number">1</span>], i + <span class="number">1</span>); <span class="comment">// 不保留 nums[i-1]，把之前减去的加回来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS配置和下载</title>
    <url>/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h1>CentOS配置和下载</h1>
<h2 id="下载">下载</h2>
<h3 id="进入官网">进入官网</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.centos.org/</span><br></pre></td></tr></table></figure>
<h3 id="如图：">如图：</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_1.PNG" alt></p>
<h3 id="点击CentOS-Linux">点击CentOS Linux</h3>
<h3 id="如图：-2">如图：</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_2.png" alt></p>
<h3 id="点击x86-64后，链接随便选一个">点击x86/64后，链接随便选一个</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_3.png" alt></p>
<h2 id="问题">问题</h2>
<h3 id="1-虚拟机安装出现system-not-found">1.虚拟机安装出现system not found</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_5.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 打开虚拟机设置 -&gt; 设备状态 -&gt; 启动时连接</span><br></pre></td></tr></table></figure>
<h3 id="2-安装好后发现无法联网">2.安装好后发现无法联网</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_6.png" alt><br>
<img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_4.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 进入root账号</span><br><span class="line">2. 输入 `cd /etc/sysconfig/network-scripts`</span><br><span class="line">3. 输入 `vi ifcfg-ens34`</span><br><span class="line">4. 输入i, `ONBOOT=no`,改成 `ONBOOT=yes`, 输入`wq!`</span><br><span class="line">5. 重启服务 `systemctl restart network`</span><br><span class="line">6. 输入`ip addr`</span><br></pre></td></tr></table></figure>
<h2 id="配置">配置</h2>
]]></content>
      <tags>
        <tag>配置</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux高性能服务器第二章</title>
    <url>/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h1>IP协议详解</h1>
<p><code>IP协议是TCP/IP协议簇的核心协议</code></p>
<h2 id="IP服务的特点">IP服务的特点</h2>
<blockquote>
<p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>
</blockquote>
<h3 id="1-无状态">1. 无状态</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无状态（stateless）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关</span><br><span class="line">系的。</span><br><span class="line"></span><br><span class="line">这种服务最大的缺点是无法处理乱序和重复的IP数据报。</span><br></pre></td></tr></table></figure>
<h4 id="1-1例子">1.1例子</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如:</span><br><span class="line"></span><br><span class="line">发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这</span><br><span class="line">两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。接收端的IP模块只要收到了完整的</span><br><span class="line">IP数据报（如果是IP分片的话，IP模块将先执行重组），就将其数据部分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那</span><br><span class="line">么从上层协议来看，这些数据就可能是乱序的、重复的。</span><br></pre></td></tr></table></figure>
<p>面向连接的协议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。</p>
<h3 id="2-无连接">2. 无连接</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无连接（connectionless）是指IP通信双方都不长久地维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对</span><br><span class="line">方的IP地址。</span><br></pre></td></tr></table></figure>
<h3 id="3-不可靠">3. 不可靠</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力（best effort）。</span><br></pre></td></tr></table></figure>
<h4 id="3-1-例子">3.1 例子</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如:</span><br><span class="line"></span><br><span class="line">某个中转路由器发现IP数据报在网络上存活的时间太长（根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并</span><br><span class="line">返回一个ICMP错误消息（超时错误）给发送端。</span><br><span class="line"></span><br><span class="line">又比如：</span><br><span class="line">接收端发现收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一个ICMP错误消息（IP头部参数错误）给发送端。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。</p>
</blockquote>
<blockquote>
<p>因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
</blockquote>
<h2 id="IPv4头部结构">IPv4头部结构</h2>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img1.PNG" alt></p>
<h3 id="版本号-bit-4bit">版本号(bit) 4bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4位版本号（version）指定IP协议的版本。对IPv4来说，其值是0100。</span><br></pre></td></tr></table></figure>
<h3 id="头部长度-bit-4bit">头部长度(bit) 4bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4位头部长度（header length）标识该IP头部有多少个32 bit字（4字节）。</span><br><span class="line">4(字节）*5行 = 20字节</span><br><span class="line">而选项最多40字节</span><br><span class="line">可以推出IP头部最长60字节</span><br></pre></td></tr></table></figure>
<h3 id="服务类型（bit）-8bit">服务类型（bit） 8bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8位服务类型（Type Of Service，TOS）包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。</span><br><span class="line"></span><br><span class="line">4位 的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。</span><br><span class="line">比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。</span><br></pre></td></tr></table></figure>
<h3 id="总长度（packet-length）-16bit">总长度（packet length） 16bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16位总长度（total length）是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65 535（216-1）字节。</span><br><span class="line">但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报（或分片）的长度都远远没有达到最大值。</span><br><span class="line"></span><br><span class="line">包括了ip头部和data</span><br></pre></td></tr></table></figure>
<h3 id="标识符（identification）-16bit">标识符（identification） 16bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16位标识（identification）唯一地标识主机发送的每一个数据报。</span><br><span class="line">其初始值由系统随机生成；每发送一个数据报，其值就加1。该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都具</span><br><span class="line">有相同的标识值。</span><br><span class="line"></span><br><span class="line">值1—65535（2^16-1）</span><br></pre></td></tr></table></figure>
<h3 id="标志（Flags）-3bit">标志（Flags） 3bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标志字段用以指出该IP数据报后面是否还有分段</span><br><span class="line">第一位 R 保留位一般是空的。</span><br><span class="line">第二位 DF（Don’t Fragment）位 不分片位 1表示不分片，0表示分片。</span><br><span class="line">第三位 MF（More Fragment）位 更多分片位 1表示后面还有分片，0表示无。除了数据报的最后一个分片外，其他分片都要把它置1。</span><br></pre></td></tr></table></figure>
<h3 id="分片偏移（Flag-offset）-13bit">分片偏移（Flag offset） 13bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位（乘8）</span><br><span class="line">后得到的。</span><br><span class="line"></span><br><span class="line">由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（这样才能保证后面的IP分片拥有一个合适的偏移值）。</span><br></pre></td></tr></table></figure>
<h3 id="生存时间-Time-to-live-8bit">生存时间(Time to live) 8bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8位生存时间（Time To Live，TTL）是数据报到达目的地之前允许经过的路由器跳数。</span><br><span class="line"></span><br><span class="line">TTL值被发送端设置（常见的值是64）。</span><br><span class="line">数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。</span><br><span class="line"></span><br><span class="line">TTL值可以防止数据报陷入路由循环。</span><br></pre></td></tr></table></figure>
<h3 id="协议号（protocol）-8bit">协议号（protocol） 8bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8位协议（protocol）用来区分上层协议。</span><br><span class="line"></span><br><span class="line">/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。其中，ICMP是1，TCP是6，UDP是17。</span><br><span class="line">/etc/protocols文件是RFC 1700的一个子集。</span><br></pre></td></tr></table></figure>
<h3 id="头部校验和（header-checksum）-16bit">头部校验和（header checksum） 16bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法以检验IP数据报头部（注意，仅检验头部）在传输过程</span><br><span class="line">中是否损坏。</span><br></pre></td></tr></table></figure>
<h3 id="源ip地址（Source-address）-32bit">源ip地址（Source address） 32bit</h3>
<h3 id="目标ip地址（Destination-address）-32bit">目标ip地址（Destination address） 32bit</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32位的源端IP地址和目的端IP地址用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，</span><br><span class="line">而不论它中间经过多少个中转路由器。</span><br></pre></td></tr></table></figure>
<h3 id="可选项（options）">可选项（options）</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">完成一些特殊功能：严格路由 松散路由 记录路由 时间戳只能在options 里面做。</span><br><span class="line">这部分最多包含40字节，因为IP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。</span><br></pre></td></tr></table></figure>
<h2 id="使用tcpdump观察IPv4头部结构">使用tcpdump观察IPv4头部结构</h2>
<h3 id="操作过程如下">操作过程如下:</h3>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img2.PNG" alt></p>
<h3 id="用tcpdump抓取数据包">用tcpdump抓取数据包:</h3>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img3.PNG" alt></p>
<blockquote>
<p>这次抓包我们开启了tcpdump的-x选项，使之输出数据包的二进制码。此数据包共包含60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据（length值为0）。</p>
</blockquote>
<h3 id="分析头部的字节">分析头部的字节</h3>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img4.PNG" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux高性能服务器阅读笔记第一章</title>
    <url>/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>TCP/IP协议簇以及主要协议</h1>
<h2 id="OSI四层协议">OSI四层协议</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数据链路层 -&gt; 第一层</span><br><span class="line">2. 网络层 -&gt; 第二层</span><br><span class="line">3. 传输层 -&gt; 第三层</span><br><span class="line">4. 应用层 -&gt; 第四层</span><br></pre></td></tr></table></figure>
<h2 id="主要协议">主要协议</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用层	  ping - telent	- OSPF - DNS      用户空间</span><br><span class="line">----------------------------------------- socket</span><br><span class="line">传输层			TCP	- UDP</span><br><span class="line">-----------------------------------------</span><br><span class="line">网络层		    ICMP - IP				  内核空间</span><br><span class="line">-----------------------------------------</span><br><span class="line">数据链路层		ARP - RARP</span><br><span class="line">----------------------------------------- 物理传输媒介</span><br></pre></td></tr></table></figure>
<h3 id="1-数据链路层">1.数据链路层</h3>
<blockquote>
<p>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介(比如以太网、令牌环等）上的传输。常用协议是<code>ARP(Address Resolve Protocol)</code>和<code>RARP(Reverse Address Resolve Protocol)</code>协议。</p>
</blockquote>
<h3 id="2-网络层">2. 网络层</h3>
<blockquote>
<p>网络层实现数据包的选路和转发。核心协议是<code>IP(Internet Protocol)</code>和<code>ICMP(Internet Control Message Protocol)</code>协议。</p>
</blockquote>
<h4 id="2-1-ICMP报文格式">2.1 ICMP报文格式</h4>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img1.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8位类型字段用于区分报文类型。它将ICMP报文分为两大类：</span><br><span class="line">	</span><br><span class="line">一类是差错报文，这类报文主要用来回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5；</span><br><span class="line"></span><br><span class="line">另一类是查询报文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达（类型值为8）的。有的ICMP报文还使用8位代码字</span><br><span class="line">段来进一步细分不同的条件。比如重定向报文使用代码值0表示对网络重定向，代码值1表示对主机重定向。ICMP报文使用16位校验和字段对整个报文（包</span><br><span class="line">括头部和内容部分）进行循环冗余校验（Cyclic Redundancy Check，CRC），以检验报文在传输过程中是否损坏。不同的ICMP报文类型具有不同的正文内</span><br><span class="line">容。</span><br><span class="line"></span><br><span class="line">其他ICMP报文格式请参考ICMP协议的标准文档RFC792。</span><br><span class="line"></span><br><span class="line">需要指出的是，ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说，上层协议使用下层协议提供的服务）。</span><br></pre></td></tr></table></figure>
<h3 id="3-传输层">3. 传输层</h3>
<blockquote>
<p>传输层为两台主机上的应用程序提供端到端（end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。核心协议是<code>TCP协议，UDP协议，SCTP协议</code>。</p>
</blockquote>
<h4 id="3-1-TCP-IP">3.1 TCP/IP</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。</span><br><span class="line"></span><br><span class="line">TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。</span><br><span class="line"></span><br><span class="line">使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</span><br><span class="line">当通信结束时，双方必须关闭连接以释放这些内核数据。</span><br><span class="line"></span><br><span class="line">TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写入数据</span><br><span class="line">，接收端也可以逐个字节地将它们读出。</span><br></pre></td></tr></table></figure>
<h4 id="3-2-UDP协议">3.2 UDP协议</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。</span><br><span class="line"></span><br><span class="line">“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，</span><br><span class="line">则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。</span><br><span class="line"></span><br><span class="line">UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。</span><br><span class="line"></span><br><span class="line">基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</span><br></pre></td></tr></table></figure>
<h4 id="3-3-SCTP协议">3.3 SCTP协议</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCTP协议（Stream Control Transmission Protocol，流控制传输协议）是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。</span><br><span class="line"></span><br><span class="line">可参考其标准文档RFC 2960</span><br></pre></td></tr></table></figure>
<h3 id="4-应用层">4. 应用层</h3>
<blockquote>
<p>应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现，而应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。如果应用层也在内核中实现，则会使内核变得非常庞大。当然，也有少数服务器程序是在内核中实现的，这样代码就无须在用户空间和内核空间来回切换（主要是数据的复制），极大地提高了工作效率。不过这种代码实现起来较复杂，不够灵活，且不便于移植。</p>
</blockquote>
<h4 id="4-1-telent-协议">4.1 telent 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet协议是一种远程登录协议，它使我们能在本地完成远程任务，本书后续章节将会多次使用telnet客户端登录到其他服务上。</span><br></pre></td></tr></table></figure>
<h4 id="4-2-OSPF-协议">4.2 OSPF 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OSPF（Open Shortest Path First，开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</span><br></pre></td></tr></table></figure>
<h4 id="4-3-DNS-协议">4.3 DNS 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DNS（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</span><br></pre></td></tr></table></figure>
<h2 id="封装">封装</h2>
<blockquote>
<p>每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p>
</blockquote>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img2.PNG" alt></p>
<blockquote>
<p>经过TCP封装后的数据称为TCP报文段（TCP message segment），或者简称TCP段。前文提到，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的TCP头部信息和TCP内核缓冲区（发送缓冲区或接收缓冲区）数据一起构成了TCP报文段，如下图中的虚线框所示。</p>
</blockquote>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img3.PNG" alt></p>
<blockquote>
<p>当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。</p>
</blockquote>
<blockquote>
<p>经过UDP封装后的数据称为UDP数据报（UDP datagram）。UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。</p>
</blockquote>
<blockquote>
<p>经过IP封装后的数据称为IP数据报（IP datagram）。IP数据报也包括头部信息和数据部分，其中数据部分就是一个TCP报文段、UDP数据报或者ICMP报文。</p>
</blockquote>
<blockquote>
<p>经过数据链路层封装的数据称为帧（frame）。</p>
</blockquote>
<h3 id="以太网帧">以太网帧</h3>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img4.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">帧的最大传输单元（Max Transmit Unit，MTU），即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限制。</span><br><span class="line">图1-6所示的以太网帧的MTU是1500字节。</span><br></pre></td></tr></table></figure>
<h2 id="分用">分用</h2>
<blockquote>
<p>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。分用是依靠头部信息中的类型字段实现的。</p>
</blockquote>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img5.PNG" alt></p>
<h2 id="测试网络">测试网络</h2>
<blockquote>
<p>测试网络两台主机A和B，以及一个连接到因特网的路由器。</p>
</blockquote>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img6.PNG" alt></p>
<h2 id="socket">socket</h2>
<blockquote>
<p>数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API（ApplicationProgramming Interface，应用程序编程接口）主要有两套：socket和XTI。</p>
</blockquote>
<blockquote>
<p>由socket定义的这一组API提供如下两点功能：一是将应用程序数据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发送数据（比如图1-5所示的send函数），或者是从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据；二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。</p>
</blockquote>
<blockquote>
<p>值得一提的是，socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈（比如X.25协议栈、UNIX本地域协议栈等）</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>STL底层实现</title>
    <url>/2022/07/25/STL%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>vector</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">底层实现是数组。</span><br><span class="line">1.由于数组的特性,vector也可以使用下标快速访问。</span><br><span class="line">2.顺序存储，插入/删除到非尾结点位置所需时间复杂度0(n)</span><br><span class="line">3.新建vector时，和数组一样分配一片连续内存空间，当添加元素时，如果初始分配的空间满了，将会重新申请一个2倍质数大小左右的空间，</span><br><span class="line">将原空间的内容拷贝过来后释放原空间内存。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>map, unordered_map, multimap, unordered_multimap</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map 和 multimap 的底层数据结构是红黑树，根据红黑树的原理，map和multimap可以实现0(lgn)的查找，删除，插入，实现key为序列的排序，并且map和multimap是有序的。</span><br><span class="line">unordered_map, unordered_map 的底层数据结构是哈希表。</span><br><span class="line">multimap 和 map 的区别在于，multimap允许关键字重复，而map不允许重复。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>list</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">底层实现是双向链表。拥有链表的特性。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>deque</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">底层实现是双向队列，可以在头尾插入和删除元素。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set &amp; multiset &amp; unordered_set &amp; unordered_multiset</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以上四种容器也都是关联容器，set系与map系的区别在于map中存储的是&lt;key-value&gt;，而set可以理解为关键字即值，即只保存关键字的容器。</span><br><span class="line">set 的底层实现是红黑树(平衡树),。</span><br><span class="line">unordered_set, unordered_multiset底层实现为哈希表。</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>尾置返回类型</title>
    <url>/2022/06/30/Trailing-return-type/</url>
    <content><![CDATA[<h3 id="C-Primer-第五版-第六章-P221-P224">C++ Primer 第五版 第六章 P221~P224</h3>
<blockquote>
<p>函数指针P221</p>
</blockquote>
<p><img src="/2022/06/30/Trailing-return-type/screen_img1.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img2.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img3.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img4.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img5.PNG" alt><br>
<img src="/2022/06/30/Trailing-return-type/screen_img6.PNG" alt></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 类型别名</span><br><span class="line">typedef string str_arr[10];</span><br><span class="line">str_arr&amp; fun();</span><br><span class="line"></span><br><span class="line">// 尾置返回类型</span><br><span class="line">auto fun()-&gt;string(&amp;)[10];</span><br><span class="line"></span><br><span class="line">// 使用decltype关键字</span><br><span class="line">string s[10];</span><br><span class="line">decltype(s)&amp; fun();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>简单的示例：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">// print containers like vector, deque, list, etc.</span><br><span class="line">// 可以看到这里也使用了尾置返回类型，但是由于类型并非是函数类型，因此没有那么复杂</span><br><span class="line">template&lt;typename Sequence&gt;</span><br><span class="line">auto println(Sequence const&amp; seq) -&gt; std::ostream&amp;</span><br><span class="line">&#123;</span><br><span class="line">    for (auto const&amp; elem : seq) </span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;;</span><br><span class="line">    return std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto eliminate_duplicates(std::vector&lt;std::string&gt; &amp;vs) -&gt; std::vector&lt;std::string&gt;&amp;</span><br><span class="line">&#123;</span><br><span class="line">    std::sort(vs.begin(), vs.end());</span><br><span class="line">    println(vs);</span><br><span class="line"></span><br><span class="line">    auto new_end = std::unique(vs.begin(), vs.end());</span><br><span class="line">    println(vs);</span><br><span class="line"></span><br><span class="line">    vs.erase(new_end, vs.end());</span><br><span class="line">    return vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vs&#123; &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;s&quot;, &quot;v&quot;, &quot;a&quot;, &quot;a&quot; &#125;;</span><br><span class="line">    println(vs);</span><br><span class="line">    println(eliminate_duplicates(vs));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试工具的简单使用</title>
    <url>/2022/07/03/Use-of-performance-test-tools/</url>
    <content><![CDATA[<h2 id="下载工具：">下载工具：</h2>
<table>
<thead>
<tr>
<th><img src="/2022/07/03/Use-of-performance-test-tools/uoptt_icon1.PNG" alt="virtual User Generator"></th>
<th><img src="/2022/07/03/Use-of-performance-test-tools/uoptt_icon2.PNG" alt="controller"></th>
<th><img src="/2022/07/03/Use-of-performance-test-tools/uoptt_icon3.PNG" alt="Analysis"></th>
</tr>
</thead>
</table>
<h2 id="打开virtual-User-Generator：">打开virtual User Generator：</h2>
<ol>
<li>点击录制按钮，选择协议<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img1.png" alt><br>
2.在高级选项中选择明确包含url的脚本<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img2.png" alt><br>
3.点击开始录制后就会进入你所写的url链接，结束后就可以看到Action的代码<br>
4.可以点击<em>设计工作室</em>进行关联<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img3.png" alt><br>
5.点击运行，看到为√的时候就成功了<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img4.png" alt></li>
</ol>
<h2 id="打开controller：">打开controller：</h2>
<p>1.选择脚本<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img5.png" alt><br>
2.进行设置，在基本计划下可以设置用户数量<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img6.png" alt><br>
3.点击运行时设置，可以将自动事务的勾选去掉<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img7.png" alt><br>
4.设置全部完成后可以运行<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img8.png" alt><br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img9.png" alt><br>
5.点击结果-&gt;分析结果<br>
<img src="/2022/07/03/Use-of-performance-test-tools/uoptt_img10.png" alt><br>
将会自动打开<em>Analysis</em>显示结果</p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>basic_algorithm</title>
    <url>/2022/07/01/basic-algorithm/</url>
    <content><![CDATA[<h3 id="二分查找：">二分查找：</h3>
<p><img src="/2022/07/01/basic-algorithm/binary_search_img3.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/binary_search_img2.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/binary_search_img1.PNG" alt></p>
<h4 id="核心思路：">核心思路：</h4>
<pre><code>-&gt;middle
-&gt;求左边界和右边界之和的平均值,使用此值为下标作为比较的参数
</code></pre>
<h4 id="代码：">代码：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.size() - 1;</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            int mid = (right - left) / 2 + left;</span><br><span class="line">            int num = nums[mid];</span><br><span class="line">            if (num == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (num &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="参考链接：">参考链接：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://leetcode.cn/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="双指针：">双指针：</h3>
<h4 id="核心思路：-2">核心思路：</h4>
<pre><code>-&gt;使用两个指针分别指向位置 p0 和 p1，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针
-&gt;双指针也不一定非得一个指向头，一个指向尾
</code></pre>
<h4 id="例题：">例题：</h4>
<p><img src="/2022/07/01/basic-algorithm/three_algorithm.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/three_algorithm1.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/three_algorithm2.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/three_algorithm3.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/three_algorithm4.PNG" alt></p>
<h4 id="参考链接：-2">参考链接：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://leetcode.cn/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="例题2：">例题2：</h4>
<p><img src="/2022/07/01/basic-algorithm/two_pointer_1.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/two_pointer_2.PNG" alt></p>
<h4 id="参考链接：-3">参考链接：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://leetcode.cn/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="例题2：-2">例题2：</h4>
<p><img src="/2022/07/01/basic-algorithm/two_pointer_3.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/two_pointer_4.PNG" alt></p>
<h4 id="参考链接：-4">参考链接：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        int low = 0, high = numbers.length - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int sum = numbers[low] + numbers[high];</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                return new int[]&#123;low + 1, high + 1&#125;;</span><br><span class="line">            &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                ++low;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="滑动窗口：">滑动窗口：</h3>
<h4 id="例题1：">例题1：</h4>
<p><img src="/2022/07/01/basic-algorithm/sliding_window_2.PNG" alt><br>
<img src="/2022/07/01/basic-algorithm/sliding_window_1.PNG" alt></p>
<h4 id="代码：-2">代码：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        // 哈希集合，记录每个字符是否出现过</span><br><span class="line">        unordered_set&lt;char&gt; occ;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br><span class="line">        int rk = -1, ans = 0;</span><br><span class="line">        // 枚举左指针的位置，初始值隐性地表示为 -1</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (i != 0) &#123;</span><br><span class="line">                // 左指针向右移动一格，移除一个字符</span><br><span class="line">                occ.erase(s[i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            while (rk + 1 &lt; n &amp;&amp; !occ.count(s[rk + 1])) &#123;</span><br><span class="line">                // 不断地移动右指针</span><br><span class="line">                occ.insert(s[rk + 1]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            // ☆第 i 到 rk 个字符是一个极长的无重复字符子串</span><br><span class="line">            ans = max(ans, rk - i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="例题2：-3">例题2：</h4>
<h4 id="代码：-3">代码：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool checkInclusion(string s1, string s2) &#123;</span><br><span class="line">        int n1 = s1.size(), n2 = s2.size();</span><br><span class="line">        if(n1 &gt; n2) return false;</span><br><span class="line">        vector&lt;int&gt; cnt1(26), cnt2(26);</span><br><span class="line">        for (int i = 0; i &lt; n1; ++i) &#123;</span><br><span class="line">            ++cnt1[s1[i] - &#x27;a&#x27;];</span><br><span class="line">            ++cnt2[s2[i] - &#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        if (cnt1 == cnt2) return true;</span><br><span class="line">        for (int i = n1; i &lt; n2; ++i) &#123;</span><br><span class="line">            ++cnt2[s2[i] - &#x27;a&#x27;];</span><br><span class="line">            // 如果之前没匹配到的话就一定没有这个字符</span><br><span class="line">            --cnt2[s2[i - n1] - &#x27;a&#x27;];</span><br><span class="line">            if (cnt1 == cnt2) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>const 和 static</title>
    <url>/2022/07/27/const-%E5%92%8C-static/</url>
    <content><![CDATA[<blockquote>
<p>const 复习</p>
</blockquote>
<p>1.const 有哪些用法？</p>
<pre><code>1.const修饰变量，使得变量成为一个常量
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img1.PNG" alt><br>
注意点：const 变量要初始化</p>
<pre><code>2.默认情况下,const对象只在文件内有效
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img2.PNG" alt></p>
<pre><code>3.const 可以引用
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img3.PNG" alt><br>
注意点：const不能改变</p>
<pre><code>4.const 指针
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img4.PNG" alt><br>
有以下几种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span>* p; <span class="comment">//指针本身可以修改，指向的内容不能修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p; <span class="comment">//指针本身可以修改，指向的内容不能修改 -》 指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p; <span class="comment">// 指针本身不能修改，指向的内容可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* <span class="type">const</span> p; <span class="comment">// 指针本身不能修改，指向的内容不能修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p; <span class="comment">// 指针本身不能修改，指向的内容不能修改</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img5.PNG" alt><br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img6.PNG" alt></p>
<pre><code>5. const 加在函数后方，不能修改成员变量
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img7.PNG" alt><br>
提示：只允许在类的非static成员函数后加const<br>
注意点：函数后加的const其实this指针进行修饰，即const *this</p>
<blockquote>
<p>static 复习</p>
</blockquote>
<p>2.static 有哪些用法？</p>
<pre><code>1. 修饰局部变量
</code></pre>
<p>看代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img8.PNG" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img9.PNG" alt></p>
<blockquote>
<p>static 修饰的局部变量(静态变量)是存储在静态区内部，而不再是本来的栈区，它的生命周期和程序的生命周期已经一样长。<br>
也就是说 静态变量出了作用域{} 也不会被销毁，除非程序结束。</p>
</blockquote>
<pre><code>2.修饰全局变量
</code></pre>
<p>测试：头文件不影响extern<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img10.PNG" alt><br>
和<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img11.PNG" alt></p>
<p>但是在源文件影响extern<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img12.PNG" alt><br>
和<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img13.PNG" alt></p>
<blockquote>
<p>全局变量是具有外部链接属性的，而static修饰的全局变量的时候就把这个外部链接属性变成了内部链接属性。生命周期是整个工程。</p>
</blockquote>
<pre><code>3. 修饰函数
</code></pre>
<p><img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img14.PNG" alt><br>
和<br>
<img src="/2022/07/27/const-%E5%92%8C-static/const_static_review_img15.PNG" alt></p>
<p>发现和上方是同一个问题</p>
<blockquote>
<p>static修饰函数其实和全局变量差不多，因为函数也具有外部链接属性，被static修饰后就变成内部链接属性了，其他源文件不能再使用。</p>
</blockquote>
<p>参考资料：<a href="https://blog.csdn.net/m0_66769266/article/details/124247596">https://blog.csdn.net/m0_66769266/article/details/124247596</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++ primer</tag>
      </tags>
  </entry>
  <entry>
    <title>删除重复元素</title>
    <url>/2022/07/10/delete-duplicate-elements/</url>
    <content><![CDATA[<h3 id="快速入手">快速入手</h3>
<h4 id="代码如下：">代码如下：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void elimdups(std::vector&lt;std::string&gt;&amp; vs)</span><br><span class="line">&#123;</span><br><span class="line">    std::sort(vs.begin(), vs.end());</span><br><span class="line">    auto new_end = std::unique(vs.begin(), vs.end());</span><br><span class="line">    // 删除重复</span><br><span class="line">    vs.erase(new_end, vs.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路：先用std-sort-排序，通过std-unique-将重复元素放入容器末尾，最后擦除">思路：先用std::sort()排序，通过std::unique() 将重复元素放入容器末尾，最后擦除</h4>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2022/08/08/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>快速入门</h1>
<h2 id="1-找到要上传的文件夹（Win10">1. 找到要上传的文件夹（Win10)</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.1 右击出现 Git Bash Here</span><br><span class="line">1.2 配置好邮箱，用户名，密码</span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx&quot;</span><br><span class="line">git config --global user.password &quot;xxx&quot;</span><br></pre></td></tr></table></figure>
<h2 id="2-基本指令">2.基本指令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化git, 会出现.git的文件夹</span><br><span class="line">git init</span><br><span class="line">// 可加可不加</span><br><span class="line">git add README.md </span><br><span class="line">// git commit 命令将暂存区内容添加到本地仓库</span><br><span class="line">git commit -m &quot;first commit&quot; </span><br><span class="line">// 创建一个新的本地分支main, 不进行切换</span><br><span class="line">git branch -M main</span><br><span class="line">// 添加远程仓库地址</span><br><span class="line">git remote add origin https://github.com/Wilson-Xbort/test.git </span><br><span class="line">// 将本地的 main 分支推送到 origin 主机的 main 分支。</span><br><span class="line">git push -u origin main</span><br><span class="line">// 压缩成.bundle</span><br><span class="line">git bundle create xxx.bundle HEAD main</span><br><span class="line">// 验证校验是否合法</span><br><span class="line">git bundle verify ./xxx.bundle</span><br><span class="line">// 删除远程库</span><br><span class="line">git remote rm origin</span><br><span class="line">// 解压.bundle</span><br><span class="line">git clone xxx.bundle</span><br></pre></td></tr></table></figure>
<h2 id="3-error和解决方式">3. error和解决方式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. error: failed to push some refs to &#x27;https://github.com/xxx/xxx.git&#x27;</span><br><span class="line">2. Git:nothing added to commit but untracked files present</span><br><span class="line">3. fatal: Updating an unborn branch with changes added to the index.</span><br></pre></td></tr></table></figure>
<h2 id="解决方法">解决方法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -A 或者 git add --all</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>安装</title>
    <url>/2022/05/31/install/</url>
    <content><![CDATA[<h2 id="快速开始-win-下的安装）">快速开始(win 下的安装）</h2>
<h4 id="1-安装node-js-下载长期支持版本-以下为网址">1.安装node.js, 下载长期支持版本, 以下为网址:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://nodejs.cn/download/</span><br></pre></td></tr></table></figure>
<h4 id="2-安装git，以下为网址">2. 安装git，以下为网址:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://git-scm.com/downloads</span><br></pre></td></tr></table></figure>
<h4 id="3-git配置">3. git配置</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;Your email&quot;</span><br><span class="line">git config --global user.name &quot;Your name&quot;</span><br></pre></td></tr></table></figure>
<h4 id="4-创建存放文件夹-such-as-“blog”">4. 创建存放文件夹 such as “blog”</h4>
<h4 id="5-打开cmd-输入">5. 打开cmd, 输入</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h4 id="6-进入github-创建仓库repository">6. 进入github,创建仓库repository</h4>
<h4 id="7-安装插件">7. 安装插件</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<h4 id="8-更改配置文件-config-xml">8. 更改配置文件_config.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/Githubname/Githubname.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<h4 id="1-运行">1.  运行</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h4 id="2-创建博客">2.  创建博客</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;My blog name&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-生成">3.  生成</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h4 id="4-运行服务">4. 运行服务</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h4 id="5-部署">5.部署</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h2 id="遇到deloy错误的解决方案">遇到deloy错误的解决方案</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSSL SSL_read: Connection was reset, errno 10054 ...</span><br></pre></td></tr></table></figure>
<h4 id="1-进入站点根目录删除-deploy-git文件夹-删除git提交内容文件夹）">1. 进入站点根目录删除.deploy_git文件夹(删除git提交内容文件夹）</h4>
<h4 id="2-执行命令">2. 执行命令</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">ipconfig /flushdns</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="经验：">经验：</h2>
<h4 id="Hexo可能出现部分图片能加载成功，部分图片加载不出的情况">Hexo可能出现部分图片能加载成功，部分图片加载不出的情况</h4>
<h2 id="解决方案：">解决方案：</h2>
<h4 id="你可以看看是不是图片名称有重名，将图片名称更改至不重复的即可">你可以看看是不是图片名称有重名，将图片名称更改至不重复的即可</h4>
]]></content>
      <tags>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda expression</title>
    <url>/2022/07/11/lambda-expression/</url>
    <content><![CDATA[<h2 id="lambda-介绍：">lambda 介绍：</h2>
<p><img src="/2022/07/11/lambda-expression/lambda_img1.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img2.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img3.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img4.PNG" alt></p>
<blockquote>
<p>find_if：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img5.PNG" alt></p>
<blockquote>
<p>for_each：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img6.PNG" alt></p>
<blockquote>
<p>示例：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img7.PNG" alt></p>
<blockquote>
<p>值捕获 tips： 需要写在函数内部</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img8.PNG" alt></p>
<blockquote>
<p>引用捕获：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img9.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img10.PNG" alt></p>
<blockquote>
<p>隐式捕获：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img11.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img12.PNG" alt></p>
<blockquote>
<p>捕获列表：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img13.PNG" alt></p>
<blockquote>
<p>可变lambda：</p>
</blockquote>
<p><img src="/2022/07/11/lambda-expression/lambda_img14.PNG" alt><br>
<img src="/2022/07/11/lambda-expression/lambda_img15.PNG" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 303 场周赛复盘</title>
    <url>/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<blockquote>
<p>第一题</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img1.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">repeatedCharacter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i = <span class="string">&#x27;a&#x27;</span>;  i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(i, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ss : s) &#123;</span><br><span class="line">            ++m[ss];</span><br><span class="line">            <span class="keyword">if</span>(m[ss] == <span class="number">2</span>) <span class="keyword">return</span> ss;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img2.PNG" alt></p>
<blockquote>
<p>第二题</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img3.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img5.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">equalPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec_col</span>(m * m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec_row;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            vec_row.<span class="built_in">push_back</span>(grid[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                vec_col[j].<span class="built_in">push_back</span>(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(vec_row[i] == vec_col[j]) ++ cnt; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img4.PNG" alt></p>
<blockquote>
<p>tip: 前两题较简单，第三题有点难度</p>
</blockquote>
<blockquote>
<p>第三题</p>
</blockquote>
<blockquote>
<p>tips: 我觉得最妙的点在于评分取负号</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img6.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img7.PNG" alt><br>
<img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img8.PNG" alt></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line">    <span class="comment">// 修改食物评分时要影响到cs中set的结构</span></span><br><span class="line">    <span class="comment">// 想要获取set必须要知道key(烹饪方式)</span></span><br><span class="line">    <span class="comment">// 所以食物 -&gt;(评分， 烹饪方式)</span></span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">int</span>, string&gt;&gt; fs;</span><br><span class="line">    <span class="comment">// 烹饪方式 -&gt; (评分, 名字)</span></span><br><span class="line">    <span class="comment">// 需要通过烹饪方式查询评分和食物名字</span></span><br><span class="line">    <span class="comment">// 要返回评分最高的食物和返回字典序较小的名字</span></span><br><span class="line">    <span class="comment">// 所以先评分，后名字</span></span><br><span class="line">    unordered_map&lt;string, set&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;&gt; cs;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FoodRatings</span>(vector&lt;string&gt; &amp;foods, vector&lt;string&gt; &amp;cuisines, vector&lt;<span class="type">int</span>&gt; &amp;ratings) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; foods.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 食物, 烹饪方式</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;f = foods[i], &amp;c = cuisines[i];</span><br><span class="line">            <span class="comment">// 评分</span></span><br><span class="line">            <span class="type">int</span> r = ratings[i];</span><br><span class="line">            <span class="comment">// 评分， 烹饪方式赋值</span></span><br><span class="line">            fs[f] = &#123;r, c&#125;;</span><br><span class="line">            <span class="comment">// emplace就不需要make_pair</span></span><br><span class="line">            <span class="comment">// 因为要返回评分最高的食物和返回字典序较小的名字</span></span><br><span class="line">            <span class="comment">// 序列是相反的</span></span><br><span class="line">            <span class="comment">// 评分取负号，保证最小对应最高评分</span></span><br><span class="line">            cs[c].<span class="built_in">emplace</span>(-r, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeRating</span><span class="params">(string food, <span class="type">int</span> newRating)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出食物对应的 (评分，烹饪方式)</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;[r, c] = fs[food];</span><br><span class="line">        <span class="comment">// 获取评分和名字</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;s = cs[c];</span><br><span class="line">        s.<span class="built_in">erase</span>(&#123;-r, food&#125;); <span class="comment">// 移除旧数据</span></span><br><span class="line">        s.<span class="built_in">emplace</span>(-newRating, food); <span class="comment">// 添加新数据</span></span><br><span class="line">        <span class="comment">// 修改评分</span></span><br><span class="line">        r = newRating;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">highestRated</span><span class="params">(string cuisine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少有一种，所以取begin()-&gt;第二项（名字）</span></span><br><span class="line">        <span class="keyword">return</span> cs[cuisine].<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第四题</p>
</blockquote>
<blockquote>
<p>看不懂的可以看视频 , 韦恩图</p>
</blockquote>
<p><img src="/2022/07/25/leetcode-303-%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/leetcode_303_img9.PNG" alt></p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数：                  1      2      3</span></span><br><span class="line">    <span class="comment">// 二进制为1的个数：     1      1      2</span></span><br><span class="line">    <span class="comment">// 表格：</span></span><br><span class="line">    <span class="comment">// |-------------------------------------------------|</span></span><br><span class="line">    <span class="comment">// cx(去重后):        |   1   |   2    |</span></span><br><span class="line">    <span class="comment">// cnt:               |   2   |   1    |</span></span><br><span class="line">    <span class="comment">// |-------------------------------------------------|</span></span><br><span class="line">    <span class="comment">// 五种：                1 + 2  -&gt; 从c(x) = 1的集合中取一个, c(x) = 2 中取一个  || 2 * 1  -&gt; 有两个1</span></span><br><span class="line">    <span class="comment">//                       1 * 2  -&gt; (2, 1) 和 （1，2）</span></span><br><span class="line">    <span class="comment">//                       1 * 1  -&gt; 自己和自己</span></span><br><span class="line">    <span class="comment">// 遍历去重后的 nums\textit&#123;nums&#125;nums，统计 c(nums[i])c(nums[i])的个数，记录在 cnt 中，</span></span><br><span class="line">    <span class="comment">// 然后写一个二重循环遍历 cnt，对于所有的 c(x)+c(y)≥k，</span></span><br><span class="line">    <span class="comment">// 累加 cnt[c(x)]⋅cnt[c(y)]，表示从这两组中各选一个 x 和 y 组成优质数对的个数。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countExcellentPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="comment">// 获取cnt表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())) <span class="comment">// 去重</span></span><br><span class="line">            ++cnt[__builtin_popcount(x)];</span><br><span class="line">        <span class="type">long</span> ans = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// cx -&gt; x中1的个数， ccx -&gt; 值为x的个数</span></span><br><span class="line">        <span class="comment">// cy -&gt; y中1的个数， ccy -&gt; 值为y的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cx, ccx] : cnt)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cy, ccy] : cnt)</span><br><span class="line">                <span class="keyword">if</span> (cx + cy &gt;= k) <span class="comment">// (x,y) 是优质数对</span></span><br><span class="line">                    ans += (<span class="type">long</span>) ccx * ccy; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=258805927&bvid=BV14a411U7QZ&cid=782543429&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>


<hr>
</div>]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 周赛308</title>
    <url>/2022/08/29/leetcode-%E5%91%A8%E8%B5%9B308/</url>
    <content><![CDATA[<h1>Leetcode 周赛308复盘</h1>
<h2 id="1-和有限的最长子序列">1. 和有限的最长子序列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。</span><br><span class="line"></span><br><span class="line">返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度  。</span><br><span class="line"></span><br><span class="line">子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-4">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,2,1], queries = [3,10,21]</span><br><span class="line">输出：[2,3,4]</span><br><span class="line">解释：queries 对应的 answer 如下：</span><br><span class="line">- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。</span><br><span class="line">- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。</span><br><span class="line">- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-4">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,4,5], queries = [1]</span><br><span class="line">输出：[0]</span><br><span class="line">解释：空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。</span><br></pre></td></tr></table></figure>
<h3 id="解析：">解析：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 关键字： 子序列，求和</span><br><span class="line">2. 要求的和 与数组元素在数组中的顺序无关 =&gt; 先对数组排序</span><br><span class="line">3. 前缀和 ： 前缀和就是从位置1到位置i这个区间内的所有的数字之和。</span><br><span class="line">4. 循环遍历</span><br></pre></td></tr></table></figure>
<h3 id="代码：-4">代码：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 求前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queries[i] &gt;= nums[j])</span><br><span class="line">                    p++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-给你一个包含若干星号-的字符串-s-。">2.给你一个包含若干星号 * 的字符串 s 。</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在一步操作中，你可以：</span><br><span class="line"></span><br><span class="line">    选中 s 中的一个星号。</span><br><span class="line">    移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。</span><br><span class="line"></span><br><span class="line">返回移除 所有 星号之后的字符串。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">    生成的输入保证总是可以执行题面中描述的操作。</span><br><span class="line">    可以证明结果字符串是唯一的。</span><br></pre></td></tr></table></figure>
<h3 id="示例1-2">示例1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;leet**cod*e&quot;</span><br><span class="line">输出：&quot;lecoe&quot;</span><br><span class="line">解释：从左到右执行移除操作：</span><br><span class="line">- 距离第 1 个星号最近的字符是 &quot;leet**cod*e&quot; 中的 &#x27;t&#x27; ，s 变为 &quot;lee*cod*e&quot; 。</span><br><span class="line">- 距离第 2 个星号最近的字符是 &quot;lee*cod*e&quot; 中的 &#x27;e&#x27; ，s 变为 &quot;lecod*e&quot; 。</span><br><span class="line">- 距离第 3 个星号最近的字符是 &quot;lecod*e&quot; 中的 &#x27;d&#x27; ，s 变为 &quot;lecoe&quot; 。</span><br><span class="line">不存在其他星号，返回 &quot;lecoe&quot; 。</span><br></pre></td></tr></table></figure>
<h3 id="示例2-2">示例2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;erase*****&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：整个字符串都会被移除，所以返回空字符串。</span><br></pre></td></tr></table></figure>
<h3 id="解析：-2">解析：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈将非*的元素压入栈中</span><br><span class="line">2. 遇到*，出栈一个元素，如果栈为空，直接返回 &quot;&quot;</span><br><span class="line">3. 反转字符串 reserve</span><br></pre></td></tr></table></figure>
<h3 id="代码：-5">代码：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string removeStars(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        stack&lt;char&gt; ss;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if(s[i] != &#x27;*&#x27;) ss.push(s[i]);</span><br><span class="line">            else &#123;</span><br><span class="line">                if(!ss.empty()) </span><br><span class="line">                    ss.pop();</span><br><span class="line">                </span><br><span class="line">                else </span><br><span class="line">                    return &quot;&quot;;  </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        while(!ss.empty()) &#123;</span><br><span class="line">            res += ss.top();</span><br><span class="line">            ss.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-收集垃圾的最少总时间">3.收集垃圾的最少总时间</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个下标从 0 开始的字符串数组 garbage ，其中 garbage[i] 表示第 i 个房子的垃圾集合。garbage[i] 只包含字符 &#x27;M&#x27; ，&#x27;P&#x27; 和 &#x27;G&#x27; ，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 一 单位的任何一种垃圾都需要花费 1 分钟。</span><br><span class="line"></span><br><span class="line">同时给你一个下标从 0 开始的整数数组 travel ，其中 travel[i] 是垃圾车从房子 i 行驶到房子 i + 1 需要的分钟数。</span><br><span class="line"></span><br><span class="line">城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 0 出发，按顺序 到达每一栋房子。但它们 不是必须 到达所有的房子。</span><br><span class="line"></span><br><span class="line">任何时刻只有 一辆 垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 不能 做任何事情。</span><br><span class="line"></span><br><span class="line">请你返回收拾完所有垃圾需要花费的 最少 总分钟数。</span><br></pre></td></tr></table></figure>
<h3 id="示例1-3">示例1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：garbage = [&quot;G&quot;,&quot;P&quot;,&quot;GP&quot;,&quot;GG&quot;], travel = [2,4,3]</span><br><span class="line">输出：21</span><br><span class="line">解释：</span><br><span class="line">收拾纸的垃圾车：</span><br><span class="line">1. 从房子 0 行驶到房子 1</span><br><span class="line">2. 收拾房子 1 的纸垃圾</span><br><span class="line">3. 从房子 1 行驶到房子 2</span><br><span class="line">4. 收拾房子 2 的纸垃圾</span><br><span class="line">收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。</span><br><span class="line">收拾玻璃的垃圾车：</span><br><span class="line">1. 收拾房子 0 的玻璃垃圾</span><br><span class="line">2. 从房子 0 行驶到房子 1</span><br><span class="line">3. 从房子 1 行驶到房子 2</span><br><span class="line">4. 收拾房子 2 的玻璃垃圾</span><br><span class="line">5. 从房子 2 行驶到房子 3</span><br><span class="line">6. 收拾房子 3 的玻璃垃圾</span><br><span class="line">收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。</span><br><span class="line">由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。</span><br><span class="line">所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-5">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：garbage = [&quot;MMM&quot;,&quot;PGM&quot;,&quot;GP&quot;], travel = [3,10]</span><br><span class="line">输出：37</span><br><span class="line">解释：</span><br><span class="line">收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。</span><br><span class="line">收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。</span><br><span class="line">收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。</span><br><span class="line">总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。</span><br></pre></td></tr></table></figure>
<h3 id="解题思路：">解题思路：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 只要算出收集所有垃圾需要的时间 =&gt; garbage 所有字符串长度之和</span><br><span class="line">2. 考虑在房子之间移动的时间/距离之和 （比如M，只需要找到最后出现的下标就行)</span><br><span class="line">3. 加起来就是答案</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">garbageCollection</span><span class="params">(vector&lt;string&gt;&amp; garbage, vector&lt;<span class="type">int</span>&gt;&amp; travel)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = garbage.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; c : garbage[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">find</span>(c) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    s.<span class="built_in">insert</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 收集所有垃圾需要的时间</span></span><br><span class="line">            res += garbage[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// 最后出现的下标 * travel[下标 - 1]</span></span><br><span class="line">            res += i &gt; <span class="number">0</span> ? s.<span class="built_in">size</span>() * travel[i - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-给定条件下构造矩阵">4.给定条件下构造矩阵</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个 正 整数 k ，同时给你：</span><br><span class="line"></span><br><span class="line">    一个大小为 n 的二维整数数组 rowConditions ，其中 rowConditions[i] = [abovei, belowi] 和</span><br><span class="line">    一个大小为 m 的二维整数数组 colConditions ，其中 colConditions[i] = [lefti, righti] 。</span><br><span class="line"></span><br><span class="line">两个数组里的整数都是 1 到 k 之间的数字。</span><br><span class="line"></span><br><span class="line">你需要构造一个 k x k 的矩阵，1 到 k 每个数字需要 恰好出现一次 。剩余的数字都是 0 。</span><br><span class="line"></span><br><span class="line">矩阵还需要满足以下条件：</span><br><span class="line"></span><br><span class="line">    对于所有 0 到 n - 1 之间的下标 i ，数字 abovei 所在的 行 必须在数字 belowi 所在行的上面。</span><br><span class="line">    对于所有 0 到 m - 1 之间的下标 i ，数字 lefti 所在的 列 必须在数字 righti 所在列的左边。</span><br><span class="line"></span><br><span class="line">返回满足上述要求的 任意 矩阵。如果不存在答案，返回一个空的矩阵。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-5">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]</span><br><span class="line">输出：[[3,0,0],[0,0,1],[0,2,0]]</span><br><span class="line">解释：上图为一个符合所有条件的矩阵。</span><br><span class="line">行要求如下：</span><br><span class="line">- 数字 1 在第 1 行，数字 2 在第 2 行，1 在 2 的上面。</span><br><span class="line">- 数字 3 在第 0 行，数字 2 在第 2 行，3 在 2 的上面。</span><br><span class="line">列要求如下：</span><br><span class="line">- 数字 2 在第 1 列，数字 1 在第 2 列，2 在 1 的左边。</span><br><span class="line">- 数字 3 在第 0 列，数字 2 在第 1 列，3 在 2 的左边。</span><br><span class="line">注意，可能有多种正确的答案。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-6">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。</span><br><span class="line">没有符合条件的矩阵存在，所以我们返回空矩阵。</span><br></pre></td></tr></table></figure>
<h3 id="提示1：">提示1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数字之间的约束只发生在行与行、列于列，而行与列之间没有任何约束。</span><br><span class="line"></span><br><span class="line">因此我们可以分别处理行与列中数字的相对顺序，如何求出这个相对顺序呢？</span><br></pre></td></tr></table></figure>
<h3 id="提示2：">提示2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拓扑排序。</span><br></pre></td></tr></table></figure>
<h3 id="提示3：">提示3：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于 rowConditions，我们可以从 abovei​ 向 belowi 连一条有向边，得到一张有向图。在这张图上跑拓扑排序，得到的拓扑序就是行与行中数字的相对顺序，这样我们就知道了每一行要填哪个数字。如果得到的拓扑序长度不足 kkk，说明图中有环，无法构造，答案不存在。</span><br><span class="line"></span><br><span class="line">对 colConditions 也执行上述过程，得到每一列要填哪个数字，进而得到每个数字要填到哪一列中，这样我们就知道每一行的数字要填到哪一列了。</span><br></pre></td></tr></table></figure>
<h3 id="代码：-6">代码：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; topo_sort(int k, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; g(k);</span><br><span class="line">        vector&lt;int&gt; in_deg(k); // 入度</span><br><span class="line">        for(auto &amp;e : edges) &#123;</span><br><span class="line">            // 总共两个元素, x 在 y的上方 / 左边</span><br><span class="line">            // 顶点编号从 0 开始，方便计算</span><br><span class="line">            int x = e[0] - 1, y = e[1] - 1;</span><br><span class="line">            // 先将下边/右边的添加进图(g)中</span><br><span class="line">            g[x].push_back(y);</span><br><span class="line">            // 入度 + 1</span><br><span class="line">            ++in_deg[y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            if (in_deg[i] == 0) // 入度为0，进入队列</span><br><span class="line">                q.push(i);</span><br><span class="line">        // 使用BFS，拓扑排序和BFS原理一样，都是先从最外围的开始       </span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            int x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            order.push_back(x);</span><br><span class="line">            for(int y : g[x]) </span><br><span class="line">                if(--in_deg[y] == 0) // 入度为0，进入队列</span><br><span class="line">                q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; buildMatrix(int k, vector&lt;vector&lt;int&gt;&gt;&amp; rowConditions, vector&lt;vector&lt;int&gt;&gt;&amp; colConditions) &#123;</span><br><span class="line">        auto row = topo_sort(k, rowConditions), col = topo_sort(k, colConditions);</span><br><span class="line">        if (row.size() &lt; k || col.size() &lt; k) return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; pos(k);</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            // pos[x] 表示元素 x 应该在哪一列，这样最后的答案就知道要把 row[i] 放在哪一列了</span><br><span class="line">            pos[col[i]] = i;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans(k, vector&lt;int&gt;(k));</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            ans[i][pos[row[i]]] = row[i] + 1;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>python 每日一报</title>
    <url>/2022/06/30/python-%E6%AF%8F%E6%97%A5%E4%B8%80%E6%8A%A5/</url>
    <content><![CDATA[<h3 id="代码较简单">代码较简单</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.implicitly_wait(10)</span><br><span class="line">driver.get(&#x27;https://id.sspu.edu.cn/cas/login?service=https%3a%2f%2fhsm.sspu.edu.cn%2fselfreport%2fLoginSSO.aspx%3ftargetUrl%3d%7bbase64%7daHR0cHM6Ly9oc20uc3NwdS5lZHUuY24vc2VsZnJlcG9ydC9JbmRleC5hc3B4&#x27;)</span><br><span class="line">driver.find_element(By.ID, &quot;username&quot;).send_keys(&quot;your admin&quot;)</span><br><span class="line">driver.find_element(By.ID, &quot;password&quot;).send_keys(&quot;your password&quot;)</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, &#x27;.submit_button&#x27;).click()</span><br><span class="line">driver.implicitly_wait(10)</span><br><span class="line">driver.find_element(By.XPATH, &quot;/html/body/form/div[6]/ul/li[1]/a/span&quot;).click();</span><br><span class="line"># 报送日期</span><br><span class="line">js=&quot;document.getElementById(&#x27;p1_BaoSRQ-inputEl&#x27;).removeAttribute(&#x27;readonly&#x27;)&quot;</span><br><span class="line">#js = &quot;$(&#x27;input:eq(0)&#x27;).removeAttr(&#x27;readonly&#x27;)&quot;</span><br><span class="line">driver.execute_script(js)</span><br><span class="line">input_datetime = driver.find_element(By.XPATH, &#x27;//*[@id=&quot;p1_BaoSRQ-inputEl&quot;]&#x27;)</span><br><span class="line">input_datetime.clear()</span><br><span class="line">input_datetime.send_keys(&quot;2022-06-23&quot;)</span><br><span class="line"></span><br><span class="line"># 国内</span><br><span class="line">driver.find_element(By.ID, &#x27;p1_TiWen-inputEl&#x27;).send_keys(36.6)</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, &#x27;.f-btn-text&#x27;).click()</span><br><span class="line">time.sleep(1)</span><br><span class="line"># driver.find_element(By.CSS_SELECTOR, &#x27;.f-btn-text&#x27;).click()</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;PyCharm&#x27;)</span><br><span class="line"></span><br><span class="line"># See PyCharm help at https://www.jetbrains.com/help/pycharm/</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Firefox WebDriver, 安装Selenium</title>
    <url>/2022/06/23/webdriver-config/</url>
    <content><![CDATA[<h2 id="1-安装Selenium">1.安装Selenium</h2>
<h4 id="1-1-在Anaconda下">1.1 在Anaconda下</h4>
<p><img src="/2022/06/23/webdriver-config/img1.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install selnium</span><br></pre></td></tr></table></figure>
<p>#查找Python 安装位置</p>
<p><img src="/2022/06/23/webdriver-config/img2.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where Python</span><br></pre></td></tr></table></figure>
<h2 id="2-下载火狐WebDriver">2.下载火狐WebDriver</h2>
<h4 id="2-1-下载">2.1 下载</h4>
<h4 id="Tips：一般下载最新版本就行">Tips：一般下载最新版本就行</h4>
<p><img src="/2022/06/23/webdriver-config/img3.png" alt><br>
网站如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/mozilla/geckodriver/releases/</span><br></pre></td></tr></table></figure>
<h4 id="2-2-解压后放在Python的安装位置">2.2 解压后放在Python的安装位置</h4>
<p><img src="/2022/06/23/webdriver-config/img4.png" alt></p>
<h4 id="2-3-在Anaconda-Jupyter下进行测试">2.3 在Anaconda Jupyter下进行测试</h4>
<p><img src="/2022/06/23/webdriver-config/img5.png" alt><br>
代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.implicitly_wait(5)</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">time.sleep(3)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>
<h2 id="测试成功">测试成功</h2>
<p><img src="/2022/06/23/webdriver-config/img6.png" alt></p>
]]></content>
      <tags>
        <tag>配置</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>基本排序算法</title>
    <url>/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/basic_sort_img1.png" alt><br>
<img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/basic_sort_img2.png" alt></p>
<h1>冒泡排序</h1>
<h2 id="1-算法步骤">1. 算法步骤</h2>
<ol>
<li>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li>
<p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ol>
<h2 id="2-动图演示">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" alt="动图演示"></p>
<ol>
<li>代码:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt) </span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 每次确定一个最大值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vc[j] &gt; vc[j + <span class="number">1</span>]) <span class="built_in">swap</span>(vc[j], vc[j + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(vc, i);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;	</span><br><span class="line">	<span class="built_in">bubble_sort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>插入排序</h1>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h2 id="1-算法步骤-2">1. 算法步骤</h2>
<ol>
<li>
<p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
</li>
<li>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
</li>
</ol>
<h2 id="2-动图演示-2">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertionSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> key = vc[i];</span><br><span class="line">		<span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; (key &lt; vc[j])) &#123;</span><br><span class="line">			vc[j + <span class="number">1</span>] = vc[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// -1 + 1 = 0</span></span><br><span class="line">		vc[j + <span class="number">1</span>] = key;</span><br><span class="line">		<span class="built_in">print</span>(vc, i);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">insertion_sort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>选择排序</h1>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="1-算法步骤-3">1. 算法步骤</h2>
<ol>
<li>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
</li>
<li>
<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
</li>
<li>
<p>重复第二步，直到所有元素均排序完毕。</p>
</li>
</ol>
<h2 id="2-动图演示-3">2. 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt) </span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort_min</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> min;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		min = i; </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) </span><br><span class="line">			<span class="keyword">if</span> (vc[j] &lt; vc[min])</span><br><span class="line">				min = j;</span><br><span class="line">		<span class="built_in">swap</span>(vc[min], vc[i]);</span><br><span class="line">		<span class="built_in">print</span>(vc, i + <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort_max</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = vc.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		max = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vc[j] &gt; vc[max]) max = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(vc[i], vc[max]);</span><br><span class="line">		<span class="built_in">print</span>(vc, len - (i + <span class="number">1</span>));</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*vector&lt;int&gt; vc = &#123; 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 &#125;;	</span></span><br><span class="line"><span class="comment">	selection_sort_min(vc);*/</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc2 = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">selection_sort_max</span>(vc2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.希尔排序</p>
</blockquote>
<h1>希尔排序</h1>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h2 id="1-算法步骤-4">1. 算法步骤</h2>
<ol>
<li>
<p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>
</li>
<li>
<p>按增量序列个数 k，对序列进行 k 趟排序；</p>
</li>
<li>
<p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序的间隔序列不推荐用2的幂(1 2 4 8 16...)，</span></span><br><span class="line"><span class="comment">// 因为这样直到间隔为1之前，都不会将奇数位置与偶数位置的元素进行比较，这样是低效的。</span></span><br><span class="line"><span class="comment">// 希尔自己认为可以用2的幂 - 1序列(1 3 7 15...)，后来又有文章建议用3x + 1(1 4 13 40 121...)，都是可以的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 间隔为3x + 1</span></span><br><span class="line">	<span class="type">int</span> gap = vc.<span class="built_in">size</span>() / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; gap &gt;= <span class="number">1</span>; gap /= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gap; ++i) &#123;</span><br><span class="line">			<span class="comment">// 组内排序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + gap; j &lt; vc.<span class="built_in">size</span>(); j += gap) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = j; k - gap &gt;= <span class="number">0</span> &amp;&amp; vc[k] &lt; vc[k - gap]; k -= gap) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(vc[k], vc[k - gap]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">print</span>(vc, i + <span class="number">1</span>);</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">	<span class="built_in">shellSort</span>(vc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5.归并排序</p>
</blockquote>
<h1>归并排序</h1>
<h2 id="1-算法步骤-5">1. 算法步骤</h2>
<ol>
<li>
<p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li>
<p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li>
<p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li>
<p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li>
<p>将另一序列剩下的所有元素直接复制到合并序列尾。</p>
</li>
</ol>
<h2 id="2…-动图演示">2… 动图演示</h2>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ptrL = l;</span><br><span class="line">    <span class="type">int</span> ptrR = mid;</span><br><span class="line">    <span class="type">static</span> vector&lt;<span class="type">int</span>&gt;tempary;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &gt; tempary.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        tempary.<span class="built_in">resize</span>(arr.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrL != mid &amp;&amp; ptrR != r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[ptrL] &lt; arr[ptrR]) &#123;</span><br><span class="line">            tempary[index++] = arr[ptrL++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tempary[index++] = arr[ptrR++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrL != mid) &#123;</span><br><span class="line">        tempary[index++] = arr[ptrL++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptrR != r) &#123;</span><br><span class="line">        tempary[index++] = arr[ptrR++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(tempary.<span class="built_in">begin</span>(), tempary.<span class="built_in">begin</span>() + index, arr.<span class="built_in">begin</span>() + l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// sort the range [l, r) in arr</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, mid, r);</span><br><span class="line">    <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="built_in">mergeSort</span>(vc, <span class="number">0</span>, vc.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">print</span>(vc, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>6.堆排序</p>
</blockquote>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/heapSort.gif" alt="动图演示"></p>
<blockquote>
<p>对于一个完全二叉树，在填满的情况下（非叶子节点都有两个子节点），每一层的元素个数是上一层的二倍，根节点数量是1，所以最后一层的节点数量，一定是之前所有层节点总数+1，<br>
所以，我们能找到最后一层的第一个节点的索引，即节点总数/2（根节点索引为0），这也就是第一个叶子节点，所以第一个非叶子节点的索引就是第一个叶子结点的索引-1。<br>
那么对于填不满的二叉树呢？这个计算方式仍然适用，当我们从上往下，从左往右填充二叉树的过程中，第一个叶子节点，一定是序列长度/2，所以第一个非叶子节点的索引就是arr.length / 2 - 1。</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 父节点 * 2 + 1为左子节点</span></span><br><span class="line">	<span class="comment">// 从最后一个叶子节点开始</span></span><br><span class="line">	<span class="type">int</span> fa = start, so = fa * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (so &lt;= end) &#123;</span><br><span class="line">		<span class="comment">// 比较两个子节点大小，选大的那个</span></span><br><span class="line">		<span class="keyword">if</span> (so + <span class="number">1</span> &lt;= end &amp;&amp; vec[so] &lt; vec[so + <span class="number">1</span>]) </span><br><span class="line">			so++; <span class="comment">// so = so + 1;</span></span><br><span class="line">		<span class="keyword">if</span> (vec[fa] &gt; vec[so]) <span class="comment">// 父节点大于子节点则不需要调整</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">			<span class="built_in">swap</span>(vec[fa], vec[so]);</span><br><span class="line">			fa = so;</span><br><span class="line">			so = fa * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 这里是*2 不是/2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 索引从0开始，寻找第一个非叶子节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">max_heapify</span>(vec, i, len - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(vec[<span class="number">0</span>], vec[i]);</span><br><span class="line">		<span class="built_in">max_heapify</span>(vec, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// vector&lt;int&gt; vec = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">heap_sort</span>(vec, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>7.快速排序</p>
</blockquote>
<p><img src="/2022/07/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" alt="动图演示"></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vc, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;轮 ： &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; vc.<span class="built_in">size</span>() - <span class="number">1</span>; ++cnt)</span><br><span class="line">		cout &lt;&lt; vc[cnt] &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; vc[vc.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> left = low;</span><br><span class="line">    <span class="type">int</span> right = high;</span><br><span class="line">    <span class="type">int</span> key = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*从左向右找比key大的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (left == high) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*从右向左找比key小的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (right == low)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*中枢值与j对应值交换*/</span></span><br><span class="line">    arr[low] = arr[right];</span><br><span class="line">    arr[right] = key;</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, low, right - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, right + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vc = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="built_in">Qsort</span>(vc, <span class="number">0</span>, vc.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(vc, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>8.基数排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>9.桶排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>10.计数排序</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转数字</title>
    <url>/2022/07/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<blockquote>
<p>如图：</p>
</blockquote>
<p><img src="/2022/07/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97/img1.PNG" alt></p>
<blockquote>
<p>代码:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; diffWaysToCompute(string expression) &#123;</span><br><span class="line">        vector&lt;int&gt; ops;</span><br><span class="line">        for (int i = 0; i &lt; expression.size();) &#123;</span><br><span class="line">            // 如果不是数字</span><br><span class="line">            if (!isdigit(expression[i])) &#123;</span><br><span class="line">                if (expression[i] == &#x27;+&#x27;) &#123;</span><br><span class="line">                    ops.push_back(ADDITION);</span><br><span class="line">                &#125; else if (expression[i] == &#x27;-&#x27;) &#123;</span><br><span class="line">                    ops.push_back(SUBTRACTION);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ops.push_back(MULTIPLICATION);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int t = 0;</span><br><span class="line">                while (i &lt; expression.size() &amp;&amp; isdigit(expression[i])) &#123;</span><br><span class="line">                    t = t * 10 + expression[i] - &#x27;0&#x27;; // 转换为数字w</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ops.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉树复习</title>
    <url>/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>二叉树复习 -&gt; 树的遍历 (重要)</p>
</blockquote>
<ol>
<li>建立二叉树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>前序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img1.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img2.PNG" alt></li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归实现（使用栈）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res; </span><br><span class="line">        stack&lt;TreeNode*&gt;stc;</span><br><span class="line">        stc.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stc.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(stc.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">            TreeNode* tmp = stc.<span class="built_in">top</span>();</span><br><span class="line">            stc.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 因为是stack(栈),需要先右后左</span></span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right) stc.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left) stc.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>中序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img3.PNG" alt></li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, vc);</span><br><span class="line">        vc.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, vc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line">        <span class="built_in">inorder</span>(root, vc);</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="comment">// 非叶子节点 || 栈不为空</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是root!</span></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>后序遍历</li>
</ol>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root,  vector&lt;<span class="type">int</span>&gt;&amp; vc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left, vc);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right, vc);</span><br><span class="line">    vc.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line">    <span class="built_in">postorder</span>(root, vc);</span><br><span class="line">    <span class="keyword">return</span> vc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代实现 暂时没看懂</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>层序遍历<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img4.PNG" alt></li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">//创建返回数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="comment">//若空</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">//根节点压入队列</span></span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">//若队列不为空，循环</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//当前队列长度</span></span><br><span class="line">            <span class="type">int</span> queLen = que.<span class="built_in">size</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            <span class="comment">//循环遍历当前层所有节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; queLen; ++i)&#123;</span><br><span class="line">                <span class="comment">//选择节点</span></span><br><span class="line">                <span class="keyword">auto</span> node = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">//选择的当前节点弹出队列</span></span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//将选择的当前节点的值压入数组</span></span><br><span class="line">                ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//寻找当前节点的下一层节点压入队列</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树复习 -&gt; 运用递归解决树的问题</p>
</blockquote>
<ol>
<li>二叉树的最大深度<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img5.PNG" alt></li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left_depth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right_depth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_depth, right_depth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.对称二叉树<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img6.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img7.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetricHelper</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果左右节点都为空, 说明当前节点是叶子节点，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点只有一个子节点或者有两个子节点，但两个子节点的值不相同，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span> || left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//然后左子节点的左子节点和右子节点的右子节点比较，左子节点的右子节点和右子节点的左子节点比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetricHelper</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isSymmetricHelper</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//从两个子节点开始判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetricHelper</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>路径总和（这题也是很妙的做法）</li>
</ol>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img8.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img9.PNG" alt></p>
<blockquote>
<p>递归法，没递归到一个节点，就拿target-当前节点值，如果存在路径总和等于target，那么最后一个叶子节点一定等于target剩下的值。<br>
如果递归到叶子节点后，剩余的target值不等于叶子节点，说明不存在路径总和等于target。<br>
时间复杂度O（n），空间复杂度O（1）。</p>
</blockquote>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==null &amp;&amp; root.right==null)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root.left,targetSum - root.val) || <span class="built_in">hasPathSum</span>(root.right,targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树复习 -&gt; 总结</p>
</blockquote>
<ol>
<li>从中序与后序遍历序列构造二叉树</li>
</ol>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img10.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> head1, <span class="type">int</span> tail1, <span class="type">int</span> head2, <span class="type">int</span> tail2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断什么时候停止递归</span></span><br><span class="line">        <span class="keyword">if</span>(head2 &gt; tail2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> last_elem = postorder[tail2];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(last_elem);</span><br><span class="line">        <span class="keyword">if</span>(head2 == tail2) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找分割点</span></span><br><span class="line">        <span class="type">int</span> spilit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(inorder[head1 + spilit] != last_elem) spilit++; </span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(inorder, postorder, head1, head1 + spilit - <span class="number">1</span>, head2, head2 + spilit - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(inorder, postorder, head1 + spilit + <span class="number">1</span>, tail1, head2 + spilit, tail2 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 如果是空树,返回nullptr</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(inorder, postorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>从前序与中序遍历序列构造二叉树<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img11.PNG" alt></li>
</ol>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="type">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="type">int</span> inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        <span class="comment">// 建立根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 获取左子树的节点数</span></span><br><span class="line">        <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        root-&gt;left = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span> + size_left_subtree, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">         <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">             index[inorder[i]] = i;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.填充每个节点的下一个右侧节点指针<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img12.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node*&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                Node* node = Q.<span class="built_in">front</span>();</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 因为最后一个节点的next不需要赋值</span></span><br><span class="line">                <span class="keyword">if</span>(i &lt; size - <span class="number">1</span>) node-&gt;next = Q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) Q.<span class="built_in">push</span>(node-&gt;left) ;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.填充每个节点的下一个右侧节点指针 II<br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img13.PNG" alt></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i &lt; size - <span class="number">1</span>) node-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.二叉树的最近公共祖先</p>
<blockquote>
<p>tip: 这题也是挺巧的,如果left为空，说明这两个节点在cur结点的右子树上，我们只需要返回右子树查找的结果即可，反之<br>
查找左子树，如果left和right都不为空，说明这两个节点一个在cur的左子树上一个在cur的右子树上，我们只需要返回cur结点<br>
即可</p>
</blockquote>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img14.PNG" alt></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">       TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">       TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">       <span class="comment">// 公共节点在根节点的右子树上</span></span><br><span class="line">       <span class="keyword">if</span>(left == <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">       <span class="comment">// 公共节点在根节点的左子树上</span></span><br><span class="line">       <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6.二叉树的序列化与反序列化</p>
<p><img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img15.PNG" alt><br>
<img src="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0/binary_tree_review_img16.PNG" alt></p>
<p>链接： <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/</a></p>
<blockquote>
<p>tips: 条例非常清晰，代码可阅读性很高</p>
</blockquote>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserialize</span><span class="params">(TreeNode* root, string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            str += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            str += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            <span class="built_in">reserialize</span>(root-&gt;left, str);</span><br><span class="line">            <span class="built_in">reserialize</span>(root-&gt;right, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="built_in">reserialize</span>(root, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">rdeserialize</span><span class="params">(list&lt;string&gt;&amp; dataArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dataArray.<span class="built_in">front</span>() == <span class="string">&quot;None&quot;</span>)&#123;</span><br><span class="line">            dataArray.<span class="built_in">erase</span>(dataArray.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(dataArray.<span class="built_in">front</span>()));</span><br><span class="line">        dataArray.<span class="built_in">erase</span>(dataArray.<span class="built_in">begin</span>());</span><br><span class="line">        root-&gt;left = <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">        root-&gt;right = <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        list&lt;string&gt; dataArray;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : data) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                dataArray.<span class="built_in">push_back</span>(str);</span><br><span class="line">                str.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> str.<span class="built_in">push_back</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            dataArray.<span class="built_in">push_back</span>(str);</span><br><span class="line">            str.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rdeserialize</span>(dataArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构: 链表复习</title>
    <url>/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>链表复习 -&gt; leetcode/牛客快速测试模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode* next;</span><br><span class="line">	<span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode* next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		cout &lt;&lt; head-&gt;val &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">	ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">	ListNode* cur = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">		cur-&gt;next = tmp;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ShowList</span>(head-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 设计链表 (重要)</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img1.PNG" alt></p>
<h2 id="代码：-注意点：新节点next一定设置为nullptr">代码： 注意点：新节点next一定设置为nullptr</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">val</span>(x) &#123;&#125; <span class="comment">// 初始化</span></span><br><span class="line">        Node* next; <span class="comment">// 指针域</span></span><br><span class="line">        <span class="type">int</span> val; <span class="comment">// 数据域</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        nHead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 初始化头指针</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表中第 index 个节点的值。如果索引无效，则返回-1。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引比0小或者比最大索引大，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; (len - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* tmp = nHead-&gt;next; <span class="comment">// 辅助指针指向第一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(index--) tmp = tmp-&gt;next; <span class="comment">// 循环index次遍历到第index个节点</span></span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(val);  <span class="comment">// 创建新节点</span></span><br><span class="line">        tmp-&gt;next = nHead-&gt;next; </span><br><span class="line">        nHead-&gt;next = tmp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tmp = nHead;</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next) tmp = tmp-&gt;next;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        newNode-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 赋值为nullptr</span></span><br><span class="line">        tmp-&gt;next = newNode;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span> ) <span class="built_in">addAtHead</span>(val); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index == len) <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">            Node* cur = nHead;</span><br><span class="line">            <span class="keyword">while</span>(index--) cur = cur-&gt;next;</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span>;</span><br><span class="line">        Node* cur = nHead;</span><br><span class="line">        <span class="keyword">while</span>(index--)  cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Node* nHead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 环形链表（基础）</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img2.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img3.PNG" alt></p>
<h2 id="代码：-注意点：循环条件应该是next指针不为空">代码： 注意点：循环条件应该是next指针不为空</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="或者-如下方这种使用do-while">或者 如下方这种使用do-while</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *f=head;</span><br><span class="line">        ListNode *s=head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(f-&gt;next==<span class="literal">nullptr</span>||f-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            f=f-&gt;next-&gt;next;</span><br><span class="line">            s=s-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(f!=s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 环形链表（进阶）</p>
</blockquote>
<blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>
不允许修改 链表。</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img4.PNG" alt></p>
<h3 id="方法一-哈希表-注意：-unordered-set-ListNode-内部是一个指针">方法一. 哈希表 注意： unordered_set&lt;ListNode*&gt; 内部是一个指针</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; unset;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span>(unset.<span class="built_in">count</span>(head)) <span class="keyword">return</span> head;</span><br><span class="line">            unset.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二-快慢指针-此方法需要手算，思路清晰-最后要移动c个next">方法二. 快慢指针: 此方法需要手算，思路清晰,最后要移动c个next</h3>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img5.PNG" alt></p>
<h2 id="代码：-7">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 相交链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img6.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img7.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img8.PNG" alt></p>
<h2 id="代码：-非常巧妙的想法">代码： 非常巧妙的想法</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = headA, *p2 = headB;</span><br><span class="line">        <span class="comment">//变轨次数</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span> p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            <span class="comment">//p1变轨</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">2</span> &amp;&amp; p1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p1 = headB;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p2变轨</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">2</span> &amp;&amp; p2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p2 = headA;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双指针技巧 -&gt; 删除链表的倒数第N个节点</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img9.PNG" alt></p>
<h2 id="代码：-使用的依旧是快慢指针">代码： 使用的依旧是快慢指针</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">nullptr</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> slow-&gt;next = (slow-&gt;next)-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 反转链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img10.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img11.PNG" alt></p>
<h2 id="代码：老算法了">代码：老算法了</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head, *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 移除链表元素</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img12.PNG" alt></p>
<h2 id="代码：加个头结点-之后的代码都是常规代码">代码：加个头结点,之后的代码都是常规代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* no_val_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        no_val_head-&gt;next = head;</span><br><span class="line">        ListNode* p = no_val_head, *q = no_val_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = q;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> no_val_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 奇偶链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img13.PNG" alt></p>
<h2 id="代码：分两个部分-奇数部分和偶数部分-头结点不变">代码：分两个部分,奇数部分和偶数部分,头结点不变</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* odd = head, *evenHead = head-&gt;next;</span><br><span class="line">        ListNode* even = evenHead;</span><br><span class="line">        <span class="keyword">while</span>(even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 经典问题 -&gt; 回文链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img14.PNG" alt></p>
<h2 id="代码：-很妙的构思-采用递归">代码： 很妙的构思,采用递归</h2>
<h3 id="正常解法">正常解法</h3>
<h3 id="巧妙的解法">巧妙的解法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode *t;</span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        res = <span class="built_in">recursivelyCheck</span>(head-&gt;next) &amp;&amp; (t-&gt;val==head-&gt;val);</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        t = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 双链表 -&gt; 设计链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img15.PNG" alt></p>
<h2 id="代码：-8">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Node* prev;</span><br><span class="line">        Node* next;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">val</span>(x) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>()&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 头结点</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* tm = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--) </span><br><span class="line">            tm = tm-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> tm-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* tm = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            head-&gt;next-&gt;prev = tm;</span><br><span class="line">        tm-&gt;prev = head;</span><br><span class="line">        tm-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = tm;</span><br><span class="line">        len ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = len;</span><br><span class="line">        Node* tmp = head;</span><br><span class="line">        Node * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next) </span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        tmp-&gt;next = newNode;</span><br><span class="line">        newNode-&gt;prev = tmp;</span><br><span class="line">        newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) <span class="built_in">addAtHead</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index == len) <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* tmp = head-&gt;next;</span><br><span class="line">            Node * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">            <span class="keyword">while</span>(index--) </span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            </span><br><span class="line">            newNode-&gt;next = tmp;</span><br><span class="line">            newNode-&gt;prev = tmp-&gt;prev;</span><br><span class="line">            tmp-&gt;prev-&gt;next = newNode;</span><br><span class="line">            tmp-&gt;prev = newNode;</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span>;</span><br><span class="line">         Node * tmp = head-&gt;next;</span><br><span class="line">         <span class="keyword">while</span>(index--) </span><br><span class="line">             tmp = tmp-&gt;next;</span><br><span class="line">         <span class="keyword">if</span>(tmp-&gt;next) &#123;</span><br><span class="line">            tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">            tmp-&gt;prev-&gt;next = tmp-&gt;next;    </span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             tmp-&gt;prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">delete</span> tmp;</span><br><span class="line">         len--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Node* prev;</span></span><br><span class="line">    Node* head, *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 合并两个有序链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img16.PNG" alt></p>
<h2 id="代码：-9">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list1 &amp;&amp; !list2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* nHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* p = nHead, *lA = list1, *lB = list2;</span><br><span class="line">        <span class="keyword">while</span>(lA &amp;&amp; lB) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lA-&gt;val &lt;= lB-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = lA;</span><br><span class="line">                p = lA;</span><br><span class="line">                lA = lA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = lB;</span><br><span class="line">                p = lB;</span><br><span class="line">                lB = lB-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lA) p-&gt;next = lA;</span><br><span class="line">        <span class="keyword">if</span>(lB) p-&gt;next = lB;</span><br><span class="line">        <span class="keyword">return</span> nHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 两数相加</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img17.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img18.PNG" alt></p>
<h2 id="代码：-10">代码：</h2>
<h3 id="正常方法：">正常方法：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * @param head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reserve</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">addInList</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> head2;</span><br><span class="line">        <span class="keyword">if</span>(head2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> head1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转链表</span></span><br><span class="line">        <span class="comment">// 9-&gt;3-&gt;7   =&gt;  7-&gt;3-&gt;9</span></span><br><span class="line">        <span class="comment">// 6-&gt;3      =&gt;  3-&gt;6</span></span><br><span class="line">        head1 = <span class="built_in">reserve</span>(head1);</span><br><span class="line">        head2 = <span class="built_in">reserve</span>(head2);</span><br><span class="line">        <span class="comment">// 创建新的表头节点</span></span><br><span class="line">        ListNode* res= <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p = res;</span><br><span class="line">        <span class="comment">// 进位的值</span></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 || head2 ) &#123;</span><br><span class="line">            <span class="comment">// 累加值(head1-&gt;val + head2-&gt;val + tmp)</span></span><br><span class="line">            <span class="type">int</span> total = carry;</span><br><span class="line">            <span class="keyword">if</span>(head1) &#123;</span><br><span class="line">                <span class="comment">// 节点不为空，加上当前节点值</span></span><br><span class="line">                total += head1-&gt;val;</span><br><span class="line">                head1 = head1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head2) &#123;</span><br><span class="line">                total += head2-&gt;val;</span><br><span class="line">                head2 = head2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求进位</span></span><br><span class="line">            carry = total / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 求余后的值为当前节点的值</span></span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(total % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 下一个节点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后两条链表都加完，且当进位不为0的时候，加上进位位</span></span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加上进位</span></span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reserve</span>(res-&gt;next);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="巧方法">巧方法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(l1 || l2 || sum)&#123;</span><br><span class="line">             <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                 sum += l1-&gt;val;</span><br><span class="line">                 l1 = l1-&gt;next;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">                 sum += l2-&gt;val;</span><br><span class="line">                 l2 = l2-&gt;next;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">             cur = cur-&gt;next;</span><br><span class="line">             sum /= <span class="number">10</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 扁平化多级双向链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img19.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img20.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img21.PNG" alt></p>
<h2 id="代码：-p-next-r是点睛之笔">代码： p-&gt;next = r是点睛之笔</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">       Node* p = head, *q, *r;</span><br><span class="line">       <span class="keyword">while</span>(p) &#123;</span><br><span class="line">           <span class="keyword">if</span>(p-&gt;child != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">               q = p-&gt;next;</span><br><span class="line">               r = p-&gt;child;</span><br><span class="line">               p-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">               p-&gt;next = r; <span class="comment">// 为下次递归做铺垫</span></span><br><span class="line">               r-&gt;prev = p;</span><br><span class="line">               <span class="keyword">while</span>(r-&gt;next) r = r-&gt;next;</span><br><span class="line">               r-&gt;next = q;</span><br><span class="line">               <span class="keyword">if</span> (q != <span class="literal">NULL</span>) q-&gt;prev = r;</span><br><span class="line">           &#125;</span><br><span class="line">           p = p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 复制带随机指针的链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img22.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img23.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img26.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img27.PNG" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next)  <span class="comment">//复制每个节点，并将原链表和复制链表连在一起。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next)   <span class="comment">//复制random指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;random)</span><br><span class="line">              p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拆分两个链表，并复原原链表</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>), cur = dummy; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            cur = cur-&gt;next = q;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img28.PNG" alt></p>
<h2 id="代码：使用的unordered-map">代码：使用的unordered_map</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; unmap;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        unmap[head] = newNode;</span><br><span class="line">        newNode-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;random) newNode-&gt;random = unmap[head-&gt;random];</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>链表复习 -&gt; 小结 -&gt; 旋转链表</p>
</blockquote>
<p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img24.PNG" alt><br>
<img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0/list_review_img25.PNG" alt></p>
<h2 id="代码-先变成循环链表再确定位置断开">代码: 先变成循环链表再确定位置断开</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        <span class="comment">// n - k % len是新链表头节点的索引</span></span><br><span class="line">        <span class="comment">// n - k % len - 1是新链表尾节点的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - k % len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt; 判断链表是否为回文结构</p>
</blockquote>
<h2 id="描述：">描述：</h2>
<blockquote>
<p>给定一个链表，请判断该链表是否为回文结构。<br>
回文是指该字符串正序逆序完全一致。</p>
</blockquote>
<h3 id="示例1-4">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1&#125;</span><br><span class="line">返回值：true</span><br></pre></td></tr></table></figure>
<h3 id="示例2-3">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;2,1&#125;</span><br><span class="line">返回值：false</span><br><span class="line">说明：2-&gt;1   </span><br></pre></td></tr></table></figure>
<h3 id="示例3">示例3</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,2,2,1&#125;</span><br><span class="line">返回值：true</span><br><span class="line">说明：1-&gt;2-&gt;2-&gt;1      </span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reserve</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPail</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="comment">// 找中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中点处翻转</span></span><br><span class="line">        slow = <span class="built_in">reserve</span>(slow);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow) &#123;</span><br><span class="line">            <span class="comment">// 比较值是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != fast-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt;  删除有序链表中重复的元素-I</p>
</blockquote>
<h2 id="描述">描述</h2>
<blockquote>
<p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>
例如：<br>
给出的链表为1→1→2,返回1→2。<br>
给出的链表为1→1→2→3→3,返回1→2→3。</p>
</blockquote>
<h3 id="示例1-5">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,1,2&#125;</span><br><span class="line">返回值：&#123;1,2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例2-4">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;&#125;</span><br><span class="line">返回值：&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码：-11">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* nHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode*p = head, *q = nHead;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(p-&gt;val) == set.<span class="built_in">end</span>())</span><br><span class="line">                set.<span class="built_in">emplace</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : set) &#123;</span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">            q-&gt;next = tmp;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表复习 -&gt; 附加 -&gt;  删除有序链表中重复的元素-II</p>
</blockquote>
<h2 id="描述-2">描述</h2>
<blockquote>
<p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>
例如：<br>
给出的链表为1→2→3→3→4→4→5,返回1→2→5.<br>
给出的链表为1→1→1→2→3, 返回2→3.</p>
</blockquote>
<h3 id="示例1-6">示例1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,2,2&#125;</span><br><span class="line">返回值：&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例2-5">示例2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;&#125;</span><br><span class="line">返回值：&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码：-12">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> tmp = cur-&gt;next-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val == tmp) </span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>C++ primer 第12章 动态内存与智能指针</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img1.PNG" alt></p>
<blockquote>
<p>shared_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img2.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img3.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img4.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img5.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img6.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img7.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img8.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img9.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img10.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img11.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img12.PNG" alt></p>
<blockquote>
<p>编写函数，返回一个动态分配的 int 的vector。将此vector 传递给另一个函数，这个函数读取标准输入，将读入的值保存在 vector 元素中。再将vector传递给另一个函数，打印读入的值。记得在恰当的时刻delete vector。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;* alloc_vector()</span><br><span class="line">&#123;</span><br><span class="line">	return new vector&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assign_vector(vector&lt;int&gt;* p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (std::cin &gt;&gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_vector(vector&lt;int&gt;* p)</span><br><span class="line">&#123;</span><br><span class="line">	for (auto i : *p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto p = alloc_vector();</span><br><span class="line">	assign_vector(p);</span><br><span class="line">	print_vector(p);</span><br><span class="line">	delete p;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重做上一题，这次使用 shared_ptr 而不是内置指针。</p>
</blockquote>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;vector&lt;int&gt;&gt; alloc_vector()</span><br><span class="line">&#123;</span><br><span class="line">	return std::make_shared&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assign_vector(std::shared_ptr&lt;vector&lt;int&gt;&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (std::cin &gt;&gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_vector(std::shared_ptr&lt;vector&lt;int&gt;&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	for (auto i : *p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto p = alloc_vector();</span><br><span class="line">	assign_vector(p);</span><br><span class="line">	print_vector(p);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>unique_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img13.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img14.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img15.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img16.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img17.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img18.PNG" alt></p>
<blockquote>
<p>如果你试图拷贝或赋值 unique_ptr，编译器并不总是能给出易于理解的错误信息。编写包含这种错误的程序，观察编译器如何诊断这种错误。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using std::string; using std::unique_ptr;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;string&gt; p1(new string(&quot;pezy&quot;));</span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;</span><br><span class="line">    p1.reset(nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>shared_ptr 为什么没有 release 成员？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">release 成员的作用是放弃控制权并返回指针，因为在某一时刻只能有一个 unique_ptr 指向某个对象，unique_ptr 不能被赋值，所以要使用 release 成员将一个 unique_ptr 的指针的所有权传递给另一个 unique_ptr。而 shared_ptr 允许有多个 shared_ptr 指向同一个对象，因此不需要 release 成员。</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>weak_ptr</p>
</blockquote>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img19.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img20.PNG" alt></p>
<blockquote>
<p>定义你自己版本的 StrBlobPtr，更新 StrBlob 类，加入恰当的 friend 声明以及 begin 和 end 成员。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using std::vector; using std::string;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class StrBlobPtr;</span><br><span class="line">class ConstStrBlobStr;</span><br><span class="line"></span><br><span class="line">class StrBlob &#123;</span><br><span class="line">public:</span><br><span class="line">    friend class StrBlobPtr;</span><br><span class="line">    friend class ConstStrBlobPtr;</span><br><span class="line">    using size_type = vector&lt;string&gt;::size_type;</span><br><span class="line"></span><br><span class="line">    StrBlobPtr begin();</span><br><span class="line">    StrBlobPtr end();</span><br><span class="line">    ConstStrBlobPtr cbegin();</span><br><span class="line">    ConstStrBlobPtr cend();</span><br><span class="line">    StrBlob() :data(std::make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">    StrBlob(std::initializer_list&lt;string&gt; il) :data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">    bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const string&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">    void pop_back() &#123;</span><br><span class="line">        check(0, &quot;pop_back on empty StrBlob&quot;);</span><br><span class="line">        data-&gt;pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; front() &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; back() &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const std::string&amp; front() const &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line">    const std::string&amp; back() const &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void check(size_type i, const string&amp; msg) const &#123;</span><br><span class="line">        if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;vector&lt;string&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConstStrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    ConstStrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    ConstStrBlobPtr(const StrBlob&amp; a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    ConstStrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const ConstStrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    StrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConstStrBlobPtr StrBlob::cbegin()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">ConstStrBlobPtr StrBlob::cend()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::ifstream is(&quot;test.txt&quot;);</span><br><span class="line">    StrBlob sb;</span><br><span class="line">    string s;</span><br><span class="line">    while (getline(is, s)) &#123;</span><br><span class="line">        sb.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    for (StrBlobPtr sbp = sb.begin(); sbp != sb.end(); sbp.incr()) &#123;</span><br><span class="line">        cout &lt;&lt; sbp.deref() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写程序，逐行读入一个输入文件，将内容存入一个 StrBlob 中，用一个 StrBlobPtr 打印出 StrBlob 中的每个元素。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using std::vector; using std::string;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class StrBlobPtr;</span><br><span class="line">class ConstStrBlobStr;</span><br><span class="line"></span><br><span class="line">class StrBlob &#123;</span><br><span class="line">public:</span><br><span class="line">    friend class StrBlobPtr;</span><br><span class="line">    friend class ConstStrBlobPtr;</span><br><span class="line">    using size_type = vector&lt;string&gt;::size_type;</span><br><span class="line"></span><br><span class="line">    StrBlobPtr begin();</span><br><span class="line">    StrBlobPtr end();</span><br><span class="line">    ConstStrBlobPtr cbegin();</span><br><span class="line">    ConstStrBlobPtr cend();</span><br><span class="line">    StrBlob() :data(std::make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">    StrBlob(std::initializer_list&lt;string&gt; il) :data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">    bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const string&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">    void pop_back() &#123;</span><br><span class="line">        check(0, &quot;pop_back on empty StrBlob&quot;);</span><br><span class="line">        data-&gt;pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; front() &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string&amp; back() &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const std::string&amp; front() const &#123;</span><br><span class="line">        check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line">    const std::string&amp; back() const &#123;</span><br><span class="line">        check(0, &quot;back on empty StrBlob&quot;);</span><br><span class="line">        return data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void check(size_type i, const string&amp; msg) const &#123;</span><br><span class="line">        if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;vector&lt;string&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConstStrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    ConstStrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    ConstStrBlobPtr(const StrBlob&amp; a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    ConstStrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const ConstStrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    StrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz = 0) :</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string&amp; deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果check成功，p就是一个shared_ptr,指向StrBlobPtr所</span><br><span class="line">        // 指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector,</span><br><span class="line">        // 然后使用下标运算符提取并返回curr位置上的元素</span><br><span class="line">        auto p = check(curr, &quot;dereference past end&quot;);</span><br><span class="line">        return (*p)[curr]; // 返回一个vector[curr]</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; incr()</span><br><span class="line">    &#123;</span><br><span class="line">        check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">        ++curr;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">private:</span><br><span class="line">    // 若检查成功，chaek返回一个指向vector的shared_ptr</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">        check(std::size_t i, const std::string&amp; msg) const &#123;</span><br><span class="line">        auto ret = wptr.lock();</span><br><span class="line">        if (!ret) throw std::runtime_error(&quot;unbound StrBolbPtr&quot;);</span><br><span class="line">        if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存一个weak_ptr,意味着底层vector可能会被销毁</span><br><span class="line">    std::weak_ptr &lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">    // 在数组中的当前位置</span><br><span class="line">    std::size_t curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConstStrBlobPtr StrBlob::cbegin()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">ConstStrBlobPtr StrBlob::cend()</span><br><span class="line">&#123;</span><br><span class="line">    return ConstStrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs(&quot;books.txt&quot;);</span><br><span class="line">	StrBlob sb;</span><br><span class="line">	string s;</span><br><span class="line">	while (getline(ifs, s))</span><br><span class="line">	&#123;</span><br><span class="line">		sb.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	for (StrBlobPtr sbp = sb.begin(); sbp != sb.end(); sbp.incr())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; sbp.deref() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>智能指针最后练习</p>
</blockquote>
<h1>12.27：</h1>
<p><img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img21.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img22.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img23.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img24.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img25.PNG" alt><br>
<img src="/2022/07/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart_pointer_img26.PNG" alt></p>
<blockquote>
<p>代码：</p>
</blockquote>
<ol>
<li>头文件：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#ifndef EX12_27_H</span><br><span class="line">#define EX12_27_H</span><br><span class="line"></span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">class QueryResult;</span><br><span class="line"></span><br><span class="line">class TextQuery</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// 类型定义</span><br><span class="line">	using line_no = std::vector&lt;std::string&gt;::size_type;</span><br><span class="line">	// 构造函数</span><br><span class="line">	TextQuery(std::ifstream&amp;);</span><br><span class="line">	QueryResult query(const std::string&amp; s) const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	// 保存输入文件的一份拷贝，输入文件中的每行保存为vector中的一个元素。当需要打印一行时，</span><br><span class="line">	// 可以用行号作为下标来提取行文本</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</span><br><span class="line">	// 使用一个map来将每个单词与它出现的行号set关联起来，可以方便地提取任意单词的set</span><br><span class="line">	std::map&lt;std::string, std::shared_ptr&lt;std::set&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class QueryResult</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	friend std::ostream&amp; print(std::ostream&amp;, const QueryResult&amp;);</span><br><span class="line"></span><br><span class="line">	QueryResult(std::string s,</span><br><span class="line">		std::shared_ptr&lt;std::set&lt;TextQuery::line_no&gt;&gt; p,</span><br><span class="line">		std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; f) :</span><br><span class="line">		sought(s), lines(p), file(f)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	std::string sought;</span><br><span class="line">	// 使用set来保存每个单词在输入文本中出现的行号，保证每行只出现一次且行号按升序保存</span><br><span class="line">	std::shared_ptr&lt;std::set&lt;TextQuery::line_no&gt;&gt; lines;</span><br><span class="line">	// 保存输入文件的一份拷贝，输入文件中的每行保存为vector中的一个元素。当需要打印一行时，</span><br><span class="line">	// 可以用行号作为下标来提取行文本</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; print(std::ostream&amp;, const QueryResult&amp;);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>功能实现</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;ex12_27.h&quot;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">TextQuery::TextQuery(ifstream&amp; ifs) : file(new vector&lt;string&gt;)</span><br><span class="line">&#123;</span><br><span class="line">	string text;</span><br><span class="line">	// 获取一行</span><br><span class="line">	while (getline(ifs, text))</span><br><span class="line">	&#123;</span><br><span class="line">		// 输入文件中的每行保存为vector中的一个元素</span><br><span class="line">		file-&gt;push_back(text);</span><br><span class="line">		// 从0开始, file-&gt;size()从1开始</span><br><span class="line">		int n = file-&gt;size() - 1;</span><br><span class="line">		cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">		istringstream line(text);</span><br><span class="line">		string word;</span><br><span class="line">		while (line &gt;&gt; word)</span><br><span class="line">		&#123;</span><br><span class="line">			// 获取行号,wm[word] -&gt; size_t</span><br><span class="line">			auto&amp; lines = wm[word];</span><br><span class="line">			// cout &lt;&lt; &quot; [word] = &quot; &lt;&lt; word;</span><br><span class="line">			if (!lines)</span><br><span class="line">				lines.reset(new set&lt;line_no&gt;);</span><br><span class="line">			// cout &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">			lines-&gt;insert(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueryResult TextQuery::query(const string&amp; s) const</span><br><span class="line">&#123;</span><br><span class="line">	static shared_ptr&lt;set&lt;line_no&gt;&gt; nodata(new set&lt;line_no&gt;);</span><br><span class="line">	auto loc = wm.find(s);</span><br><span class="line">	// 如果找到返回行数</span><br><span class="line">	if (loc == wm.end())</span><br><span class="line">		return QueryResult(s, nodata, file);</span><br><span class="line">	else</span><br><span class="line">		return QueryResult(s, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印</span><br><span class="line">std::ostream&amp; print(std::ostream&amp; os, const QueryResult&amp; qr)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; qr.sought &lt;&lt; &quot; occurs &quot; &lt;&lt; qr.lines-&gt;size() &lt;&lt; &quot; &quot;</span><br><span class="line">		&lt;&lt; &quot;time&quot; &lt;&lt; (qr.lines-&gt;size() &gt; 1 ? &quot;s&quot; : &quot;&quot;) &lt;&lt; endl;</span><br><span class="line">	for (auto num : *qr.lines)</span><br><span class="line">		os &lt;&lt; &quot;\t(line &quot; &lt;&lt; num + 1 &lt;&lt; &quot;) &quot; &lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; endl;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>main函数实现</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &quot;ex12_27.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void runQueries(ifstream&amp; infile)</span><br><span class="line">&#123;</span><br><span class="line">	TextQuery tq(infile);</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;enter word to look for, or q to quit: &quot;;</span><br><span class="line">		string s;</span><br><span class="line">		if (!(cin &gt;&gt; s) || s == &quot;q&quot;) break;</span><br><span class="line">		print(cout, tq.query(s)) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs(&quot;test.txt&quot;);</span><br><span class="line">	runQueries(ifs);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>12.28</h1>
<blockquote>
<p>编写程序实现文本查询，不要定义类来管理数据。你的程序应该接受一个文件，并与用户交互来查询单词。使用vector、map 和 set 容器来保存来自文件的数据并生成查询结果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using std::string;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using std::shared_ptr;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::ifstream file(&quot;test.txt&quot;);</span><br><span class="line">	vector&lt;string&gt; input;</span><br><span class="line">	std::map&lt;string, std::set&lt;decltype(input.size())&gt;&gt; dictionary;</span><br><span class="line">	// size_t</span><br><span class="line">	decltype(input.size()) lineNo&#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">	for (string line; std::getline(file, line); ++lineNo)</span><br><span class="line">	&#123;</span><br><span class="line">		input.push_back(line);</span><br><span class="line">		std::istringstream line_stream(line);</span><br><span class="line">		for (string text, word; line_stream &gt;&gt; text; word.clear())</span><br><span class="line">		&#123;</span><br><span class="line">			// ispunct检查参数c是否为标点符号或特殊符号</span><br><span class="line">			// 将text不符合ispunct复制到word后</span><br><span class="line">			std::cout &lt;&lt; &quot;word-before : &quot; &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">			std::remove_copy_if(text.begin(), text.end(), std::back_inserter(word), ispunct);</span><br><span class="line">			std::cout &lt;&lt; &quot;word_after : &quot; &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">			dictionary[word].insert(lineNo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;enter word to look for, or q to quit: &quot;;</span><br><span class="line">		string s;</span><br><span class="line">		if (!(std::cin &gt;&gt; s) || s == &quot;q&quot;) break;</span><br><span class="line">		auto found = dictionary.find(s);</span><br><span class="line">		if (found != dictionary.end())</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; s &lt;&lt; &quot; occurs &quot; &lt;&lt; found-&gt;second.size() &lt;&lt; (found-&gt;second.size() &gt; 1 ? &quot; times&quot; : &quot; time&quot;) &lt;&lt; std::endl;</span><br><span class="line">			for (auto i : found-&gt;second)</span><br><span class="line">				std::cout &lt;&lt; &quot;\t(line &quot; &lt;&lt; i + 1 &lt;&lt; &quot;) &quot; &lt;&lt; input.at(i) &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else std::cout &lt;&lt; s &lt;&lt; &quot; occurs 0 time&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式复习</title>
    <url>/2022/08/22/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="设计模式复习">设计模式复习</h2>
<h3 id="1-备忘录模式">1. 备忘录模式</h3>
<blockquote>
<p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
</blockquote>
<h4 id="例题：-2">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.某系统提供了用户信息操作模块，用户可以修改自己的各项信息。为了使操作过程更加人性化，可以使用（）对系统进行改进，使得用户在进行了错误操作之后可以恢复到操作之前的状态。</span><br></pre></td></tr></table></figure>
<h3 id="2-适配器模式">2.适配器模式</h3>
<blockquote>
<p>适配器模式（Adapter）通常适用于以下场景。<br>
以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。<br>
使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p>
</blockquote>
<h4 id="例题：-3">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.当已有类能满足目前的需求但和当前的系统兼容性比较差的情况下，比较适合使用（ ）</span><br></pre></td></tr></table></figure>
<h3 id="3-模板方法模式">3.模板方法模式</h3>
<blockquote>
<p>基本流程几乎一样采用模板方法模式</p>
</blockquote>
<h4 id="例题：-4">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在银行办理业务时，一般都包含几个基本步骤，即取号排队、办理具体业务和对银行工作人员进行评分。无论具体业务是取款、存款还是转账，其基本流程都一样。可以使用（ ）模拟银行业务办理流程。</span><br></pre></td></tr></table></figure>
<h3 id="4-观察者模式">4. 观察者模式</h3>
<blockquote>
<p>观察者模式：定义对象之间的一种一对多的关系，当一个对象发生改变时，其他依赖于该对象的对象也会被通知自动改变。</p>
</blockquote>
<h4 id="例题：-5">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，应该使用何种设计模式：</span><br></pre></td></tr></table></figure>
<h3 id="5-命令模式">5.命令模式</h3>
<blockquote>
<p>命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志。</p>
</blockquote>
<h4 id="例题：-6">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在设计中如果一个对象请求另一个对象调用其方法到达某种目的，而不和请求的对象直接打交道，这种模式是（ ）。</span><br></pre></td></tr></table></figure>
<h3 id="6-原型模式">6.原型模式</h3>
<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>
原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节。<br>
工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。<br>
它主要面对的问题是：“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。</p>
</blockquote>
<h4 id="例题：-7">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.（）模式的关键是将一个对象定义为原型，并为其提供复制自己的方法。 </span><br><span class="line">2. 以下哪个模式可以利用一个对象，快速地生成一批对象？（）</span><br></pre></td></tr></table></figure>
<h3 id="7-责任链模式">7.责任链模式</h3>
<blockquote>
<p>责任链模式是一种设计模式。<br>
在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。<br>
请求在这个链上传递，直到链上的某一个对象决定处理此请求。<br>
发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>
</blockquote>
<h4 id="例题：-8">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.某OA系统需要提供一个假条审批的模块，如果员工请假天数小于3天，主任可以审批该假条；如果员工请假天数大于等于3天，小于10天，经理可以审批；如果员工请假天数大于等于10天，小于30天，总经理可以审批；如果超过30天，总经理也不能审批，提示相应的拒绝信息。如果假条审批使用模式来进行设计，可以使用（）模式。</span><br></pre></td></tr></table></figure>
<h3 id="8-装饰者模式">8.装饰者模式</h3>
<blockquote>
<p>23种设计模式之一，英文叫Decorator Pattern，又叫装饰者模式。装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
</blockquote>
<h4 id="例题：-9">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.系统中的文本显示类（TextView）和图片显示类（PictureView）都继承了组件类（Component），分别显示文本和图片内容，现需要构造带有滚动条、或者带有黑色边框、或者既有滚动条又有黑色边框的文本显示控件和图片显示控件，但希望最多只增加三个类，（）设计模式可以实现该目的。</span><br></pre></td></tr></table></figure>
<h3 id="9-享元模式">9.享元模式</h3>
<blockquote>
<p>通过共享以便有效的支持大量细颗粒对象。</p>
</blockquote>
<h4 id="例题：-10">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 共享网络设备模拟：很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发。共享网络设备可以使用（）模拟共享网络设备的设计原理。</span><br></pre></td></tr></table></figure>
<h3 id="10-外观模式">10.外观模式</h3>
<blockquote>
<p>为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<h3 id="11-代理模式">11.代理模式</h3>
<blockquote>
<p>为其他对象提供一个代理以控制对这个对象的访问。</p>
</blockquote>
<h3 id="12-工厂方法模式">12.工厂方法模式</h3>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类。(工厂方法模式：客户必须清楚地指出想获取哪种产品；由接口的子类负责获取产品 )</p>
</blockquote>
<h3 id="13-访问者模式">13.访问者模式</h3>
<blockquote>
<p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">某高校奖励审批系统可以实现教师奖励和学生奖励的审批(AwardCheck)，如果教师发表论文数超过10篇或者学生论文超过2篇可以评选科研奖，如果教师教学反馈分大于等于90分或者学生平均成绩大于等于90分可以评选成绩优秀奖。奖励审批系统可以使用（）设计该系统，以判断候选人集合中的教师或学生是否符合某种获奖要求。</span><br></pre></td></tr></table></figure>
<h3 id="14-单例模式">14.单例模式</h3>
<blockquote>
<p>单例对于不频繁创建和销毁的对象只会增加系统开支，因为它一直存在，但是对于频繁创建和销毁的却可以在一定程度上减少开支。</p>
</blockquote>
<h3 id="15-策略模式">15.策略模式</h3>
<blockquote>
<p>策略模式（Strategy）-定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<h3 id="16-建造者模式">16.建造者模式</h3>
<blockquote>
<p>建造者模式是设计模式的一种，又叫做生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<h4 id="例题：-11">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.KFC套餐一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。可以使用（)描述KFC如何创建套餐。</span><br></pre></td></tr></table></figure>
<h3 id="17-简单工厂模式">17.简单工厂模式</h3>
<blockquote>
<p>当客户获取产品时，工厂模式作为获取产品的接口。由接口直接负责获取产品</p>
</blockquote>
<h3 id="18-简单工厂模式">18.简单工厂模式</h3>
<blockquote>
<p>抽象工厂模式：客户不知道其想获取哪种产品；由接口中判断调用哪个子类，通过子类获取产品。</p>
</blockquote>
<h3 id="19-桥接模式">19.桥接模式</h3>
<blockquote>
<p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低 抽象和实现这两个可变维度的耦合度。</p>
</blockquote>
<h3 id="20-组合模式">20.组合模式</h3>
<blockquote>
<p>将对象组合成树形结构以表示部分和整体的层次结构</p>
</blockquote>
]]></content>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试</title>
    <url>/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1>2022-8-23</h1>
<h2 id="1-常见的HTTP协议状态码有哪些？">1. 常见的HTTP协议状态码有哪些？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标准回答</span><br><span class="line"></span><br><span class="line">常见的状态码有：</span><br><span class="line">    1xx代表服务器端已经接受了请求。</span><br><span class="line">    2xx代表请求已经被服务器端成功接收，最常见的有200、201状态码。</span><br><span class="line">    3xx代表路径被服务器端重定向到了一个新的URL，最常见的有301、302状态码。</span><br><span class="line">    4xx代表客户端的请求发生了错误，最常见的有401、404状态码。</span><br><span class="line">    5xx代表服务器端的响应出现了错误。 </span><br><span class="line"></span><br><span class="line">加分回答</span><br><span class="line"></span><br><span class="line">    1xx：指定客户端相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</span><br><span class="line"></span><br><span class="line">    2xx：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。</span><br><span class="line">        200（成功）：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</span><br><span class="line">        201（已创建）：请求成功并且服务器创建了新的资源。</span><br><span class="line">        202（已接受）：服务器已接受请求，但尚未处理。</span><br><span class="line">        203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源。</span><br><span class="line">        204（无内容）：服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line">        205（重置内容）：服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line">        206（部分内容）：服务器成功处理了部分 GET 请求。 </span><br><span class="line"></span><br><span class="line">    3xx：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在响应头Location字段中指明。这系列中最常见的有301、302状态码。</span><br><span class="line">        300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</span><br><span class="line">        301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class="line">        302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line">        303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class="line">        304（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line">        305（使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</span><br><span class="line">        307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 </span><br><span class="line"></span><br><span class="line">    4xx：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。</span><br><span class="line"></span><br><span class="line">        400（错误请求）：服务器不理解请求的语法。</span><br><span class="line"></span><br><span class="line">        401（未授权）：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</span><br><span class="line"></span><br><span class="line">        403（禁止）：服务器拒绝请求。</span><br><span class="line"></span><br><span class="line">        404（未找到）：服务器找不到请求的网页。</span><br><span class="line"></span><br><span class="line">        405（方法禁用）：禁用请求中指定的方法。</span><br><span class="line"></span><br><span class="line">        406（不接受）：无法使用请求的内容特性响应请求的网页。</span><br><span class="line"></span><br><span class="line">        407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class="line"></span><br><span class="line">        408（请求超时）：服务器等候请求时发生超时。</span><br><span class="line"></span><br><span class="line">        409（冲突）：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</span><br><span class="line"></span><br><span class="line">        410（已删除）：如果请求的资源已永久删除，服务器就会返回此响应。</span><br><span class="line"></span><br><span class="line">        411（需要有效长度）：服务器不接受不含有效内容长度标头字段的请求。</span><br><span class="line"></span><br><span class="line">        412（未满足前提条件）：服务器未满足请求者在请求中设置的其中一个前提条件。</span><br><span class="line"></span><br><span class="line">        413（请求实体过大）：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</span><br><span class="line"></span><br><span class="line">        414（请求的 URI 过长）：请求的 URI（通常为网址）过长，服务器无法处理。</span><br><span class="line"></span><br><span class="line">        415（不支持的媒体类型）：请求的格式不受请求页面的支持。</span><br><span class="line"></span><br><span class="line">        416（请求范围不符合要求）：如果页面无法提供请求的范围，则服务器会返回此状态代码。</span><br><span class="line"></span><br><span class="line">        417 （未满足期望值）：服务器未满足&quot;期望&quot;请求标头字段的要求。</span><br><span class="line"></span><br><span class="line">    5xx：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。</span><br><span class="line">        500（服务器内部错误）：服务器遇到错误，无法完成请求。</span><br><span class="line">        501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line">        502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line">        503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</span><br><span class="line">        504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line">        505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-简述一下C-中的四种类型转换">2.简述一下C++ 中的四种类型转换</h2>
<blockquote>
<p>const_cast 只能改变运算对象的底层const,只有const_cast能改变表达式的常量属性,将常量对象转换成非常量对象的行为，我们一般称其为&quot;去掉const性质。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对改对象进行读写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法行为。<br>
然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc); <span class="comment">// 正确：但是通过p写值是未定义的行为</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cp;</span><br><span class="line"><span class="comment">// 错误：static_cast不能转换调const性质</span></span><br><span class="line"><span class="type">char</span> *q = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);</span><br><span class="line"><span class="keyword">static_cast</span>&lt;string&gt;cp; <span class="comment">//正确：字符串字面值转换成string类型</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;string&gt;cp;  <span class="comment">// 错误：const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>static_cast: 任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) / i</span><br></pre></td></tr></table></figure>
<blockquote>
<p>reinterpret_cast：reinterpret_cast，是C++里强制类型转换符。</p>
</blockquote>
<blockquote>
<p>dynamic_cast是将一个基类对象指针（或引用）转换到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理。dynamic_cast运算符涉及到编译器的属性设置，而且牵扯到的面向对象的多态性跟程序运行时的状态也有关系，所以不能完全的使用传统的替换方式来代替。但是也因此它最常用，是最不可缺少的一个运算符。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base &amp;b;</span><br><span class="line"><span class="type">const</span> Derived &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br></pre></td></tr></table></figure>
<h2 id="3-简述C-的内存管理">3.简述C++ 的内存管理</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++的内存分区主要有五个区：分别是代码区、全局/静态存储区、常量存储区、堆区和栈区。</span><br><span class="line">代码区：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</span><br><span class="line">全局区/静态存储区（.bss【Block Started by Symbol】 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</span><br><span class="line">常量存储区：存放的是常量，不允许修改，程序运行结束自动释放。</span><br><span class="line">栈区：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</span><br><span class="line">堆区：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</span><br></pre></td></tr></table></figure>
<h2 id="两数之和">两数之和</h2>
<blockquote>
<p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。<br>
（注：返回的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 判断哈希表里面是否有tmp</span></span><br><span class="line">        <span class="type">int</span> tmp = target - numbers[i];</span><br><span class="line">        <span class="comment">// 如果没有</span></span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(tmp) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            hash[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(hash[tmp] + <span class="number">1</span>); <span class="comment">// 索引+1</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-为什么要实现多态">C++ 为什么要实现多态?</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。需要在基类函数前加virtual。</span><br></pre></td></tr></table></figure>
<h3 id="看代码：">看代码：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;调用Father类函数&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;调用Son类函数&quot;</span> &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son1;</span><br><span class="line"></span><br><span class="line">	Father* fp = &amp;son1;</span><br><span class="line">	fp-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上图代码函数没有加virtual，导致了fp-&gt;func()最后输出父类的func，而加了virual后，按照原则：不管谁指向/引用谁，都是自动识别调子类自己的函数(调用被重写过的函数）。</p>
</blockquote>
<h2 id="虚函数的作用？">虚函数的作用？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用基类的指针指向不同的派生类的对象时，</span><br><span class="line">基类指针调用其虚成员函数，则会调用其真正指向对象的成员函数，</span><br><span class="line">而不是基类中定义的成员函数（只要派生类改写了该成员函数）。</span><br><span class="line">若不是虚函数，则不管基类指针指向的哪个派生类对象，调用时都</span><br><span class="line">会调用基类中定义的那个函数。</span><br></pre></td></tr></table></figure>
<h2 id="C-重载怎么实现？">C++ 重载怎么实现？</h2>
<h2 id="C-重写和重载的区别？">C++ 重写和重载的区别？</h2>
<blockquote>
<p>函数重载是指在 同一作用域内，可以有一组具有 相同函数名，不同参数列表 的函数，这组函数被称为重载函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">(<span class="type">long</span> a)</span> </span>&#123; .. &#125; <span class="comment">// 重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">(<span class="type">char</span> a)</span> </span>&#123; .. &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">     <span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">()</span> </span>&#123; .. &#125; <span class="comment">// 重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的使用场景">二叉树的使用场景?</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数据压缩(哈夫曼树)</span><br><span class="line">2. STL的容器(map, set) (红黑树)</span><br></pre></td></tr></table></figure>
<h2 id="堆和栈的区别？">堆和栈的区别？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 栈是系统自动分配，堆是人为申请分配。</span><br><span class="line">2. 栈获得的空间较小，堆获得的空间大。</span><br><span class="line">3. 申请效率不同，栈由系统分配，速度较快。</span><br><span class="line">4. 栈是连续空间，堆是不连续空间。</span><br><span class="line">5. 存储内容不同，栈在函数调用时，函数调用的下一条可执行语句的地址第一个进栈,</span><br><span class="line">然后函数的参数进栈，静态变量不如栈。堆是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排的。</span><br></pre></td></tr></table></figure>
<h2 id="public-private-protected-继承">public/private/protected 继承</h2>
<blockquote>
<p>C++ Primer 15.5</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公有继承(public)、私有继承(private)、保护继承(protected)是常用的三种继承方式。　　</span><br><span class="line">1. 公有继承(public) 　　</span><br><span class="line">公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。　　</span><br><span class="line">2. 私有继承(private) 　默认的继承方式（如果缺省，默认为private继承)</span><br><span class="line">私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。　</span><br><span class="line">子类也不能转换成相应的基类，如果转换，会报错：“不允许对不可访问的基类进行转换”。</span><br><span class="line">3. 保护继承(protected) 　　</span><br><span class="line">保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。　　</span><br></pre></td></tr></table></figure>
<h2 id="C-优先队列中的less和greater">C++优先队列中的less和greater</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>
<h3 id="less源代码：">less源代码：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x&lt;y;&#125;</span><br><span class="line">  <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="less-example">less example</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// less example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// std::less</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::sort, std::includes</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> foo[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">25</span>&#125;;</span><br><span class="line">  <span class="type">int</span> bar[]=&#123;<span class="number">15</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">  std::<span class="built_in">sort</span> (foo, foo+<span class="number">5</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// 5 10 15 20 25</span></span><br><span class="line">  std::<span class="built_in">sort</span> (bar, bar+<span class="number">3</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//   10 15 20</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">includes</span> (foo, foo+<span class="number">5</span>, bar, bar+<span class="number">3</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()))</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo includes bar.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="greater源代码：">greater源代码：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">greater</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line">  <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="greater-example">greater example</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// greater example</span><br><span class="line">#include &lt;iostream&gt;     // std::cout</span><br><span class="line">#include &lt;functional&gt;   // std::greater</span><br><span class="line">#include &lt;algorithm&gt;    // std::sort</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">  int numbers[]=&#123;20,40,50,10,30&#125;;</span><br><span class="line">  std::sort (numbers, numbers+5, std::greater&lt;int&gt;());</span><br><span class="line">  for (int i=0; i&lt;5; i++)</span><br><span class="line">    std::cout &lt;&lt; numbers[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">  std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以知道less<type>()是从小到大排序，greater<type>()是从大到小排序</type></type></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在C++ STL的priority_queue中：</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt;que       -&gt;      从小到大排序</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;,less&lt;int&gt; &gt;que          -&gt;      从大到小排序</span><br></pre></td></tr></table></figure>
<h2 id="请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁-※">请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁 ※</h2>
<h3 id="死锁：">死锁：</h3>
<blockquote>
<p>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。</p>
</blockquote>
<h3 id="死锁产生的必要条件">死锁产生的必要条件</h3>
<blockquote>
<ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放；</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放；</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，···，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。</li>
</ul>
</blockquote>
<h3 id="死锁产生的原因">死锁产生的原因</h3>
<blockquote>
<p>竞争资源 - 进程间推进顺序非法</p>
</blockquote>
<h3 id="怎么预防死锁">怎么预防死锁</h3>
<blockquote>
<p>有序资源分配法 - 银行家算法</p>
</blockquote>
<h2 id="x-x-1-x-1-x-哪个效率高？">x = x + 1, x += 1, x++ 哪个效率高？</h2>
<blockquote>
<p>x = x + 1 执行效率如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 读取右x的地址</span><br><span class="line">2. x + 1</span><br><span class="line">3. 读取左x的地址</span><br><span class="line">4.将右表达式的值传递给左x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x += 1 执行效率如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 读取x的地址</span><br><span class="line">2. x + 1</span><br><span class="line">3. 将得到的值传给x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x++</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 读取x的地址</span><br><span class="line">2. 自增操作</span><br></pre></td></tr></table></figure>
<h2 id="const-和-define-的区别">const 和 #define 的区别</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. #define 只在预编译阶段起作用, const在编译、运行的时候起作用</span><br><span class="line">2. #define 只是简单的字符串替换，没有类型检查。而const有对应的数据类型，需要进行类型检查。</span><br><span class="line">3. #define 只是进行展开,有多少地方使用就替换多少次，它定义的宏常量在内存中有多个备份，const定义的只读变量在程序运行中只有一份备份。</span><br><span class="line">4. #define 是不能进行调试的在预编译阶段就替换了，const常量可以进行调试</span><br></pre></td></tr></table></figure>
<h2 id="new-和-malloc的区别和联系">new 和 malloc的区别和联系</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. new 是 C++中的操作符，malloc是c中的一个函数</span><br><span class="line">2. new不只是分配内存，还会调用类的构造函数，同理，delete会调用类的析构函数，malloc则只会分配内存，不会进行初始化类成员的工作，free也不会调用析构函数。</span><br><span class="line">3. new的指针是直接带着类型信息的，malloc返回的是void*</span><br><span class="line">4. new，delete || new [], delete[] || malloc, free配套使用</span><br></pre></td></tr></table></figure>
<h2 id="构造函数和析构函数可不可以为虚函数？为什么？">构造函数和析构函数可不可以为虚函数？为什么？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">析构函数可以是虚函数，构造函数不可以。因为构造函数有特殊的工作，它处在对象创建初期，先调用基类的构造函数，再按照继承顺序调用派生类的构造函数。</span><br><span class="line">而析构函数和构造函数恰恰相反，从最后的派生类开始，依次到向上到基类，析构函数确切知道它从哪个类派生而来。</span><br><span class="line"></span><br><span class="line">如果某个类不包含虚函数,一般是表示它将不作为一个基类来使用,当一个类不作为基类使用时，析构函数没必要声明为虚函数，以防虚函数表指针浪费空间。</span><br></pre></td></tr></table></figure>
<h2 id="strcpy-和-memcpy的区别">strcpy 和 memcpy的区别</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）复制的内容不同，strcpy只能用于字符串copy，memcpy可以复制任何类型的内容，用途更广。</span><br><span class="line">2）复制的方法不同，strcpy不需要指定长度，遇到&#x27;\0&#x27;才会结束，容易溢出。memcpy需要设置复制长度。</span><br><span class="line">3）用途不同。一般复制字符串才会使用strcpy，其他类型使用memcpy</span><br></pre></td></tr></table></figure>
<h2 id="如何限制一个类对象只在堆-栈）上分配空间？">如何限制一个类对象只在堆(栈）上分配空间？</h2>
<blockquote>
<p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
</blockquote>
<blockquote>
<p>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;</p>
</blockquote>
<blockquote>
<p>动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A();</p>
</blockquote>
<h3 id="1-类对象只建立在堆上">1.类对象只建立在堆上</h3>
<blockquote>
<p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
</blockquote>
<h4 id="解决方法1：">解决方法1：</h4>
<blockquote>
<p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="该方法存在的问题：">该方法存在的问题：</h4>
<blockquote>
<p>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。</p>
</blockquote>
<blockquote>
<p>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
</blockquote>
<h4 id="解决方法2：">解决方法2：</h4>
<blockquote>
<p>构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static A *create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-类对象只建立在栈上">2.类对象只建立在栈上</h3>
<blockquote>
<p>解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    void* operator new(size_t t)&#123;&#125;     // 注意函数的第一个参数和返回值都是固定的  </span><br><span class="line">    void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载delete  </span><br><span class="line">public:  </span><br><span class="line">    A()&#123;&#125;  </span><br><span class="line">    ~A()&#123;&#125;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重载类的new操作符，使重载后的new操作符的功能为空。这样就使外层程序无法在堆上分配对象，只可以在栈上分配。</p>
</blockquote>
<h2 id="C-程序编译过程">C++ 程序编译过程</h2>
<h3 id="1-编译预处理">1. 编译预处理</h3>
<blockquote>
<p>编译预处理：处理以 # 开头的指令；</p>
</blockquote>
<h3 id="2-编译、优化">2. 编译、优化</h3>
<blockquote>
<p>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；</p>
</blockquote>
<h3 id="3-汇编">3. 汇编</h3>
<blockquote>
<p>汇编：将汇编代码 .s 翻译成机器指令 .o 文件；</p>
</blockquote>
<h3 id="4-链接">4. 链接</h3>
<blockquote>
<p>链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
</blockquote>
<p><img src="/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/mock_interview_img1.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接分为两种：</span><br><span class="line"></span><br><span class="line">    静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</span><br><span class="line">    动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。</span><br><span class="line">    在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</span><br><span class="line"></span><br><span class="line">二者的优缺点：</span><br><span class="line"></span><br><span class="line">    静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可</span><br><span class="line">    执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</span><br><span class="line">    动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</span><br></pre></td></tr></table></figure>
<h2 id="栈和堆的区别">栈和堆的区别</h2>
<blockquote>
<p>申请方式：栈是系统自动分配，堆是程序员主动申请。</p>
</blockquote>
<blockquote>
<p>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</p>
</blockquote>
<blockquote>
<p>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</p>
</blockquote>
<blockquote>
<p>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</p>
</blockquote>
<blockquote>
<p>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</p>
</blockquote>
<h2 id="变量的区别">变量的区别</h2>
<blockquote>
<p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
</blockquote>
<h3 id="从作用域看：">从作用域看：</h3>
<blockquote>
<p>全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p>
</blockquote>
<blockquote>
<p>静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p>
</blockquote>
<blockquote>
<p>局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p>
</blockquote>
<blockquote>
<p>静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</p>
</blockquote>
<h3 id="从分配内存空间看：">从分配内存空间看：</h3>
<blockquote>
<p>静态存储区：全局变量，静态局部变量，静态全局变量。</p>
</blockquote>
<blockquote>
<p>栈：局部变量。</p>
</blockquote>
<h2 id="全局变量定义在头文件中有什么问题？">全局变量定义在头文件中有什么问题？</h2>
<blockquote>
<p>如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>
</blockquote>
<h3 id="解决方法：">解决方法：</h3>
<blockquote>
<p>1）在头文件起始位置使用预处理指令，也就是 #ifndef，可以防止同一个头文件在一个 cpp 的include 链中被重复 include。<br>
2）头文件不做变量或者函数的定义，只做声明，定义放在cpp文件。</p>
</blockquote>
]]></content>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>模板与泛型编程</title>
    <url>/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1>第十六章 模板和泛型编程</h1>
<ul>
<li>面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。
<ul>
<li>OOP能处理类型在程序运行之前都未知的情况；</li>
<li>泛型编程中，在编译时就可以获知类型。</li>
</ul>
</li>
</ul>
<h2 id="定义模板">定义模板</h2>
<ul>
<li><strong>模板</strong>：模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</li>
<li><strong>编写一个函数来比较两个值:</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string&amp; v1, <span class="type">const</span> string&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; v1, <span class="type">const</span> <span class="type">double</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两个函数基本相同，只有参数类型不同。</li>
<li><strong>可以修改为：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2) &#123;</span><br><span class="line">    if(v1 &lt; v2) return -1;</span><br><span class="line">    if(v2 &lt; v1) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>template后跟一个<code>模板参数列表(以逗号分隔的一个或多个模板参数的列表)</code>,例如：<code>template &lt;typename T1, typename T2&gt;</code></li>
<li>compare函数声明了<code>T类型参数</code>，T表示的实际类型则在编译时根据compare的使用情况确定。</li>
</ul>
<h2 id="实例化函数模板">实例化函数模板</h2>
<ul>
<li>模板类型参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// √，返回类型和参数类型一致</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ×，U之前必须加上class 或者 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// √，模板参数列表中，typename 和 class没有什么不同，typename更清楚的指出随后的是个类型名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">U</span>&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非类型模板参数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span><br><span class="line"><span class="comment">// 如果是（*p1) 就是数组指针，（&amp;p1)就是数组引用， &amp;p1[N] 引用数组， *p1[N]指针数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用compare(“h1”, “mom”)调用时，编译器使用字面常量大小代替N和M，用于实例化模板，编译器会在一个字符串后加个’\0’做为终结符。</li>
<li>即<code>int compare(const char (&amp;p1)[3]</code>, <code>const char (&amp;p2)[4]</code>。</li>
</ul>
<h2 id="inline-和-constexpr">inline 和 constexpr</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// √， inline 跟在模板参数列表后</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// ×，inline位置不正确</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="编写类型无关的代码">编写类型无关的代码</h2>
<ul>
<li>compare 说明了编写泛型代码的两个重要原则：
<ul>
<li>模板中的函数参数是const&amp;。</li>
<li>函数体的条件判断仅使用&lt;比较运算。</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数参数是const&amp;，保证函数可以用于不能拷贝的类型，如果compare用于处理大对象，可以使函数运行更快。<br>
只使用&lt;运算符，降低了compare对要处理的类型的要求。这些类型必须支持&lt;，但不必支持&gt;。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="comment">// 即使使用指针也正确的compare版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// C++ 提供的比较函数</span></span><br><span class="line">    <span class="comment">/// less&lt;type&gt;()    -&gt;   从小到大排序 &lt;</span></span><br><span class="line">    <span class="comment">/// grater&lt;type&gt;()  -&gt;   从大到小排序 &gt;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">less</span>&lt;T&gt;()(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">less</span>&lt;T&gt;()(v2, v1)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你认为接受一个数组实参的标准库函数begin和end是如何工作的？定义你自己版本的begin和end</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">Array* <span class="title">begin</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">Array* <span class="title">end</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr + N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写一个 constexpr 模版，返回给定数组的大小。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Array* <span class="title">begin</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板">类模板</h2>
<blockquote>
<p>typedef -&gt; 取别名，typename（class) -&gt; 类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="comment">// C++语言默认情况下，假定通过作用域运算符访问的名字不是类型，所以当我们要访问的是类型时候，必须显示的告诉编译器这是一个类型</span></span><br><span class="line">    <span class="comment">// typedef创建了存在类型的别名，而typename告诉编译器std::vector&lt;T&gt;::size_type是一个类型而不是一个成员。</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="comment">// initializer_list对象中的元素是const&amp;,元素的类型一致</span></span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line">    <span class="comment">// Blob中的元素数目</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">pop_back</span>();</span><br><span class="line">    T&amp; <span class="built_in">back</span>();</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string&amp; msg) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在main函数中定义：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Blob&lt;<span class="type">int</span>&gt; ia;</span><br><span class="line">    Blob&lt;<span class="type">int</span>&gt; ia2 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ia和ia2使用特定类型版本的Blob<int>, 编译器会实例化出一个与下方定义等价的类：</int></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;<span class="type">int</span>&gt;::size_type size_type;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="comment">// initializer_list对象中的元素是const&amp;,元素的类型一致</span></span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;<span class="type">int</span>&gt; il);</span><br><span class="line">    <span class="comment">// Blob中的元素数目</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> &amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="type">int</span>&amp; <span class="built_in">back</span>();</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[] (size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string&amp; msg) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每当编译器从Blob模板实例化出一个类，会重写Blob模板，将模板参数T的每个实例替换为给定的模板实例，这里是int。</p>
</blockquote>
<h2 id="在模板作用域中引用模板类型">在模板作用域中引用模板类型</h2>
<ul>
<li>std::shared_ptr&lt;std::vector<T>&gt; data; data使用了两个模板 shared_ptr 和 vector。</T></li>
<li>使用了Blob类型参数来声明data是一个shared_ptr的实例，shared_ptr指向一个保存类型为T的对象的vector实例。</li>
<li>当我们实例化一个特定类型的Blob，例如：Blob<string> -&gt; std::shared_ptr&lt;std::vector<string>&gt; data。</string></string></li>
</ul>
<h2 id="类模板的成员函数">类模板的成员函数</h2>
<ul>
<li>一般类的成员函数  return-type A :: member-name(parm-list)</li>
<li>对应的Blob 成员：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">return-type Blob :: member-name(parm-list)</span><br></pre></td></tr></table></figure>
<h2 id="类的实现-通过编译">类的实现(通过编译)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// constructors</span></span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of elements in the Blob</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span>      <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t)); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// element access</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span> [](size_type i) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">	<span class="comment">// throw msg if data[i] isn&#x27;t valid</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructors</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>() : <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) :</span><br><span class="line"><span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string &amp;msg) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Blob&lt;T&gt;::<span class="built_in">back</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span> [](size_type i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if i is too big, check function will throw, preventing access to a nonexistent element</span></span><br><span class="line">	<span class="built_in">check</span>(i, <span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span> [](size_type i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if i is too big, check function will throw, preventing access to a nonexistent element</span></span><br><span class="line">	<span class="built_in">check</span>(i, <span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Blob-Ptr类">Blob_Ptr类</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Blob.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> ==&lt;T&gt;</span><br><span class="line">	(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; &lt;T&gt;</span><br><span class="line">		(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, std::<span class="type">size_t</span> sz = <span class="number">0</span>) :</span><br><span class="line">		<span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (*p)[curr];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prefix</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// postfix</span></span><br><span class="line">	BlobPtr <span class="keyword">operator</span> ++(<span class="type">int</span>);</span><br><span class="line">	BlobPtr <span class="keyword">operator</span> --(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// returns  a shared_ptr to the vector if the check succeeds</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt;</span><br><span class="line">		<span class="built_in">check</span>(std::<span class="type">size_t</span>, <span class="type">const</span> std::string&amp;) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">	std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;</span><br><span class="line">	std::<span class="type">size_t</span> curr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefix ++</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if curr already points past the end of the container, can&#x27;t increment it</span></span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot;increment past end of StrBlob&quot;</span>);</span><br><span class="line">	++curr;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefix --</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> --()</span><br><span class="line">&#123;</span><br><span class="line">	--curr;</span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot;decrement past begin of BlobPtr&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// postfix ++</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> ++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postfix --</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> --(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BlobPtr&lt;T&gt; &amp;lhs, <span class="type">const</span> BlobPtr&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lhs.wptr.<span class="built_in">lock</span>() != rhs.wptr.<span class="built_in">lock</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ptrs to different Blobs!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lhs.i == rhs.i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> BlobPtr&lt;T&gt; &amp;lhs, <span class="type">const</span> BlobPtr&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lhs.wptr.<span class="built_in">lock</span>() != rhs.wptr.<span class="built_in">lock</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ptrs to different Blobs!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lhs.i &lt; rhs.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认模板实参">默认模板实参</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2, F f = <span class="built_in">F</span>()) &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(v1,v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(v2,v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制实例化">控制实例化</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>declaration是一个类或函数声明，将其中所有模板参数换成模板实参</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;; <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当编译器遇到extern模板声明时，不会在本文件中生成实例化代码。将一个实例化声明成extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义)。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
</blockquote>
<h2 id="remove-reference">remove_reference</h2>
<blockquote>
<p>我们可以使用remove_reference获取元素类型。remove_refrence&lt;decltype(*beg)&gt;::type</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_refrence&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用折叠">引用折叠</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img1.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img2.PNG" alt></p>
<ul>
<li>即 X&amp; &amp;（引用的引用）, X&amp; &amp;&amp; (引用的右值引用), X&amp;&amp; &amp;(右值引用的引用)都折叠成X&amp;（X的引用）</li>
<li>类型X&amp;&amp; &amp;&amp;（右值引用的右值引用）折叠成X&amp;&amp;(X的右值引用)</li>
</ul>
<h2 id="std-move">std::move</h2>
<ul>
<li>定义：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>move的函数参数T&amp;&amp;是一个指向模板类型参数的右值引用。通过引用折叠,此参数可以和任何类型的实参匹配。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s1(&quot;hi!&quot;), s2;</span><br><span class="line">// 传入string构造函数的右值结果，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型（&amp;）。</span><br><span class="line">// T -&gt; string</span><br><span class="line">// remove_reference用string实例化</span><br><span class="line">// remove_reference&lt;string&gt;::type -&gt; string</span><br><span class="line">// move 返回类型是string&amp;&amp;</span><br><span class="line">// move的函数参数t的类型为string&amp;&amp;</span><br><span class="line">// 即string&amp;&amp; move(string&amp;&amp; t)</span><br><span class="line">// static_cast&lt;string&amp;&amp;&gt;(t), 不需要转换。</span><br><span class="line">s2 = std::move(string(&quot;bye!&quot;)); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 传入一个左值,所以T是个引用</span><br><span class="line">// T -&gt; string&amp; </span><br><span class="line">// remove_reference用string&amp;实例化</span><br><span class="line">// remove_reference&lt;string&amp;&gt;::type -&gt; string</span><br><span class="line">// move 返回类型是string&amp;&amp;</span><br><span class="line">// move的函数参数t的类型为string&amp; &amp;&amp;,会折叠为string&amp;</span><br><span class="line">// 即string&amp;&amp; move(string&amp; t)</span><br><span class="line">//  static_cast&lt;string&amp;&amp;&gt;(t), t为string&amp;, cast将其转换为string&amp;&amp;</span><br><span class="line">s2 = std::move(s1);</span><br></pre></td></tr></table></figure>
<h2 id="转发">转发</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i); <span class="comment">// f改变了实参i</span></span><br><span class="line">    <span class="built_in">flip1</span>(f, j, <span class="number">42</span>); <span class="comment">// 通过flip1调用f不会改变实参j</span></span><br><span class="line">    cout &lt;&lt; j &lt;&lt; endl &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int,而非int&amp;。因此，flip1调用会实例化为<code>void flip1(void(*fcn)(int, int&amp;), int t1, int t2);</code><br>
j的值被copy到t1。f中的引用参数被绑定带t1,而非j,从而其改变不会影响j。</p>
</blockquote>
<ul>
<li>如果我们将函数参数定义成T1&amp;&amp; 和 T2&amp;&amp;, 通过引用折叠，就可以保存翻转实参的左值，右值属性。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>&amp;&amp; v1, <span class="type">int</span>&amp;&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i);</span><br><span class="line">    <span class="built_in">flip2</span>(f, j, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">flip2</span>(g, i, <span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img3.PNG" alt></p>
<h2 id="在调用中使用std-forward保持类型信息">在调用中使用std::forward保持类型信息</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(T &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传入右值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传入左值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp; &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也就是：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img4.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img5.PNG" alt></p>
<ul>
<li>最后实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>&amp;&amp; v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i);</span><br><span class="line">    <span class="built_in">flip</span>(f, j, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">flip</span>(g, i, <span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写重载模板">编写重载模板</h2>
<ul>
<li>多个可行模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; string*</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T* t) T -&gt; string</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(&amp;s) &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> string* sp = &amp;s;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; string*</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T* t) T -&gt; const string</span></span><br><span class="line">    <span class="comment">// 调用更特例化版本string debug_rep(T* t)</span></span><br><span class="line">    <span class="comment">// 因为string debug_rep(const T&amp; t)本质上可以用于任何类型，后者只能用于指针类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(sp) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非模板和模板重载</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(s) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在本例中，两个函数具有相同的参数列表，因此，显然两者提供同样好的匹配。但是，编译器会选择非模板版本。当存在多个同样好的函数模板时，编译器选择最特例化的版本，处于相同的原因，一个非模板函数比一个函数模板更好。</p>
</blockquote>
<h2 id="重载模板和类型转换">重载模板和类型转换</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果希望将字符指针按string处理,可以定义另外两个非模板重载版本</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">debug_rep</span>(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">debug_rep</span>(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; char[10]</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T *p) T -&gt; const char</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const string&amp; s) const char* 到 string 的转换</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变参数模板">可变参数模板</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;  ... rest)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl; <span class="comment">// 类型参数的数目</span></span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(rest) &lt;&lt; endl; <span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    string s = <span class="string">&quot;how now brown cow&quot;</span>;</span><br><span class="line">    <span class="built_in">foo</span>(i, s, <span class="number">42</span>, d);</span><br><span class="line">    <span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    <span class="built_in">foo</span>(d, s);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写可变参数函数模板">编写可变参数函数模板</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... rest)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>; <span class="comment">// 递归调用打印其他实参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, s = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">print</span>(cout, i, s, <span class="number">42</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包扩展">包扩展</h2>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img6.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img7.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img8.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img9.PNG" alt></p>
<h2 id="模板特例化">模板特例化</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个版本;可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 第二个版本；处理字符串字面常量</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有当传递给compare一个字符串字面常量或者一个数组时，编译器才会调用接受两个非类型模板参数的版本。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span>;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);        <span class="comment">// 调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);   <span class="comment">// 调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义函数模板特例化</li>
</ul>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img10.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img11.PNG" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++ primer</tag>
      </tags>
  </entry>
  <entry>
    <title>水晶头连线</title>
    <url>/2022/07/10/%E6%B0%B4%E6%99%B6%E5%A4%B4%E8%BF%9E%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="颜色：">颜色：</h3>
<blockquote>
<p>白橙 橙 白绿 蓝 白蓝 绿 白棕 棕</p>
</blockquote>
<h3 id="图片：">图片：</h3>
<p><img src="/2022/07/10/%E6%B0%B4%E6%99%B6%E5%A4%B4%E8%BF%9E%E7%BA%BF/conn_img1.PNG" alt></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>流迭代器</title>
    <url>/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>C++ primer 第十章 泛型算法</p>
</blockquote>
<p><img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img1.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img2.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img3.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img4.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img5.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img6.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img7.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img8.PNG" alt><br>
<img src="/2022/07/16/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8/iostream_iterator_img9.PNG" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法</title>
    <url>/2022/07/14/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="一写文章就开始啰嗦…">一写文章就开始啰嗦…</h4>
<blockquote>
<p>感知机</p>
</blockquote>
<p>1.1 感知机详解链接：<a href="https://www.pkudodo.com/2018/11/18/1-4/">https://www.pkudodo.com/2018/11/18/1-4/</a></p>
<p>1.2 MNIST训练集下载：</p>
<pre><code>1.2.1 进入如下网址下载：
    https://github.com/Dod-o/Statistical-Learning-Method_Code
1.2.2 点击Mnist 解压即可
</code></pre>
<p>1.3 将csv放入文件夹<br>
1.4 贴代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def loadData(fileName):</span><br><span class="line">    </span><br><span class="line"># 加载Mnist数据集</span><br><span class="line"># :param fileName:要加载的数据集路径</span><br><span class="line"># :return: list形式的数据集及标记</span><br><span class="line"> </span><br><span class="line">print(&#x27;start to read data&#x27;)</span><br><span class="line"># 存放数据及标记的list</span><br><span class="line">dataArr = []; labelArr = []</span><br><span class="line"># 打开文件</span><br><span class="line">fr = open(fileName, &#x27;r&#x27;)</span><br><span class="line"># 将文件按行读取</span><br><span class="line">for line in fr.readlines():</span><br><span class="line">    # 对每一行数据按切割福&#x27;,&#x27;进行切割，返回字段列表</span><br><span class="line">    curLine = line.strip().split(&#x27;,&#x27;)</span><br><span class="line">    # 最左边的是标签</span><br><span class="line">    # Mnsit有0-9是个标记，由于是二分类任务，所以将&gt;=5的作为1，&lt;5为-1</span><br><span class="line">    if int(curLine[0]) &gt;= 5:</span><br><span class="line">        labelArr.append(1)</span><br><span class="line">    else:</span><br><span class="line">        labelArr.append(-1)</span><br><span class="line">    #存放标记</span><br><span class="line">    #[int(num) for num in curLine[1:]] -&gt; 遍历每一行中除了以第一个元素（标记）外将所有元素转换成int类型</span><br><span class="line">    #[int(num)/255 for num in curLine[1:]] -&gt; 将所有数据除255归一化(非必须步骤，可以不归一化)</span><br><span class="line">    dataArr.append([int(num)/255 for num in curLine[1:]])</span><br><span class="line"></span><br><span class="line">#返回data和label</span><br><span class="line">return dataArr, labelArr</span><br><span class="line"></span><br><span class="line">def perceptron(dataArr, labelArr, iter=50):</span><br><span class="line">    </span><br><span class="line">    # 感知器训练过程</span><br><span class="line">    # :param dataArr:训练集的数据 (list)</span><br><span class="line">    # :param labelArr: 训练集的标签(list)</span><br><span class="line">    # :param iter: 迭代次数，默认50</span><br><span class="line">    # :return: 训练好的w和b</span><br><span class="line"></span><br><span class="line">    print(&#x27;start to trans&#x27;)</span><br><span class="line">    #将数据转换成矩阵形式（在机器学习中因为通常都是向量的运算，转换称矩阵形式方便运算）</span><br><span class="line">    #转换后的数据中每一个样本的向量都是横向的</span><br><span class="line">    dataMat = np.mat(dataArr)</span><br><span class="line">    #将标签转换成矩阵，之后转置(.T为转置)。</span><br><span class="line">    #转置是因为在运算中需要单独取label中的某一个元素，如果是1xN的矩阵的话，无法用label[i]的方式读取</span><br><span class="line">    #对于只有1xN的label可以不转换成矩阵，直接label[i]即可，这里转换是为了格式上的统一</span><br><span class="line">    labelMat = np.mat(labelArr).T</span><br><span class="line">    #获取数据矩阵的大小，为m*n</span><br><span class="line">    m, n = np.shape(dataMat) # 60000 * 784</span><br><span class="line">    print(&#x27;------------&#x27;,m, n,&#x27;-------------------&#x27;)</span><br><span class="line">    #创建初始权重w，初始值全为0。</span><br><span class="line">    #np.shape(dataMat)的返回值为m，n -&gt; np.shape(dataMat)[1])的值即为n，与</span><br><span class="line">    #样本长度保持一致</span><br><span class="line">    # 1 * n</span><br><span class="line">    w = np.zeros((1, np.shape(dataMat)[1]))</span><br><span class="line">    #初始化偏置b为0</span><br><span class="line">    b = 0</span><br><span class="line">    #初始化步长，也就是梯度下降过程中的n，控制梯度下降速率</span><br><span class="line">    h = 0.0001</span><br><span class="line"></span><br><span class="line">    #进行iter次迭代计算</span><br><span class="line">    for k in range(iter):</span><br><span class="line">        #对于每一个样本进行梯度下降</span><br><span class="line">        #李航书中在2.3.1开头部分使用的梯度下降，是全部样本都算一遍以后，统一</span><br><span class="line">        #进行一次梯度下降</span><br><span class="line">        #在2.3.1的后半部分可以看到（例如公式2.6 2.7），求和符号没有了，此时用</span><br><span class="line">        #的是随机梯度下降，即计算一个样本就针对该样本进行一次梯度下降。</span><br><span class="line">        #两者的差异各有千秋，但较为常用的是随机梯度下降。</span><br><span class="line">        for i in range(m):</span><br><span class="line">            #获取当前样本的向量</span><br><span class="line">            xi = dataMat[i]</span><br><span class="line">            #获取当前样本所对应的标签</span><br><span class="line">            yi = labelMat[i]</span><br><span class="line">            #判断是否是误分类样本</span><br><span class="line">            #误分类样本特征为： -yi(w*xi+b)&gt;=0，详细可参考书中2.2.2小节</span><br><span class="line">            #在书的公式中写的是&gt;0，实际上如果=0，说明改点在超平面上，也是不正确的</span><br><span class="line">            if -1 * yi * (w * xi.T + b) &gt;= 0:</span><br><span class="line">                #对于误分类样本，进行梯度下降，更新w和b</span><br><span class="line">                #按公式进行更新</span><br><span class="line">                w = w + h *  yi * xi</span><br><span class="line">                b = b + h * yi</span><br><span class="line">        #打印训练进度</span><br><span class="line">        print(&#x27;Round %d:%d training&#x27; % (k, iter))</span><br><span class="line"></span><br><span class="line">    #返回训练完的w、b</span><br><span class="line">    return w, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test(dataArr, labelArr, w, b):</span><br><span class="line">   </span><br><span class="line">    # 测试准确率</span><br><span class="line">    # :param dataArr:测试集</span><br><span class="line">    # :param labelArr: 测试集标签</span><br><span class="line">    # :param w: 训练获得的权重w</span><br><span class="line">    # :param b: 训练获得的偏置b</span><br><span class="line">    # :return: 正确率</span><br><span class="line">    </span><br><span class="line">    print(&#x27;start to test&#x27;)</span><br><span class="line">    #将数据集转换为矩阵形式方便运算</span><br><span class="line">    dataMat = np.mat(dataArr)</span><br><span class="line">    #将label转换为矩阵并转置，详细信息参考上文perceptron中</span><br><span class="line">    #对于这部分的解说</span><br><span class="line">    labelMat = np.mat(labelArr).T</span><br><span class="line"></span><br><span class="line">    #获取测试数据集矩阵的大小</span><br><span class="line">    m, n = np.shape(dataMat)</span><br><span class="line">    #错误样本数计数</span><br><span class="line">    errorCnt = 0</span><br><span class="line">    #遍历所有测试样本</span><br><span class="line">    for i in range(m):</span><br><span class="line">        #获得单个样本向量</span><br><span class="line">        xi = dataMat[i]</span><br><span class="line">        #获得该样本标记</span><br><span class="line">        yi = labelMat[i]</span><br><span class="line">        #获得运算结果</span><br><span class="line">        result = -1 * yi * (w * xi.T + b)</span><br><span class="line">        #如果-yi(w*xi+b)&gt;=0，说明该样本被误分类，错误样本数加一</span><br><span class="line">        if result &gt;= 0:</span><br><span class="line">            errorCnt += 1</span><br><span class="line">    #正确率 = 1 - （样本分类错误数 / 样本总数）</span><br><span class="line">    accruRate = 1 - (errorCnt / m)</span><br><span class="line">    #返回正确率</span><br><span class="line">    return accruRate</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    #获取当前时间</span><br><span class="line">    #在文末同样获取当前时间，两时间差即为程序运行时间</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    #获取训练集及标签</span><br><span class="line">    trainData, trainLabel = loadData(&#x27;./mnist_train/mnist_train.csv&#x27;)</span><br><span class="line">    #print(&#x27;train_Data :&#123;0&#125;, train_Label : &#123;1&#125;&#x27;, trainData, trainLabel)</span><br><span class="line"></span><br><span class="line">    #获取测试集及标签</span><br><span class="line">    testData, testLabel = loadData(&#x27;./mnist_test/mnist_test.csv&#x27;)</span><br><span class="line"></span><br><span class="line">    #训练获得权重</span><br><span class="line">    w, b = perceptron(trainData, trainLabel, iter = 30)</span><br><span class="line">    #进行测试，获得正确率</span><br><span class="line">    accruRate = test(testData, testLabel, w, b)</span><br><span class="line"></span><br><span class="line">    #获取当前时间，作为结束时间</span><br><span class="line">    end = time.time()</span><br><span class="line">    #显示正确率</span><br><span class="line">    print(&#x27;accuracy rate is:&#x27;, accruRate)</span><br><span class="line">    #显示用时时长</span><br><span class="line">    print(&#x27;time span:&#x27;, end - start)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<blockquote>
<p>K近邻</p>
</blockquote>
<p>1.1 K近邻详解：<a href="https://www.pkudodo.com/2018/11/19/1-2/">https://www.pkudodo.com/2018/11/19/1-2/</a></p>
<p>1.2 MNIST训练集下载：</p>
<pre><code>1.2.1 进入如下网址下载：
    https://github.com/Dod-o/Statistical-Learning-Method_Code
1.2.2 点击Mnist 解压即可
</code></pre>
<p>1.3 将csv放入文件夹<br>
1.4 贴代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line"># Author:Dodo</span><br><span class="line"># Date:2018-11-16</span><br><span class="line"># Email:lvtengchao@pku.edu.cn</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">数据集：Mnist</span><br><span class="line">训练集数量：60000</span><br><span class="line">测试集数量：10000（实际使用：200）</span><br><span class="line">------------------------------</span><br><span class="line">运行结果：（邻近k数量：25）</span><br><span class="line">向量距离使用算法——欧式距离</span><br><span class="line">    正确率：97%</span><br><span class="line">    运行时长：308s</span><br><span class="line">向量距离使用算法——曼哈顿距离</span><br><span class="line">    正确率：14%</span><br><span class="line">    运行时长：246s</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import numpy as np</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loadData(fileName):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    加载文件</span><br><span class="line">    :param fileName:要加载的文件路径</span><br><span class="line">    :return: 数据集和标签集</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;start read file&#x27;)</span><br><span class="line">    # 存放数据及标记</span><br><span class="line">    dataArr = [];</span><br><span class="line">    labelArr = []</span><br><span class="line">    # 读取文件</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    # 遍历文件中的每一行</span><br><span class="line">    for line in fr.readlines():</span><br><span class="line">        # 获取当前行，并按“，”切割成字段放入列表中</span><br><span class="line">        # strip：去掉每行字符串首尾指定的字符（默认空格或换行符）</span><br><span class="line">        # split：按照指定的字符将字符串切割成每个字段，返回列表形式</span><br><span class="line">        curLine = line.strip().split(&#x27;,&#x27;)</span><br><span class="line">        # 将每行中除标记外的数据放入数据集中（curLine[0]为标记信息）</span><br><span class="line">        # 在放入的同时将原先字符串形式的数据转换为整型</span><br><span class="line">        dataArr.append([int(num) for num in curLine[1:]])</span><br><span class="line">        # 将标记信息放入标记集中</span><br><span class="line">        # 放入的同时将标记转换为整型</span><br><span class="line">        labelArr.append(int(curLine[0]))</span><br><span class="line">    # 返回数据集和标记</span><br><span class="line">    return dataArr, labelArr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def calcDist(x1, x2):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    计算两个样本点向量之间的距离</span><br><span class="line">    使用的是欧氏距离，即 样本点每个元素相减的平方  再求和  再开方</span><br><span class="line">    欧式举例公式这里不方便写，可以百度或谷歌欧式距离（也称欧几里得距离）</span><br><span class="line">    :param x1:向量1</span><br><span class="line">    :param x2:向量2</span><br><span class="line">    :return:向量之间的欧式距离</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    return np.sqrt(np.sum(np.square(x1 - x2)))</span><br><span class="line">    # 马哈顿距离计算公式</span><br><span class="line">    # return np.sum(x1 - x2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getClosest(trainDataMat, trainLabelMat, x, topK):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    预测样本x的标记。</span><br><span class="line">    获取方式通过找到与样本x最近的topK个点，并查看它们的标签。</span><br><span class="line">    查找里面占某类标签最多的那类标签</span><br><span class="line">    （书中3.1 3.2节）</span><br><span class="line">    :param trainDataMat:训练集数据集</span><br><span class="line">    :param trainLabelMat:训练集标签集</span><br><span class="line">    :param x:要预测的样本x</span><br><span class="line">    :param topK:选择参考最邻近样本的数目（样本数目的选择关系到正确率，详看3.2.3 K值的选择）</span><br><span class="line">    :return:预测的标记</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 建立一个存放向量x与每个训练集中样本距离的列表</span><br><span class="line">    # 列表的长度为训练集的长度，distList[i]表示x与训练集中第</span><br><span class="line">    ## i个样本的距离</span><br><span class="line">    distList = [0] * len(trainLabelMat)</span><br><span class="line">    # 遍历训练集中所有的样本点，计算与x的距离</span><br><span class="line">    for i in range(len(trainDataMat)):</span><br><span class="line">        # 获取训练集中当前样本的向量</span><br><span class="line">        x1 = trainDataMat[i]</span><br><span class="line">        # 计算向量x与训练集样本x的距离</span><br><span class="line">        curDist = calcDist(x1, x)</span><br><span class="line">        # 将距离放入对应的列表位置中</span><br><span class="line">        distList[i] = curDist</span><br><span class="line">    # 对距离列表进行排序</span><br><span class="line">    # argsort：函数将数组的值从小到大排序后，并按照其相对应的索引值输出</span><br><span class="line">    # 例如：</span><br><span class="line">    #   &gt;&gt;&gt; x = np.array([3, 1, 2])</span><br><span class="line">    #   &gt;&gt;&gt; np.argsort(x)</span><br><span class="line">    #   array([1, 2, 0])</span><br><span class="line">    # 返回的是列表中从小到大的元素索引值，对于我们这种需要查找最小距离的情况来说很合适</span><br><span class="line">    # array返回的是整个索引值列表，我们通过[:topK]取列表中前topL个放入list中。</span><br><span class="line">    # ----------------优化点-------------------</span><br><span class="line">    # 由于我们只取topK小的元素索引值，所以其实不需要对整个列表进行排序，而argsort是对整个</span><br><span class="line">    # 列表进行排序的，存在时间上的浪费。字典有现成的方法可以只排序top大或top小，可以自行查阅</span><br><span class="line">    # 对代码进行稍稍修改即可</span><br><span class="line">    # 这里没有对其进行优化主要原因是KNN的时间耗费大头在计算向量与向量之间的距离上，由于向量高维</span><br><span class="line">    # 所以计算时间需要很长，所以如果要提升时间，在这里优化的意义不大。</span><br><span class="line">    # 这边这么写是因为一维的数组，画张图就能理解</span><br><span class="line">    topKList = np.argsort(np.array(distList))[:topK]  # 升序排序</span><br><span class="line">    # 建立一个长度时的列表，用于选择数量最多的标记</span><br><span class="line">    # 3.2.4提到了分类决策使用的是投票表决，topK个标记每人有一票，在数组中每个标记代表的位置中投入</span><br><span class="line">    # 自己对应的地方，随后进行唱票选择最高票的标记</span><br><span class="line">    # 这里是分配10个空间，初始值为0</span><br><span class="line">    labelList = [0] * 10</span><br><span class="line">    # 对topK个索引进行遍历</span><br><span class="line">    for index in topKList:</span><br><span class="line">        # trainLabelMat[index]：在训练集标签中寻找topK元素索引对应的标记</span><br><span class="line">        # int(trainLabelMat[index])：将标记转换为int（实际上已经是int了，但是不int的话，报错）</span><br><span class="line">        # labelList[int(trainLabelMat[index])]：找到标记在labelList中对应的位置</span><br><span class="line">        # 最后加1，表示投了一票</span><br><span class="line">        labelList[int(trainLabelMat[index])] += 1</span><br><span class="line">    # max(labelList)：找到选票箱中票数最多的票数值</span><br><span class="line">    # labelList.index(max(labelList))：再根据最大值在列表中找到该值对应的索引，等同于预测的标记</span><br><span class="line">    return labelList.index(max(labelList))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test(trainDataArr, trainLabelArr, testDataArr, testLabelArr, topK):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    测试正确率</span><br><span class="line">    :param trainDataArr:训练集数据集</span><br><span class="line">    :param trainLabelArr: 训练集标记</span><br><span class="line">    :param testDataArr: 测试集数据集</span><br><span class="line">    :param testLabelArr: 测试集标记</span><br><span class="line">    :param topK: 选择多少个邻近点参考</span><br><span class="line">    :return: 正确率</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;start test&#x27;)</span><br><span class="line">    # 将所有列表转换为矩阵形式，方便运算</span><br><span class="line">    trainDataMat = np.mat(trainDataArr);</span><br><span class="line">    trainLabelMat = np.mat(trainLabelArr).T</span><br><span class="line">    testDataMat = np.mat(testDataArr);</span><br><span class="line">    testLabelMat = np.mat(testLabelArr).T</span><br><span class="line">    # 错误值技术</span><br><span class="line">    errorCnt = 0</span><br><span class="line">    # 遍历测试集，对每个测试集样本进行测试</span><br><span class="line">    # 由于计算向量与向量之间的时间耗费太大，测试集有6000个样本，所以这里人为改成了</span><br><span class="line">    # 测试200个样本点，如果要全跑，将行注释取消，再下一行for注释即可，同时下面的print</span><br><span class="line">    # 和return也要相应的更换注释行</span><br><span class="line">    # for i in range(len(testDataMat)):</span><br><span class="line">    for i in range(200):</span><br><span class="line">        # print(&#x27;test %d:%d&#x27;%(i, len(trainDataArr)))</span><br><span class="line">        print(&#x27;test %d:%d&#x27; % (i, 200))</span><br><span class="line">        # 读取测试集当前测试样本的向量</span><br><span class="line">        x = testDataMat[i]</span><br><span class="line">        # 获取预测的标记</span><br><span class="line">        y = getClosest(trainDataMat, trainLabelMat, x, topK)</span><br><span class="line">        # 如果预测标记与实际标记不符，错误值计数加1</span><br><span class="line">        if y != testLabelMat[i]: errorCnt += 1</span><br><span class="line">    # 返回正确率</span><br><span class="line">    # return 1 - (errorCnt / len(testDataMat))</span><br><span class="line">    return 1 - (errorCnt / 200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start = time.time()</span><br><span class="line">    # 获取训练集</span><br><span class="line">    trainDataArr, trainLabelArr = loadData(&#x27;./mnist_train/mnist_train.csv&#x27;)</span><br><span class="line">    # 获取测试集</span><br><span class="line">    testDataArr, testLabelArr = loadData(&#x27;./mnist_test/mnist_test.csv&#x27;)</span><br><span class="line">    # 计算测试集正确率</span><br><span class="line">    accur = test(trainDataArr, trainLabelArr, testDataArr, testLabelArr, 25)</span><br><span class="line">    # 打印正确率</span><br><span class="line">    print(&#x27;accur is:%d&#x27; % (accur * 100), &#x27;%&#x27;)</span><br><span class="line">    end = time.time()</span><br><span class="line">    # 显示花费时间</span><br><span class="line">print(&#x27;time span:&#x27;, end - start)</span><br></pre></td></tr></table></figure>
<p>KD树：</p>
<blockquote>
<p>还未实现，只找了外链</p>
</blockquote>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=853980597&bvid=BV1EL4y1F7sz&cid=717808316&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</div>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数复习</title>
    <url>/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1>C++ primer 第15章 面向对象程序设计</h1>
<h1>虚函数</h1>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img1.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img2.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img3.PNG" alt></p>
<h2 id="final-和-override">final 和 override</h2>
<blockquote>
<p>final 不允许后续的其他类覆盖<br>
override 帮助编译器说明派生类中的虚函数</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img4.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img5.PNG" alt></p>
<h2 id="抽象基类-含有纯虚函数）">抽象基类(含有纯虚函数）</h2>
<blockquote>
<p>有纯虚函数的类才称之为抽象类</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img6.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img7.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img8.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img9.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img10.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img11.PNG" alt></p>
<h2 id="虚析构函数">虚析构函数</h2>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img12.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img13.PNG" alt></p>
<h2 id="重载和隐藏">重载和隐藏</h2>
<blockquote>
<p>同一作用域，那就是重载。不同作用域，那就是隐藏。</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img14.PNG" alt></p>
<h1>虚继承</h1>
<h2 id="前置：">前置：</h2>
<blockquote>
<p>IO标准库的istream 和 ostream分别继承了base_ios的抽象基类。改抽象基类负责保存流的缓冲内容并管理流的条件状态。iostream是另外一个类，<br>
它从istream和ostream直接继承而来，可以同时读写流的内容。因为istream和ostream都继承自base_ios，所以iostream继承了base_ios两次，一次是通过<br>
istream，另一次通过ostream。<br>
在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了很多次，则派生类中将包含该类的多个子对象。<br>
这种默认的情况对某些形如iostream的类显然是行不通的。一个iostream对象肯定希望在同一个缓冲区中进行读写操作，也会要求条件状态能同时反映输入和输出操作的情况。<br>
加入在iostream对象中真的包含了base_ios的两份拷贝，则上述的共享行为就无法实现。</p>
</blockquote>
<h2 id="实现：">实现：</h2>
<h3 id="如图：-3">如图：</h3>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img15.PNG" alt></p>
<blockquote>
<p>对于Panda进行修改，使其同时继承Raccoon科和Bear科，此时，为了避免赋予Panda两份ZooAnimal的子对象，我们将Bear和Raccoon继承ZooAnimal的方式定义为虚继承。</p>
</blockquote>
<h3 id="使用虚基类：">使用虚基类：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码我们将ZooAnimal定义为Raccoon和Bear的虚基类。<br>
virtual说明符表面了一种愿望，即在后续派生类中共享虚基类的同一份实例。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span> : <span class="keyword">public</span> Bear,</span><br><span class="line">			  <span class="keyword">public</span> Raccoon, <span class="keyword">public</span> Endangered&#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Panda通过Raccoon和Bear继承了ZooAnimal,因为Raccoon和Bear继承ZooAnimal的方式都是虚继承，所以Panda中只有一个ZooAnimal基类部分。</p>
</blockquote>
<h3 id="构造函数和虚继承">构造函数和虚继承</h3>
<blockquote>
<p>在虚派生中，虚基类是由最底层的派生类初始化的。<br>
只要我们能创建虚基类的派生类对象(Bear/Raccoon),该派生类的构造函数就必须初始化它的虚基类。当创建一个Bear/Raccoon对象时，它已经位于派生的最底层，因此<br>
Bear/Raccoon的构造函数将直接初始化其ZooAnimal基类部分</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bear::<span class="built_in">Bear</span>(std::string name, <span class="type">bool</span> onExhibit):</span><br><span class="line">	<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Bear&quot;</span>) &#123; &#125;</span><br><span class="line">Raccoon::<span class="built_in">Raccoon</span>(std::string name, <span class="type">bool</span> onExhibit):</span><br><span class="line">	<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Raccoon&quot;</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而当创建一个Panda对象时，Panda位于派生类的最底层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Panda::<span class="built_in">Panda</span>(std::string name, <span class="type">bool</span> onExhibit)</span><br><span class="line">	:<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Panda&quot;</span>),</span><br><span class="line">	<span class="built_in">Bear</span>(name, onExhibit),</span><br><span class="line">	<span class="built_in">Raccoon</span>(name, onExhibit),</span><br><span class="line">	<span class="built_in">Endangered</span>(Endangered::critical),</span><br><span class="line">	<span class="built_in">sleeping_flag</span>(<span class="literal">false</span>) &#123; .. &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。</span><br><span class="line">2. 接下来构造Bear部分</span><br><span class="line">3. 构造Raccoon部分</span><br><span class="line">4. 构造第三直接基类Endangered</span><br><span class="line">5. 最后构造Panda部分</span><br><span class="line"></span><br><span class="line">如果Panda没有显示地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>访问控制与继承</title>
    <url>/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1>C++ primer 第15章 面向对象程序设计</h1>
<h2 id="访问控制和继承">访问控制和继承</h2>
<p><img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img1.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img2.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img3.PNG" alt></p>
<blockquote>
<p>基类对象不能访问基类的peotected,private成员<br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_qx.jpg" alt></p>
</blockquote>
<p><img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img4.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img5.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img6.PNG" alt></p>
<blockquote>
<p>只有public继承的时候才能使用派生类向基类的转换</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经整理</title>
    <url>/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1>卡方科技</h1>
<h2 id="1-delete-与-delete-的区别？">1. delete 与 delete[]的区别？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete 释放new分配的单个对象指针指向的内存，只调用一次析构函数。</span><br><span class="line">delete[] 释放new分配的对象数组指针指向的内存,并且逐一调用每个对象的析构函数。</span><br></pre></td></tr></table></figure>
<h2 id="2-多态，虚函数，纯虚函数的作用？">2.多态，虚函数，纯虚函数的作用？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚函数的作用：基类指针既可以使用基类的成员函数，也可以使用派生类的成员函数。</span><br><span class="line">纯虚函数的作用：通过它可以指明一个虚函数只是提供了一个可被子类型改写的接口。抽象类是类里面定义了有纯虚函数的类。</span><br><span class="line">多态的作用：使用多态能够增强程序的可扩充性，即程序需要修改或增加功能时，只需改动或增加较少的代码。此外，使用多态也能起到精简代码的作用。</span><br></pre></td></tr></table></figure>
<h2 id="struct-和-union有什么区别？">struct 和 union有什么区别？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在任何同一时刻, union中只存放了一个被选中的成员; 而struct的所有成员都存在。</span><br><span class="line">2. struct占用的空间为4的倍数，而union占用的空间等于最长的成员的长度。</span><br><span class="line">3. 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了,所以，共同体变量中起作用的成员是最后一次存放的成员; 而对于struct的不同成员赋值是互不影响的。</span><br></pre></td></tr></table></figure>
<h2 id="const-和-define相比的优缺点">const 和 #define相比的优缺点</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. #define 只在预编译阶段起作用, const在编译、运行的时候起作用</span><br><span class="line">2. #define 只是简单的字符串替换，没有类型检查。而const有对应的数据类型，需要进行类型检查。</span><br><span class="line">3. #define 只是进行展开,有多少地方使用就替换多少次，它定义的宏常量在内存中有多个备份，const定义的只读变量在程序运行中只有一份备份。</span><br><span class="line">4. #define 是不能进行调试的在预编译阶段就替换了，const常量可以进行调试</span><br><span class="line"></span><br><span class="line">const 的优点：</span><br><span class="line">1.有数据类型，在定义式可进行安全性检查。</span><br><span class="line">2.可调式。</span><br><span class="line">3.占用较少的空间。</span><br></pre></td></tr></table></figure>
<h2 id="关键字static的作用是什么？">关键字static的作用是什么？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static修饰的常规变量，从生命周期和作用域来来分析比较好：</span><br><span class="line"></span><br><span class="line">生命周期： </span><br><span class="line">	从定义该变量该开始，直到程序结束时</span><br><span class="line">作用域：</span><br><span class="line">    若是局部变量，则作用域就是定义该变量的函数块范围</span><br><span class="line">    若是全局变量，则是定义该变量的文件范围内部，也即是 static 修饰的变量具有文件作用域</span><br><span class="line"></span><br><span class="line">static 定义变量的位置在静态变量区，超过其作用域该变量并不被释放，而是在函数结束时释放</span><br><span class="line">static 修饰的变量只会被初始化一次</span><br><span class="line"></span><br><span class="line">static 修饰类：</span><br><span class="line">	static 修饰的成员变量要在类外初始化，属于类，为所有类对象共享，static 修饰的变量不占类的空间</span><br><span class="line">	static 修饰的函数，静态成员函数， 属于类，为类的所有对象共享， 不能访问类的非静态成员，和外部函数， 没有this指针，因此只能访问静态成员(静态成员变量和静态函数)</span><br><span class="line"></span><br><span class="line">程序的内存分配：</span><br><span class="line">1. 栈区 stack 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</span><br><span class="line">2. 堆区 heap 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</span><br><span class="line">3. 自由存储区</span><br><span class="line">4. 全局变量区 局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放</span><br><span class="line">5. 常量区</span><br></pre></td></tr></table></figure>
<h2 id="内存泄漏的场景以及解决方法有哪些？如何避免内存泄漏？">内存泄漏的场景以及解决方法有哪些？如何避免内存泄漏？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内存泄漏场景：</span><br><span class="line">	1. 堆内存泄漏：new/mallc分配内存，未使用对应的delete/free回收</span><br><span class="line">	2. 系统资源泄漏， Bitmap, handle,socket等资源未释放</span><br><span class="line">	3. 没有将基类析构函数定义称为虚函数，（使用基类指针或者引用指向派生类对象时）派生类对象释放时将不能正确释放派生对象部分。</span><br><span class="line"></span><br><span class="line">避免内存泄漏:</span><br><span class="line">	1. 内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。</span><br><span class="line">	2. 使用智能指针</span><br><span class="line">	3. 使用内存泄漏工具检查</span><br></pre></td></tr></table></figure>
<h2 id="TCP与UDP的区别有哪些？">TCP与UDP的区别有哪些？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP为应用层提供可靠的、面向连接的和基于流的服务</span><br><span class="line">1. TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。</span><br><span class="line">2. 使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</span><br><span class="line">当通信结束时，双方必须关闭连接以释放这些内核数据。</span><br><span class="line">3. TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写入数据</span><br><span class="line">，接收端也可以逐个字节地将它们读出。</span><br><span class="line"></span><br><span class="line">UDP为应用层提供不可靠、无连接和基于数据报的服务。</span><br><span class="line">1. “不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，</span><br><span class="line">则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。</span><br><span class="line">2. UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。</span><br><span class="line">3. 基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</span><br></pre></td></tr></table></figure>
<h2 id="TCP建立时三次握手，为啥断开时是四次握手？请描述原因？">TCP建立时三次握手，为啥断开时是四次握手？请描述原因？</h2>
<p><img src="/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/audition_img1.PNG" alt></p>
<h3 id="第一次握手">第一次握手</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时随机生成初始序列号 seq=x</span><br><span class="line"></span><br><span class="line">此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</span><br><span class="line"></span><br><span class="line">这个三次握手中的开始。表示客户端想要和服务端建立连接。</span><br></pre></td></tr></table></figure>
<h3 id="第二次握手">第二次握手</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己随机初始化一个序列号 seq=y</span><br><span class="line"></span><br><span class="line">此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端是否准备好。</span><br></pre></td></tr></table></figure>
<h3 id="第三次握手">第三次握手</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。</span><br><span class="line"></span><br><span class="line">TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/audition_img2.PNG" alt></p>
<h3 id="第一次挥手">第一次挥手</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。客户端进程发出连接释放报文，并且停止发送数据。</span><br><span class="line"></span><br><span class="line">释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</span><br></pre></td></tr></table></figure>
<h3 id="第二次挥手">第二次挥手</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务端收到这个FIN，他发回一个ACK(确认)，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。</span><br><span class="line"></span><br><span class="line">服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。</span><br><span class="line"></span><br><span class="line">这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</span><br><span class="line"></span><br><span class="line">客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</span><br></pre></td></tr></table></figure>
<h3 id="第三次挥手">第三次挥手</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接。</span><br><span class="line"></span><br><span class="line">服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据</span><br><span class="line"></span><br><span class="line">假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</span><br></pre></td></tr></table></figure>
<h3 id="第四次挥手">第四次挥手</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。</span><br><span class="line"></span><br><span class="line">客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。</span><br><span class="line"></span><br><span class="line">注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</span><br><span class="line"></span><br><span class="line">服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/audition_img3.PNG" alt></p>
<hr>
<h2 id="常见的多线程之间线程同步的方式有哪些？实际开发中用到哪个？">常见的多线程之间线程同步的方式有哪些？实际开发中用到哪个？</h2>
<h3 id="1-互斥锁-Mutex">1.互斥锁(Mutex)</h3>
<h3 id="2-条件变量">2.条件变量</h3>
<h3 id="3-读写锁">3.读写锁</h3>
<h3 id="4-信号量">4.信号量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考： https://www.cnblogs.com/Chlik/p/13556720.html</span><br></pre></td></tr></table></figure>
<hr>
<h1>选择题杂项</h1>
<h2 id="1-以下哪个只能用于需求分析？">1.以下哪个只能用于需求分析？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A.对象图 B.类图 C.状态图 D.用例图</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应该是状态图</p>
</blockquote>
<h2 id="2-信号量初值为2，当前值为-4，请问有几个进程阻塞？">2.信号量初值为2，当前值为-4，请问有几个进程阻塞？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当信号量的值小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程个数。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应该是4</p>
</blockquote>
<h3 id="3-以下哪个使用贪心算法不一定能产生整体最优解">3.以下哪个使用贪心算法不一定能产生整体最优解</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A.八皇后 B.最小生成树 C.单源最短路径 D.最佳合并模式</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应该是八皇后（应该使用回溯法）</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面试小知识: delete 和 delete[]</title>
    <url>/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/</url>
    <content><![CDATA[<blockquote>
<p>面试小知识 delete 和 delete[]的区别</p>
</blockquote>
<ol>
<li>区别是什么？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前提 ： 在自定义类型下</span><br><span class="line">delete用来释放new分配的单个对象指针指向的内存，</span><br><span class="line">delete[] : 用来释放new分配的对象数组指针指向的内存。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img5.PNG" alt></p>
<blockquote>
<p>可见网址: <a href="https://blog.csdn.net/heibao111728/article/details/84952023">https://blog.csdn.net/heibao111728/article/details/84952023</a></p>
</blockquote>
<hr>
<p>追加： 动态数组</p>
<blockquote>
<ol>
<li>new</li>
</ol>
</blockquote>
<p><img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img1.PNG" alt><br>
等同于<br>
<img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img2.PNG" alt></p>
<hr>
<p><img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img3.PNG" alt><br>
<img src="/2022/07/14/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86-delete-%E5%92%8C-delete/new_img4.PNG" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试小知识： 取反符号~</title>
    <url>/2022/07/13/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86%EF%BC%9A-%E5%8F%96%E5%8F%8D%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h3 id="今天在力扣刷题的时候看到这么一个问题：-0-？">今天在力扣刷题的时候看到这么一个问题： ~ 0 = ？</h3>
<blockquote>
<p>按照公式：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~x = -(x + 1) </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
