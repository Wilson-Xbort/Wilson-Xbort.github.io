<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Gelasio:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wilson-xbort.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="none">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://wilson-xbort.github.io/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="none">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Willson-Xbort">
<meta property="article:tag" content="Hexo, NexT">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wilson-xbort.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

  <!--此处为建站时间 -->
  <!--<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("09/24/2018 23:45:01");
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML ="(ㆆᴗㆆ)本弱已菜菜的存活了"+dnum+"&thinsp;天"; 
        document.getElementById("times").innerHTML = hnum + "&thinsp;时" + mnum + "&thinsp;分" + snum + "&thinsp;秒"; 
    } 
  setInterval("createtime()",250);-->


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">Linux高性能服务器第二章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-19 12:25:30" itemprop="dateCreated datePublished" datetime="2022-09-19T12:25:30+08:00">2022-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-24 20:55:36" itemprop="dateModified" datetime="2022-09-24T20:55:36+08:00">2022-09-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>IP协议详解</h1>
<p><code>IP协议是TCP/IP协议簇的核心协议</code></p>
<h2 id="IP服务的特点">IP服务的特点</h2>
<blockquote>
<p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>
</blockquote>
<h3 id="1-无状态">1. 无状态</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无状态（stateless）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关</span><br><span class="line">系的。</span><br><span class="line"></span><br><span class="line">这种服务最大的缺点是无法处理乱序和重复的IP数据报。</span><br></pre></td></tr></table></figure>
<h4 id="1-1例子">1.1例子</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">比如:</span><br><span class="line"></span><br><span class="line">发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这</span><br><span class="line">两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。接收端的IP模块只要收到了完整的</span><br><span class="line">IP数据报（如果是IP分片的话，IP模块将先执行重组），就将其数据部分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那</span><br><span class="line">么从上层协议来看，这些数据就可能是乱序的、重复的。</span><br></pre></td></tr></table></figure>
<p>面向连接的协议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。</p>
<h3 id="2-无连接">2. 无连接</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无连接（connectionless）是指IP通信双方都不长久地维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对</span><br><span class="line">方的IP地址。</span><br></pre></td></tr></table></figure>
<h3 id="3-不可靠">3. 不可靠</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力（best effort）。</span><br></pre></td></tr></table></figure>
<h4 id="3-1-例子">3.1 例子</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如:</span><br><span class="line"></span><br><span class="line">某个中转路由器发现IP数据报在网络上存活的时间太长（根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并</span><br><span class="line">返回一个ICMP错误消息（超时错误）给发送端。</span><br><span class="line"></span><br><span class="line">又比如：</span><br><span class="line">接收端发现收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一个ICMP错误消息（IP头部参数错误）给发送端。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。</p>
</blockquote>
<blockquote>
<p>因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
</blockquote>
<h2 id="IPv4头部结构">IPv4头部结构</h2>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img1.PNG" alt><br>
其长度通常为20字节，除非含有可变长的选项部分。</p>
<h3 id="版本号-bit-4bit">版本号(bit) 4bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4位版本号（version）指定IP协议的版本。对IPv4来说，其值是0100。</span><br></pre></td></tr></table></figure>
<h3 id="头部长度-bit-4bit">头部长度(bit) 4bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4位头部长度（header length）标识该IP头部有多少个32 bit字（4字节）。</span><br><span class="line">4(字节）*5行 = 20字节</span><br><span class="line">而选项最多40字节</span><br><span class="line">可以推出IP头部最长60字节</span><br></pre></td></tr></table></figure>
<h3 id="服务类型（bit）-8bit">服务类型（bit） 8bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8位服务类型（Type Of Service，TOS）包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。</span><br><span class="line"></span><br><span class="line">4位 的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。</span><br><span class="line">比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。</span><br></pre></td></tr></table></figure>
<h3 id="总长度（packet-length）-16bit">总长度（packet length） 16bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">16位总长度（total length）是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65 535（216-1）字节。</span><br><span class="line">但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报（或分片）的长度都远远没有达到最大值。</span><br><span class="line"></span><br><span class="line">包括了ip头部和data</span><br></pre></td></tr></table></figure>
<h3 id="标识符（identification）-16bit">标识符（identification） 16bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16位标识（identification）唯一地标识主机发送的每一个数据报。</span><br><span class="line">其初始值由系统随机生成；每发送一个数据报，其值就加1。该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都具</span><br><span class="line">有相同的标识值。</span><br><span class="line"></span><br><span class="line">值1—65535（2^16-1）</span><br></pre></td></tr></table></figure>
<h3 id="标志（Flags）-3bit">标志（Flags） 3bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标志字段用以指出该IP数据报后面是否还有分段</span><br><span class="line">第一位 R 保留位一般是空的。</span><br><span class="line">第二位 DF（Don’t Fragment）位 不分片位 1表示不分片，0表示分片。</span><br><span class="line">第三位 MF（More Fragment）位 更多分片位 1表示后面还有分片，0表示无。除了数据报的最后一个分片外，其他分片都要把它置1。</span><br></pre></td></tr></table></figure>
<h3 id="分片偏移（Flag-offset）-13bit">分片偏移（Flag offset） 13bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位（乘8）</span><br><span class="line">后得到的。</span><br><span class="line"></span><br><span class="line">由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（这样才能保证后面的IP分片拥有一个合适的偏移值）。</span><br></pre></td></tr></table></figure>
<h3 id="生存时间-Time-to-live-8bit">生存时间(Time to live) 8bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8位生存时间（Time To Live，TTL）是数据报到达目的地之前允许经过的路由器跳数。</span><br><span class="line"></span><br><span class="line">TTL值被发送端设置（常见的值是64）。</span><br><span class="line">数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。</span><br><span class="line"></span><br><span class="line">TTL值可以防止数据报陷入路由循环。</span><br></pre></td></tr></table></figure>
<h3 id="协议号（protocol）-8bit">协议号（protocol） 8bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8位协议（protocol）用来区分上层协议。</span><br><span class="line"></span><br><span class="line">/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。其中，ICMP是1，TCP是6，UDP是17。</span><br><span class="line">/etc/protocols文件是RFC 1700的一个子集。</span><br></pre></td></tr></table></figure>
<h3 id="头部校验和（header-checksum）-16bit">头部校验和（header checksum） 16bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法以检验IP数据报头部（注意，仅检验头部）在传输过程</span><br><span class="line">中是否损坏。</span><br></pre></td></tr></table></figure>
<h3 id="源ip地址（Source-address）-32bit">源ip地址（Source address） 32bit</h3>
<h3 id="目标ip地址（Destination-address）-32bit">目标ip地址（Destination address） 32bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32位的源端IP地址和目的端IP地址用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，</span><br><span class="line">而不论它中间经过多少个中转路由器。</span><br></pre></td></tr></table></figure>
<h3 id="可选项（options）">可选项（options）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">完成一些特殊功能：严格路由 松散路由 记录路由 时间戳只能在options 里面做。</span><br><span class="line">这部分最多包含40字节，因为IP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。</span><br></pre></td></tr></table></figure>
<h2 id="使用tcpdump观察IPv4头部结构">使用tcpdump观察IPv4头部结构</h2>
<h3 id="操作过程如下">操作过程如下:</h3>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img2.PNG" alt></p>
<h3 id="用tcpdump抓取数据包">用tcpdump抓取数据包:</h3>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img3.PNG" alt></p>
<blockquote>
<p>这次抓包我们开启了tcpdump的-x选项，使之输出数据包的二进制码。此数据包共包含60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据（length值为0）。</p>
</blockquote>
<h3 id="分析头部的字节">分析头部的字节</h3>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img4.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000: 4510 003c a5da 4000 4006 96cf 7f00 0001</span><br><span class="line">解析：</span><br><span class="line">	都是16进制，1个16进制是4位，对照下方的表格看</span><br><span class="line">	IP版本号4，头部长度20字节，开启最小延时服务，禁止分片，TTL最多经过64个路由器，上层协议是TCP。</span><br></pre></td></tr></table></figure>
<h1>IP分片</h1>
<blockquote>
<p>当IP数据报的长度超过帧的MTU时，它将被分片传<br>
输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能<br>
在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才<br>
会被内核中的IP模块重新组装。</p>
</blockquote>
<blockquote>
<p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：<code>数据报标识、 标志和片偏移</code>。一个IP数据报的每个分片都具有自己的IP头<br>
部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一<br>
个分片外，其他分片都将设置<code>MF</code>标志。此外，每个分片的IP头部的总<br>
长度字段将被设置为该分片的长度。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以太网帧的MTU是1500字节（可以通过ifconfig命令或者netstat命令查看），因此它携带的IP数据报的数据部分最多是1480字节（IP头部</span><br><span class="line">占用20字节）。考虑用IP数据报封装一个长度为1481字节的ICMP报文（包括8字节的ICMP头部，所以其数据部分长度为1473字节），则该</span><br><span class="line">数据报在使用以太网帧传输时必须被分片。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img5.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  长度为1501字节的IP数据报被拆分成两个IP分片，第一个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片</span><br><span class="line">都包含自己的IP头部（20字节），且第一个IP分片的IP头部设置了MF标志，而第二个IP分片的IP头部则没有设置该标志，因为它</span><br><span class="line">已经是最后一个分片了。原始IP数据报中的ICMP头部内容被完整地复制到了第一个IP分片中。第二个IP分片不包含ICMP头部信息</span><br><span class="line">，因为IP模块重组该ICMP报文的时候只需要一份ICMP头部信息，重复传送这个信息没有任何益处。1473字节的ICMP报文数据的前</span><br><span class="line">1472字节被IP模块复制到第一个IP分片中，使其总长度为1500字节，从而满足MTU的要求；而多出的最后1字节则被复制到第二个</span><br><span class="line">IP分片中。</span><br><span class="line"></span><br><span class="line">  需要指出的是，ICMP报文的头部长度取决于报文的类型，其变化范围很大。图2-2以8字节为例，因为后面的例子用到了ping程序，而</span><br><span class="line">ping程序使用的ICMP回显和应答报文的头部长度是8字节。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了看清楚IP分片的具体过程，考虑从ernest-laptop来ping机器Kongming20，每次传送1473字节的数据（这是ICMP报文的数据部分）<br>
以强制引起IP分片，并用tcpdump抓取这一过程中双方交换的数据包。具体操作过程如下：</p>
</blockquote>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img6.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这两个IP分片的标识值都是61197，说明它们是同一个IP数据报的分片。</span><br><span class="line"></span><br><span class="line">第一个分片的片偏移值为0，而第二个则是1480。很显然，第二个分片的片偏移值实际上也是第一个分片的ICMP报文的长度。</span><br><span class="line">第一个分片设置了MF标志以表示还有后续分片，所以tcpdump输 出“flags[+]”。</span><br><span class="line">而第二个分片则没有设置任何标志，所以tcpdump输 出“flags[none]”。这个两个分片的长度分别为1500字节和21字节。</span><br><span class="line"></span><br><span class="line">最后，IP层传递给数据链路层的数据可能是一个完整的IP数据报，也可能是一个IP分片，它们统称为IP分组（packet）。</span><br></pre></td></tr></table></figure>
<h1>IP路由</h1>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img7.PNG" alt></p>
<p>从右往左看：</p>
<blockquote>
<p>当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做CRC校验，确认无误之后就分析其头部的具体信息。</p>
</blockquote>
<blockquote>
<p>如果该IP数据报的头部设置了<code>源站选路选项</code>（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理该数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址，或者是广播地址，即该数据报是发送给本机的，则IP模块就根据数据报头部中的协议字段来决定将它派发给哪个上层应用（分用）。如果IP模块发现这个数据报不是发送给本机的，则也调用数据报转发子模块来处理该数据报。</p>
</blockquote>
<blockquote>
<p>IP数据报应该发送至哪个下一跳路由（或者目标机器），以及经过哪个网卡来发送，就是IP路由过程，即图2-3中“计算下一跳路由”子模块。IP模块实现数据报路由的核心数据结构是<code>路由表</code>。这个表按照数据报的目标IP地址分类，同一类型的IP数据报将被发往相同的下一跳路由器（或者目标机器）。我们将在后面讨论IP路由过程。</p>
</blockquote>
<blockquote>
<p>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括封装了本机上层数据（ICMP报文、TCP报文段和UDP数据报）的IP数据报。</p>
</blockquote>
<blockquote>
<p>图2-3中的虚线箭头显示了<code>路由表更新的过程</code>。这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，称为IP路由策略。</p>
</blockquote>
<h2 id="路由机制">路由机制</h2>
<blockquote>
<p>要研究IP路由机制，需要先了解路由表的内容。我们可以使用<code>route</code>命令或<code>netstat</code>命令查看路由表。在测试机器ernest-laptop上执行route命令。</p>
</blockquote>
<h3 id="路由表实例">路由表实例</h3>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img8.PNG" alt></p>
<p>该路由表包含两项，每项都包含8个字段。<br>
<img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img9.PNG" alt></p>
<blockquote>
<p>第一项的目标地址是default，即所谓的<code>默认路由项</code>。该项包含一个“G”标志，说明路由的下一跳目标是网关，其地址是192.168.1.1（这是测试网络中路由器的本地IP地址）。另外一个路由项的目标地址是192.168.1.0，它指的是<code>本地局域网</code>。该路由项的网关地址为*，说明数据报不需要路由中转，可以直接发送到目标机器。</p>
</blockquote>
<p>那么路由表是如何按照IP地址分类的呢？或者说给定数据报的目标IP地址，它将匹配路由表中的哪一项呢？这就是IP的路由机制，分为<br>
3个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。</span><br><span class="line">如果找到，就使用该路由项，没找到则转步骤2。</span><br><span class="line"></span><br><span class="line">2）查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP</span><br><span class="line">地址（比如代码清单2-2所示的路由表中的第二项）。如果找到，就使</span><br><span class="line">用该路由项；没找到则转步骤3。</span><br><span class="line"></span><br><span class="line">3）选择默认路由项，这通常意味着数据报的下一跳路由是网关。</span><br><span class="line">因此，对于测试机器ernest-laptop而言，所有发送到IP地址为</span><br><span class="line">192.168.1.*的机器的IP数据报都可以直接发送到目标机器（匹配路由表</span><br><span class="line">第二项），而所有访问因特网的请求都将通过网关来转发（匹配默认</span><br><span class="line">路由项）。</span><br></pre></td></tr></table></figure>
<h2 id="路由表更新">路由表更新</h2>
<blockquote>
<p>路由表必须能够更新，以反映网络连接的变化，这样IP模块才能准确、高效地转发数据报。route命令可以修改路由表。我们看如下几个例子（在机器ernest-laptop上执行）：</p>
</blockquote>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img10.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第1行表示添加主机192.168.1.109（机器Kongming20）对应的路由项。</span><br><span class="line">这样设置之后，所有从ernest-laptop发送到Kongming20的IP数据报将通过网卡eth0直接发送至目标机器的接收网卡。</span><br><span class="line"></span><br><span class="line">第2行表示删除网络192.168.1.0对应的路由项。</span><br><span class="line">这样，除了机器Kongming20外，测试机器ernest-laptop将无法访问该局域网上的任何其他机器（能访问到Kongming20是由于执行了上一条命令）。</span><br><span class="line"></span><br><span class="line">第3行表示删除默认路由项，这样做的后果是无法访问因特网。</span><br><span class="line"></span><br><span class="line">第4行表示重新设置默认路由项，不过这次其网关是机器Kongming20（而不是能直接访问因特网的路由器）！</span><br><span class="line">经过上述修改后的路由表如下：</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img11.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这个新的路由表中，第一个路由项是主机路由项，所以它被设置了“H”标志。我们设计这样一个路由表的目的是为后文讨论ICMP重定</span><br><span class="line">向提供环境。</span><br><span class="line"></span><br><span class="line">通过route命令或其他工具手工修改路由表，是静态的路由更新方式。对于大型的路由器，它们通常通过BGP（Border Gateway</span><br><span class="line">Protocol，边际网关协议）、RIP（Routing Information Protocol，路由信息协议）、OSPF等协议来发现路径，并更新自己的路由表。这种更新</span><br><span class="line">方式是动态的、自动的。这部分内容超出了本书的讨论范围，感兴趣的读者可阅读参考资料1。</span><br></pre></td></tr></table></figure>
<h1>IP转发</h1>
<blockquote>
<p>不是发送给本机的IP数据报将由数据报转发子模块来处理。路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。我们可以通过修改它来使能主机的数据报转发功能（在测试<br>
机器Kongming20上以root身份执行）：</p>
</blockquote>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img12.PNG" alt></p>
<blockquote>
<p>对于允许IP数据报转发的系统（主机或路由器），数据报转发子模块将对期望转发的数据报执行如下操作：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）检查数据报头部的TTL值。如果TTL值已经是0，则丢弃该数据报。</span><br><span class="line"></span><br><span class="line">2）查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。</span><br><span class="line"></span><br><span class="line">3）如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器。</span><br><span class="line"></span><br><span class="line">4）将TTL值减1。</span><br><span class="line"></span><br><span class="line">5）处理IP头部选项。</span><br><span class="line"></span><br><span class="line">6）如果有必要，则执行IP分片操作。</span><br></pre></td></tr></table></figure>
<h1>重定向</h1>
<h2 id="ICMP重定向报文">ICMP重定向报文</h2>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img13.PNG" alt></p>
<blockquote>
<p>过ICMP报文头部的3个固定字段：8位类型、8位代码和16位校验和。ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。本书仅讨论主机重定向，其代码值为1。</p>
</blockquote>
<p>ICMP重定向报文的数据部分含义很明确，它给接收方提供了如下两个信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.引起重定向的IP数据报（即图2-4中的原始IP数据报）的源端IP地址。</span><br><span class="line">2.应该使用的路由器的IP地址。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接收主机根据这两个信息就可以断定引起重定向的IP数据报应该使用哪个路由器来转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。</span><br><span class="line"></span><br><span class="line">/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文，而/proc/sys/net/ipv4/conf/all/accept_redirects内核参数则指定是否允许接收ICMP重定向报文。</span><br><span class="line"></span><br><span class="line">一般来说，主机只能接收ICMP重定向报文，而路由器只能发送ICMP重定向报文。</span><br></pre></td></tr></table></figure>
<h2 id="主机重定向实例">主机重定向实例</h2>
<p>我们把机器ernest-laptop的网关设置成了机器<br>
Kongming20，2.5节中我们又使能了Kongming20的数据报转发功能，因此机器ernest-laptop将通过Kongming20来访问因特网，比如在ernest-laptop上执行如下ping命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com(119.75.217.56)56(84)bytes of data.</span><br><span class="line">From Kongming20(192.168.1.109):icmp_seq=1 Redirect Host(New</span><br><span class="line">nexthop:192.168.1.1)</span><br><span class="line">64 bytes from 119.75.217.56:icmp_seq=1 ttl=54 time=6.78 ms</span><br><span class="line">---www.a.shifen.com ping statistics---</span><br><span class="line">1 packets transmitted,1 received,0%packet loss,time 0ms</span><br><span class="line">rtt min/avg/max/mdev=6.789/6.789/6.789/0.000 ms</span><br></pre></td></tr></table></figure>
<p>从ping命令的输出来看，Kongming20给ernest-laptop发送了一个ICMP重定向报文，告诉它请通过192.168.1.1来访问目标机器，因为这对ernest-laptop来说是更合理的路由方式。当主机ernest-laptop收到这样的ICMP重定向报文后，它将更新其路由表缓冲（使用命令route-Cn查看），并使用新的路由方式来发送后续数据报。上面讨论的重定向过程可用图2-5来总结。</p>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img14.PNG" alt></p>
<h2 id="IPv6头部结构">IPv6头部结构</h2>
<p>IPv6头部由40字节的固定头部和可变长的扩展头部组成。<br>
<img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img15.PNG" alt></p>
<h3 id="版本号-bit-4bit-2">版本号(bit) 4bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4位版本号（version）指定IP协议的版本。对IPv6来说，其值是6。</span><br></pre></td></tr></table></figure>
<h3 id="通信类型-bit-8bit">通信类型(bit) 8bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8位通信类型（traffic class）指示数据流通信类型或优先级，和IPv4中的TOS类似。</span><br></pre></td></tr></table></figure>
<h3 id="流标签-bit-20bit">流标签(bit) 20bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20位流标签（flow label）是IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输。</span><br></pre></td></tr></table></figure>
<h3 id="净荷长度-bit-16bit">净荷长度(bit) 16bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16位净荷长度（payload length）指的是IPv6扩展头部和应用程序数据长度之和，不包括固定头部长度。</span><br></pre></td></tr></table></figure>
<h3 id="下一个包头-bit-8bit">下一个包头(bit) 8bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8位下一个包头（next header）指出紧跟IPv6固定头部后的包头类型，如扩展头（如果有的话）或某个上层协议头（比如TCP，UDP或ICMP）。它类似于IPv4头部中的协议字段，且相同的取值有相同的含义。</span><br></pre></td></tr></table></figure>
<h3 id="IP地址-bit-128bit">IP地址(bit) 128bit</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPv6用128位（16字节）来表示IP地址，使得IP地址的总量达到了2^128个。所以有人说，“IPv6使得地球上的每粒沙子都有一个IP地址”。</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">32位表示的IPv4地址一般用点分十进制来表示，而IPv6地址则用十</span><br><span class="line">六进制字符串表示，比</span><br><span class="line">如“FE80:0000:0000:0000:1234:5678:0000:0012”。可见，IPv6地址</span><br><span class="line">用“:”分割成8组，每组包含2字节。</span><br></pre></td></tr></table></figure>
<h3 id="零压缩法（省略连续的、全零的组）">零压缩法（省略连续的、全零的组）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面的例子使用零压缩法可表示为“FE80::1234:5678:0000:0012”。</span><br><span class="line">不过零压缩法对一个IPv6地址只能使用一次，比如上面的例子中，</span><br><span class="line">字节组“5678”后面的全零组就不能再省略，否则我们就无法计算每个“::”之间省略了多少个全零组。</span><br></pre></td></tr></table></figure>
<h3 id="IPv6扩展头部">IPv6扩展头部</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。</span><br><span class="line"></span><br><span class="line">它的长度可以是0，表示数据报没使用任何扩展头部。一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部</span><br><span class="line">（固定头部或扩展头部）中的下一个报头字段指定。目前可以使用的扩展头部如表2-3所示。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0/Linux_Server_C2_img16.PNG" alt></p>
<blockquote>
<p>IPv6协议并不是IPv4协议的简单扩展，而是完全独立的协议。用以太网帧封装的IPv6数据报和IPv4数据报具有不同的类型值。第1章提到，IPv4数据报的以太网帧封装类型值是0x800，而IPv6数据报的以太网帧封装类型值是0x86dd（见RFC 2464）。</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">面经整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 09:27:07 / 修改时间：10:51:10" itemprop="dateCreated datePublished" datetime="2022-09-19T09:27:07+08:00">2022-09-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>卡方科技</h1>
<h2 id="1-delete-与-delete-的区别？">1. delete 与 delete[]的区别？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete 释放new分配的单个对象指针指向的内存，只调用一次析构函数。</span><br><span class="line">delete[] 释放new分配的对象数组指针指向的内存,并且逐一调用每个对象的析构函数。</span><br></pre></td></tr></table></figure>
<h2 id="2-多态，虚函数，纯虚函数的作用？">2.多态，虚函数，纯虚函数的作用？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚函数的作用：基类指针既可以使用基类的成员函数，也可以使用派生类的成员函数。</span><br><span class="line">纯虚函数的作用：通过它可以指明一个虚函数只是提供了一个可被子类型改写的接口。抽象类是类里面定义了有纯虚函数的类。</span><br><span class="line">多态的作用：使用多态能够增强程序的可扩充性，即程序需要修改或增加功能时，只需改动或增加较少的代码。此外，使用多态也能起到精简代码的作用。</span><br></pre></td></tr></table></figure>
<h2 id="struct-和-union有什么区别？">struct 和 union有什么区别？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 在任何同一时刻, union中只存放了一个被选中的成员; 而struct的所有成员都存在。</span><br><span class="line">2. struct占用的空间为4的倍数，而union占用的空间等于最长的成员的长度。</span><br><span class="line">3. 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了,所以，共同体变量中起作用的成员是最后一次存放的成员; 而对于struct的不同成员赋值是互不影响的。</span><br></pre></td></tr></table></figure>
<h2 id="const-和-define相比的优缺点">const 和 #define相比的优缺点</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. #define 只在预编译阶段起作用, const在编译、运行的时候起作用</span><br><span class="line">2. #define 只是简单的字符串替换，没有类型检查。而const有对应的数据类型，需要进行类型检查。</span><br><span class="line">3. #define 只是进行展开,有多少地方使用就替换多少次，它定义的宏常量在内存中有多个备份，const定义的只读变量在程序运行中只有一份备份。</span><br><span class="line">4. #define 是不能进行调试的在预编译阶段就替换了，const常量可以进行调试</span><br><span class="line"></span><br><span class="line">const 的优点：</span><br><span class="line">1.有数据类型，在定义式可进行安全性检查。</span><br><span class="line">2.可调式。</span><br><span class="line">3.占用较少的空间。</span><br></pre></td></tr></table></figure>
<h2 id="关键字static的作用是什么？">关键字static的作用是什么？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static修饰的常规变量，从生命周期和作用域来来分析比较好：</span><br><span class="line"></span><br><span class="line">生命周期： </span><br><span class="line">	从定义该变量该开始，直到程序结束时</span><br><span class="line">作用域：</span><br><span class="line">    若是局部变量，则作用域就是定义该变量的函数块范围</span><br><span class="line">    若是全局变量，则是定义该变量的文件范围内部，也即是 static 修饰的变量具有文件作用域</span><br><span class="line"></span><br><span class="line">static 定义变量的位置在静态变量区，超过其作用域该变量并不被释放，而是在函数结束时释放</span><br><span class="line">static 修饰的变量只会被初始化一次</span><br><span class="line"></span><br><span class="line">static 修饰类：</span><br><span class="line">	static 修饰的成员变量要在类外初始化，属于类，为所有类对象共享，static 修饰的变量不占类的空间</span><br><span class="line">	static 修饰的函数，静态成员函数， 属于类，为类的所有对象共享， 不能访问类的非静态成员，和外部函数， 没有this指针，因此只能访问静态成员(静态成员变量和静态函数)</span><br><span class="line"></span><br><span class="line">程序的内存分配：</span><br><span class="line">1. 栈区 stack 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</span><br><span class="line">2. 堆区 heap 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</span><br><span class="line">3. 自由存储区</span><br><span class="line">4. 全局变量区 局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放</span><br><span class="line">5. 常量区</span><br></pre></td></tr></table></figure>
<h2 id="内存泄漏的场景以及解决方法有哪些？如何避免内存泄漏？">内存泄漏的场景以及解决方法有哪些？如何避免内存泄漏？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内存泄漏场景：</span><br><span class="line">	1. 堆内存泄漏：new/mallc分配内存，未使用对应的delete/free回收</span><br><span class="line">	2. 系统资源泄漏， Bitmap, handle,socket等资源未释放</span><br><span class="line">	3. 没有将基类析构函数定义称为虚函数，（使用基类指针或者引用指向派生类对象时）派生类对象释放时将不能正确释放派生对象部分。</span><br><span class="line"></span><br><span class="line">避免内存泄漏:</span><br><span class="line">	1. 内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。</span><br><span class="line">	2. 使用智能指针</span><br><span class="line">	3. 使用内存泄漏工具检查</span><br></pre></td></tr></table></figure>
<h2 id="TCP与UDP的区别有哪些？">TCP与UDP的区别有哪些？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TCP为应用层提供可靠的、面向连接的和基于流的服务</span><br><span class="line">1. TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。</span><br><span class="line">2. 使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</span><br><span class="line">当通信结束时，双方必须关闭连接以释放这些内核数据。</span><br><span class="line">3. TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写入数据</span><br><span class="line">，接收端也可以逐个字节地将它们读出。</span><br><span class="line"></span><br><span class="line">UDP为应用层提供不可靠、无连接和基于数据报的服务。</span><br><span class="line">1. “不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，</span><br><span class="line">则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。</span><br><span class="line">2. UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。</span><br><span class="line">3. 基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</span><br></pre></td></tr></table></figure>
<h2 id="TCP建立时三次握手，为啥断开时是四次握手？请描述原因？">TCP建立时三次握手，为啥断开时是四次握手？请描述原因？</h2>
<p><img src="/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/audition_img1.PNG" alt></p>
<h3 id="第一次握手">第一次握手</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时随机生成初始序列号 seq=x</span><br><span class="line"></span><br><span class="line">此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</span><br><span class="line"></span><br><span class="line">这个三次握手中的开始。表示客户端想要和服务端建立连接。</span><br></pre></td></tr></table></figure>
<h3 id="第二次握手">第二次握手</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己随机初始化一个序列号 seq=y</span><br><span class="line"></span><br><span class="line">此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端是否准备好。</span><br></pre></td></tr></table></figure>
<h3 id="第三次握手">第三次握手</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。</span><br><span class="line"></span><br><span class="line">TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/audition_img2.PNG" alt></p>
<h3 id="第一次挥手">第一次挥手</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。客户端进程发出连接释放报文，并且停止发送数据。</span><br><span class="line"></span><br><span class="line">释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</span><br></pre></td></tr></table></figure>
<h3 id="第二次挥手">第二次挥手</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务端收到这个FIN，他发回一个ACK(确认)，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。</span><br><span class="line"></span><br><span class="line">服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。</span><br><span class="line"></span><br><span class="line">这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</span><br><span class="line"></span><br><span class="line">客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</span><br></pre></td></tr></table></figure>
<h3 id="第三次挥手">第三次挥手</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接。</span><br><span class="line"></span><br><span class="line">服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据</span><br><span class="line"></span><br><span class="line">假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</span><br></pre></td></tr></table></figure>
<h3 id="第四次挥手">第四次挥手</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。</span><br><span class="line"></span><br><span class="line">客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。</span><br><span class="line"></span><br><span class="line">注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</span><br><span class="line"></span><br><span class="line">服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/19/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/audition_img3.PNG" alt></p>
<hr>
<h2 id="常见的多线程之间线程同步的方式有哪些？实际开发中用到哪个？">常见的多线程之间线程同步的方式有哪些？实际开发中用到哪个？</h2>
<h3 id="1-互斥锁-Mutex">1.互斥锁(Mutex)</h3>
<h3 id="2-条件变量">2.条件变量</h3>
<h3 id="3-读写锁">3.读写锁</h3>
<h3 id="4-信号量">4.信号量</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考： https://www.cnblogs.com/Chlik/p/13556720.html</span><br></pre></td></tr></table></figure>
<hr>
<h1>选择题杂项</h1>
<h2 id="1-以下哪个只能用于需求分析？">1.以下哪个只能用于需求分析？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.对象图 B.类图 C.状态图 D.用例图</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应该是状态图</p>
</blockquote>
<h2 id="2-信号量初值为2，当前值为-4，请问有几个进程阻塞？">2.信号量初值为2，当前值为-4，请问有几个进程阻塞？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当信号量的值小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程个数。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应该是4</p>
</blockquote>
<h3 id="3-以下哪个使用贪心算法不一定能产生整体最优解">3.以下哪个使用贪心算法不一定能产生整体最优解</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.八皇后 B.最小生成树 C.单源最短路径 D.最佳合并模式</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应该是八皇后（应该使用回溯法）</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Linux高性能服务器阅读笔记第一章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-17 19:50:36" itemprop="dateCreated datePublished" datetime="2022-09-17T19:50:36+08:00">2022-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-18 19:18:23" itemprop="dateModified" datetime="2022-09-18T19:18:23+08:00">2022-09-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>TCP/IP协议簇以及主要协议</h1>
<h2 id="OSI四层协议">OSI四层协议</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 数据链路层 -&gt; 第一层</span><br><span class="line">2. 网络层 -&gt; 第二层</span><br><span class="line">3. 传输层 -&gt; 第三层</span><br><span class="line">4. 应用层 -&gt; 第四层</span><br></pre></td></tr></table></figure>
<h2 id="主要协议">主要协议</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">应用层	  ping - telent	- OSPF - DNS      用户空间</span><br><span class="line">----------------------------------------- socket</span><br><span class="line">传输层			TCP	- UDP</span><br><span class="line">-----------------------------------------</span><br><span class="line">网络层		    ICMP - IP				  内核空间</span><br><span class="line">-----------------------------------------</span><br><span class="line">数据链路层		ARP - RARP</span><br><span class="line">----------------------------------------- 物理传输媒介</span><br></pre></td></tr></table></figure>
<h3 id="1-数据链路层">1.数据链路层</h3>
<blockquote>
<p>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介(比如以太网、令牌环等）上的传输。常用协议是<code>ARP(Address Resolve Protocol)</code>和<code>RARP(Reverse Address Resolve Protocol)</code>协议。</p>
</blockquote>
<h3 id="2-网络层">2. 网络层</h3>
<blockquote>
<p>网络层实现数据包的选路和转发。核心协议是<code>IP(Internet Protocol)</code>和<code>ICMP(Internet Control Message Protocol)</code>协议。</p>
</blockquote>
<h4 id="2-1-ICMP报文格式">2.1 ICMP报文格式</h4>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img1.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">8位类型字段用于区分报文类型。它将ICMP报文分为两大类：</span><br><span class="line">	</span><br><span class="line">一类是差错报文，这类报文主要用来回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5；</span><br><span class="line"></span><br><span class="line">另一类是查询报文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达（类型值为8）的。有的ICMP报文还使用8位代码字</span><br><span class="line">段来进一步细分不同的条件。比如重定向报文使用代码值0表示对网络重定向，代码值1表示对主机重定向。ICMP报文使用16位校验和字段对整个报文（包</span><br><span class="line">括头部和内容部分）进行循环冗余校验（Cyclic Redundancy Check，CRC），以检验报文在传输过程中是否损坏。不同的ICMP报文类型具有不同的正文内</span><br><span class="line">容。</span><br><span class="line"></span><br><span class="line">其他ICMP报文格式请参考ICMP协议的标准文档RFC792。</span><br><span class="line"></span><br><span class="line">需要指出的是，ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说，上层协议使用下层协议提供的服务）。</span><br></pre></td></tr></table></figure>
<h3 id="3-传输层">3. 传输层</h3>
<blockquote>
<p>传输层为两台主机上的应用程序提供端到端（end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。核心协议是<code>TCP协议，UDP协议，SCTP协议</code>。</p>
</blockquote>
<h4 id="3-1-TCP-IP">3.1 TCP/IP</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。</span><br><span class="line"></span><br><span class="line">TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。</span><br><span class="line"></span><br><span class="line">使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</span><br><span class="line">当通信结束时，双方必须关闭连接以释放这些内核数据。</span><br><span class="line"></span><br><span class="line">TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写入数据</span><br><span class="line">，接收端也可以逐个字节地将它们读出。</span><br></pre></td></tr></table></figure>
<h4 id="3-2-UDP协议">3.2 UDP协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。</span><br><span class="line"></span><br><span class="line">“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，</span><br><span class="line">则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。</span><br><span class="line"></span><br><span class="line">UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。</span><br><span class="line"></span><br><span class="line">基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</span><br></pre></td></tr></table></figure>
<h4 id="3-3-SCTP协议">3.3 SCTP协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SCTP协议（Stream Control Transmission Protocol，流控制传输协议）是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。</span><br><span class="line"></span><br><span class="line">可参考其标准文档RFC 2960</span><br></pre></td></tr></table></figure>
<h3 id="4-应用层">4. 应用层</h3>
<blockquote>
<p>应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现，而应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。如果应用层也在内核中实现，则会使内核变得非常庞大。当然，也有少数服务器程序是在内核中实现的，这样代码就无须在用户空间和内核空间来回切换（主要是数据的复制），极大地提高了工作效率。不过这种代码实现起来较复杂，不够灵活，且不便于移植。</p>
</blockquote>
<h4 id="4-1-telent-协议">4.1 telent 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet协议是一种远程登录协议，它使我们能在本地完成远程任务，本书后续章节将会多次使用telnet客户端登录到其他服务上。</span><br></pre></td></tr></table></figure>
<h4 id="4-2-OSPF-协议">4.2 OSPF 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSPF（Open Shortest Path First，开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</span><br></pre></td></tr></table></figure>
<h4 id="4-3-DNS-协议">4.3 DNS 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNS（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</span><br></pre></td></tr></table></figure>
<h2 id="封装">封装</h2>
<blockquote>
<p>每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p>
</blockquote>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img2.PNG" alt></p>
<blockquote>
<p>经过TCP封装后的数据称为TCP报文段（TCP message segment），或者简称TCP段。前文提到，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的TCP头部信息和TCP内核缓冲区（发送缓冲区或接收缓冲区）数据一起构成了TCP报文段，如下图中的虚线框所示。</p>
</blockquote>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img3.PNG" alt></p>
<blockquote>
<p>当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。</p>
</blockquote>
<blockquote>
<p>经过UDP封装后的数据称为UDP数据报（UDP datagram）。UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。</p>
</blockquote>
<blockquote>
<p>经过IP封装后的数据称为IP数据报（IP datagram）。IP数据报也包括头部信息和数据部分，其中数据部分就是一个TCP报文段、UDP数据报或者ICMP报文。</p>
</blockquote>
<blockquote>
<p>经过数据链路层封装的数据称为帧（frame）。</p>
</blockquote>
<h3 id="以太网帧">以太网帧</h3>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img4.PNG" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">帧的最大传输单元（Max Transmit Unit，MTU），即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限制。</span><br><span class="line">图1-6所示的以太网帧的MTU是1500字节。</span><br></pre></td></tr></table></figure>
<h2 id="分用">分用</h2>
<blockquote>
<p>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。分用是依靠头部信息中的类型字段实现的。</p>
</blockquote>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img5.PNG" alt></p>
<h2 id="测试网络">测试网络</h2>
<blockquote>
<p>测试网络两台主机A和B，以及一个连接到因特网的路由器。</p>
</blockquote>
<p><img src="/2022/09/17/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Linux_Server_img6.PNG" alt></p>
<h2 id="socket">socket</h2>
<blockquote>
<p>数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API（ApplicationProgramming Interface，应用程序编程接口）主要有两套：socket和XTI。</p>
</blockquote>
<blockquote>
<p>由socket定义的这一组API提供如下两点功能：一是将应用程序数据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发送数据（比如图1-5所示的send函数），或者是从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据；二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。</p>
</blockquote>
<blockquote>
<p>值得一提的是，socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈（比如X.25协议栈、UNIX本地域协议栈等）</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/29/leetcode-%E5%91%A8%E8%B5%9B308/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/leetcode-%E5%91%A8%E8%B5%9B308/" class="post-title-link" itemprop="url">leetcode 周赛308</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-29 10:15:44 / 修改时间：20:19:34" itemprop="dateCreated datePublished" datetime="2022-08-29T10:15:44+08:00">2022-08-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>Leetcode 周赛308复盘</h1>
<h2 id="1-和有限的最长子序列">1. 和有限的最长子序列</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。</span><br><span class="line"></span><br><span class="line">返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度  。</span><br><span class="line"></span><br><span class="line">子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-4">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,2,1], queries = [3,10,21]</span><br><span class="line">输出：[2,3,4]</span><br><span class="line">解释：queries 对应的 answer 如下：</span><br><span class="line">- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。</span><br><span class="line">- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。</span><br><span class="line">- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-4">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,4,5], queries = [1]</span><br><span class="line">输出：[0]</span><br><span class="line">解释：空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。</span><br></pre></td></tr></table></figure>
<h3 id="解析：">解析：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 关键字： 子序列，求和</span><br><span class="line">2. 要求的和 与数组元素在数组中的顺序无关 =&gt; 先对数组排序</span><br><span class="line">3. 前缀和 ： 前缀和就是从位置1到位置i这个区间内的所有的数字之和。</span><br><span class="line">4. 循环遍历</span><br></pre></td></tr></table></figure>
<h3 id="代码：-4">代码：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 求前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queries[i] &gt;= nums[j])</span><br><span class="line">                    p++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-给你一个包含若干星号-的字符串-s-。">2.给你一个包含若干星号 * 的字符串 s 。</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在一步操作中，你可以：</span><br><span class="line"></span><br><span class="line">    选中 s 中的一个星号。</span><br><span class="line">    移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。</span><br><span class="line"></span><br><span class="line">返回移除 所有 星号之后的字符串。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">    生成的输入保证总是可以执行题面中描述的操作。</span><br><span class="line">    可以证明结果字符串是唯一的。</span><br></pre></td></tr></table></figure>
<h3 id="示例1-2">示例1:</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;leet**cod*e&quot;</span><br><span class="line">输出：&quot;lecoe&quot;</span><br><span class="line">解释：从左到右执行移除操作：</span><br><span class="line">- 距离第 1 个星号最近的字符是 &quot;leet**cod*e&quot; 中的 &#x27;t&#x27; ，s 变为 &quot;lee*cod*e&quot; 。</span><br><span class="line">- 距离第 2 个星号最近的字符是 &quot;lee*cod*e&quot; 中的 &#x27;e&#x27; ，s 变为 &quot;lecod*e&quot; 。</span><br><span class="line">- 距离第 3 个星号最近的字符是 &quot;lecod*e&quot; 中的 &#x27;d&#x27; ，s 变为 &quot;lecoe&quot; 。</span><br><span class="line">不存在其他星号，返回 &quot;lecoe&quot; 。</span><br></pre></td></tr></table></figure>
<h3 id="示例2-2">示例2:</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;erase*****&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：整个字符串都会被移除，所以返回空字符串。</span><br></pre></td></tr></table></figure>
<h3 id="解析：-2">解析：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 使用栈将非*的元素压入栈中</span><br><span class="line">2. 遇到*，出栈一个元素，如果栈为空，直接返回 &quot;&quot;</span><br><span class="line">3. 反转字符串 reserve</span><br></pre></td></tr></table></figure>
<h3 id="代码：-5">代码：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">string removeStars(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        stack&lt;char&gt; ss;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if(s[i] != &#x27;*&#x27;) ss.push(s[i]);</span><br><span class="line">            else &#123;</span><br><span class="line">                if(!ss.empty()) </span><br><span class="line">                    ss.pop();</span><br><span class="line">                </span><br><span class="line">                else </span><br><span class="line">                    return &quot;&quot;;  </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        while(!ss.empty()) &#123;</span><br><span class="line">            res += ss.top();</span><br><span class="line">            ss.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-收集垃圾的最少总时间">3.收集垃圾的最少总时间</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从 0 开始的字符串数组 garbage ，其中 garbage[i] 表示第 i 个房子的垃圾集合。garbage[i] 只包含字符 &#x27;M&#x27; ，&#x27;P&#x27; 和 &#x27;G&#x27; ，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 一 单位的任何一种垃圾都需要花费 1 分钟。</span><br><span class="line"></span><br><span class="line">同时给你一个下标从 0 开始的整数数组 travel ，其中 travel[i] 是垃圾车从房子 i 行驶到房子 i + 1 需要的分钟数。</span><br><span class="line"></span><br><span class="line">城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 0 出发，按顺序 到达每一栋房子。但它们 不是必须 到达所有的房子。</span><br><span class="line"></span><br><span class="line">任何时刻只有 一辆 垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 不能 做任何事情。</span><br><span class="line"></span><br><span class="line">请你返回收拾完所有垃圾需要花费的 最少 总分钟数。</span><br></pre></td></tr></table></figure>
<h3 id="示例1-3">示例1:</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：garbage = [&quot;G&quot;,&quot;P&quot;,&quot;GP&quot;,&quot;GG&quot;], travel = [2,4,3]</span><br><span class="line">输出：21</span><br><span class="line">解释：</span><br><span class="line">收拾纸的垃圾车：</span><br><span class="line">1. 从房子 0 行驶到房子 1</span><br><span class="line">2. 收拾房子 1 的纸垃圾</span><br><span class="line">3. 从房子 1 行驶到房子 2</span><br><span class="line">4. 收拾房子 2 的纸垃圾</span><br><span class="line">收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。</span><br><span class="line">收拾玻璃的垃圾车：</span><br><span class="line">1. 收拾房子 0 的玻璃垃圾</span><br><span class="line">2. 从房子 0 行驶到房子 1</span><br><span class="line">3. 从房子 1 行驶到房子 2</span><br><span class="line">4. 收拾房子 2 的玻璃垃圾</span><br><span class="line">5. 从房子 2 行驶到房子 3</span><br><span class="line">6. 收拾房子 3 的玻璃垃圾</span><br><span class="line">收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。</span><br><span class="line">由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。</span><br><span class="line">所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-5">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：garbage = [&quot;MMM&quot;,&quot;PGM&quot;,&quot;GP&quot;], travel = [3,10]</span><br><span class="line">输出：37</span><br><span class="line">解释：</span><br><span class="line">收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。</span><br><span class="line">收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。</span><br><span class="line">收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。</span><br><span class="line">总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。</span><br></pre></td></tr></table></figure>
<h3 id="解题思路：">解题思路：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 只要算出收集所有垃圾需要的时间 =&gt; garbage 所有字符串长度之和</span><br><span class="line">2. 考虑在房子之间移动的时间/距离之和 （比如M，只需要找到最后出现的下标就行)</span><br><span class="line">3. 加起来就是答案</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">garbageCollection</span><span class="params">(vector&lt;string&gt;&amp; garbage, vector&lt;<span class="type">int</span>&gt;&amp; travel)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = garbage.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; c : garbage[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">find</span>(c) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    s.<span class="built_in">insert</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 收集所有垃圾需要的时间</span></span><br><span class="line">            res += garbage[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// 最后出现的下标 * travel[下标 - 1]</span></span><br><span class="line">            res += i &gt; <span class="number">0</span> ? s.<span class="built_in">size</span>() * travel[i - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-给定条件下构造矩阵">4.给定条件下构造矩阵</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给你一个 正 整数 k ，同时给你：</span><br><span class="line"></span><br><span class="line">    一个大小为 n 的二维整数数组 rowConditions ，其中 rowConditions[i] = [abovei, belowi] 和</span><br><span class="line">    一个大小为 m 的二维整数数组 colConditions ，其中 colConditions[i] = [lefti, righti] 。</span><br><span class="line"></span><br><span class="line">两个数组里的整数都是 1 到 k 之间的数字。</span><br><span class="line"></span><br><span class="line">你需要构造一个 k x k 的矩阵，1 到 k 每个数字需要 恰好出现一次 。剩余的数字都是 0 。</span><br><span class="line"></span><br><span class="line">矩阵还需要满足以下条件：</span><br><span class="line"></span><br><span class="line">    对于所有 0 到 n - 1 之间的下标 i ，数字 abovei 所在的 行 必须在数字 belowi 所在行的上面。</span><br><span class="line">    对于所有 0 到 m - 1 之间的下标 i ，数字 lefti 所在的 列 必须在数字 righti 所在列的左边。</span><br><span class="line"></span><br><span class="line">返回满足上述要求的 任意 矩阵。如果不存在答案，返回一个空的矩阵。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-5">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]</span><br><span class="line">输出：[[3,0,0],[0,0,1],[0,2,0]]</span><br><span class="line">解释：上图为一个符合所有条件的矩阵。</span><br><span class="line">行要求如下：</span><br><span class="line">- 数字 1 在第 1 行，数字 2 在第 2 行，1 在 2 的上面。</span><br><span class="line">- 数字 3 在第 0 行，数字 2 在第 2 行，3 在 2 的上面。</span><br><span class="line">列要求如下：</span><br><span class="line">- 数字 2 在第 1 列，数字 1 在第 2 列，2 在 1 的左边。</span><br><span class="line">- 数字 3 在第 0 列，数字 2 在第 1 列，3 在 2 的左边。</span><br><span class="line">注意，可能有多种正确的答案。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-6">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。</span><br><span class="line">没有符合条件的矩阵存在，所以我们返回空矩阵。</span><br></pre></td></tr></table></figure>
<h3 id="提示1：">提示1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数字之间的约束只发生在行与行、列于列，而行与列之间没有任何约束。</span><br><span class="line"></span><br><span class="line">因此我们可以分别处理行与列中数字的相对顺序，如何求出这个相对顺序呢？</span><br></pre></td></tr></table></figure>
<h3 id="提示2：">提示2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序。</span><br></pre></td></tr></table></figure>
<h3 id="提示3：">提示3：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于 rowConditions，我们可以从 abovei​ 向 belowi 连一条有向边，得到一张有向图。在这张图上跑拓扑排序，得到的拓扑序就是行与行中数字的相对顺序，这样我们就知道了每一行要填哪个数字。如果得到的拓扑序长度不足 kkk，说明图中有环，无法构造，答案不存在。</span><br><span class="line"></span><br><span class="line">对 colConditions 也执行上述过程，得到每一列要填哪个数字，进而得到每个数字要填到哪一列中，这样我们就知道每一行的数字要填到哪一列了。</span><br></pre></td></tr></table></figure>
<h3 id="代码：-6">代码：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; topo_sort(int k, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; g(k);</span><br><span class="line">        vector&lt;int&gt; in_deg(k); // 入度</span><br><span class="line">        for(auto &amp;e : edges) &#123;</span><br><span class="line">            // 总共两个元素, x 在 y的上方 / 左边</span><br><span class="line">            // 顶点编号从 0 开始，方便计算</span><br><span class="line">            int x = e[0] - 1, y = e[1] - 1;</span><br><span class="line">            // 先将下边/右边的添加进图(g)中</span><br><span class="line">            g[x].push_back(y);</span><br><span class="line">            // 入度 + 1</span><br><span class="line">            ++in_deg[y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            if (in_deg[i] == 0) // 入度为0，进入队列</span><br><span class="line">                q.push(i);</span><br><span class="line">        // 使用BFS，拓扑排序和BFS原理一样，都是先从最外围的开始       </span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            int x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            order.push_back(x);</span><br><span class="line">            for(int y : g[x]) </span><br><span class="line">                if(--in_deg[y] == 0) // 入度为0，进入队列</span><br><span class="line">                q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; buildMatrix(int k, vector&lt;vector&lt;int&gt;&gt;&amp; rowConditions, vector&lt;vector&lt;int&gt;&gt;&amp; colConditions) &#123;</span><br><span class="line">        auto row = topo_sort(k, rowConditions), col = topo_sort(k, colConditions);</span><br><span class="line">        if (row.size() &lt; k || col.size() &lt; k) return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; pos(k);</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            // pos[x] 表示元素 x 应该在哪一列，这样最后的答案就知道要把 row[i] 放在哪一列了</span><br><span class="line">            pos[col[i]] = i;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans(k, vector&lt;int&gt;(k));</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            ans[i][pos[row[i]]] = row[i] + 1;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/26/307%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/26/307%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/" class="post-title-link" itemprop="url">307场周赛复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-26 12:02:17 / 修改时间：20:41:26" itemprop="dateCreated datePublished" datetime="2022-08-26T12:02:17+08:00">2022-08-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>Leetcode 第307场周赛复盘</h1>
<h2 id="1-赢得比赛需要的最少训练时长">1.赢得比赛需要的最少训练时长</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。</span><br><span class="line"></span><br><span class="line">另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。</span><br><span class="line"></span><br><span class="line">你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。</span><br><span class="line"></span><br><span class="line">击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少  energy[i] 。</span><br><span class="line"></span><br><span class="line">在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。</span><br><span class="line"></span><br><span class="line">返回击败全部 n 个对手需要训练的 最少 小时数目。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。</span><br><span class="line">按以下顺序与对手比赛：</span><br><span class="line">- 你的精力与经验都超过第 0 个对手，所以获胜。</span><br><span class="line">  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。</span><br><span class="line">- 你的精力与经验都超过第 1 个对手，所以获胜。</span><br><span class="line">  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。</span><br><span class="line">- 你的精力与经验都超过第 2 个对手，所以获胜。</span><br><span class="line">  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。</span><br><span class="line">- 你的精力与经验都超过第 3 个对手，所以获胜。</span><br><span class="line">  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。</span><br><span class="line">在比赛前进行了 8 小时训练，所以返回 8 。</span><br><span class="line">可以证明不存在更小的答案。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]</span><br><span class="line">输出：0</span><br><span class="line">解释：你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。</span><br></pre></td></tr></table></figure>
<h3 id="我的题解：">我的题解：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, vector&lt;<span class="type">int</span>&gt;&amp; energy, vector&lt;<span class="type">int</span>&gt;&amp; experience)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> energy_len = energy.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> experience_len = energy.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 经验训练次数，精力训练次数</span></span><br><span class="line">        <span class="type">int</span> exp_time_experience = <span class="number">0</span>, exp_time_energy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 训练</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; experience_len; ) &#123;</span><br><span class="line">            <span class="comment">// 必须是经验和精力严格大于敌人才能击败敌人</span></span><br><span class="line">            <span class="keyword">if</span>(initialExperience &gt; experience[i] &amp;&amp; initialEnergy &gt; energy[i]) &#123;</span><br><span class="line">                initialExperience += experience[i];</span><br><span class="line">                initialEnergy -= energy[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="comment">// 如果精力不大于敌人，我们就训练精力</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(initialEnergy - energy[i] &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                exp_time_energy++;</span><br><span class="line">                initialEnergy++;</span><br><span class="line">            &#125; <span class="comment">// 如果经验不大于敌人，我们就训练经验</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                exp_time_experience++;</span><br><span class="line">                initialExperience++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后返回经验和精力的训练次数之和</span></span><br><span class="line">        <span class="keyword">return</span> exp_time_experience + exp_time_energy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-最大回文数字">2.最大回文数字</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给你一个仅由数字（0 - 9）组成的字符串 num 。</span><br><span class="line"></span><br><span class="line">请你找出能够使用 num 中数字形成的 最大回文 整数，并以字符串形式返回。该整数不含 前导零 。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">    你 无需 使用 num 中的所有数字，但你必须使用 至少 一个数字。</span><br><span class="line">    数字可以重新排序。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-2">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;444947137&quot;</span><br><span class="line">输出：&quot;7449447&quot;</span><br><span class="line">解释：</span><br><span class="line">从 &quot;444947137&quot; 中选用数字 &quot;4449477&quot;，可以形成回文整数 &quot;7449447&quot; 。</span><br><span class="line">可以证明 &quot;7449447&quot; 是能够形成的最大回文整数。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-2">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;00009&quot;</span><br><span class="line">输出：&quot;9&quot;</span><br><span class="line">解释：</span><br><span class="line">可以证明 &quot;9&quot; 能够形成的最大回文整数。</span><br><span class="line">注意返回的整数不应含前导零。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们要考虑的情况：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路： 先构造左半部分，最后填充镜像字符串</span><br><span class="line">1. 前导 ‘0’： 比如 0000。 -&gt; 【字符串长度超过1的情况，你的第一个字母不能是0】</span><br><span class="line">2. 例如 100  ： 如果安装每次取偶数个数填左右，可能变成 010。 -&gt;【从9开始枚举到1，单独考虑0】</span><br><span class="line">3. 考虑从中间填一个字符串 -&gt; [从9开始枚举到0]</span><br><span class="line">4. 最后填充镜像字符串</span><br></pre></td></tr></table></figure>
<h1>我的题解：</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestPalindromic</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : num) cnt[c - <span class="string">&#x27;0&#x27;</span>]++;   </span><br><span class="line">        <span class="comment">// 特殊情况 0000</span></span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>] == num.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="comment">// 从9枚举到1,单独考虑0</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 找出成对的最大数字</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt[i] / <span class="number">2</span>; j++)</span><br><span class="line">                res += (i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">0</span>] / <span class="number">2</span>; i++)</span><br><span class="line">                res += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        string tmp = res;</span><br><span class="line">        <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 考虑中间填一个字符，遍历num选择最大数,[0, 9]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res += i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="感染二叉树需要的总时间">感染二叉树需要的总时间</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。</span><br><span class="line"></span><br><span class="line">每分钟，如果节点满足以下全部条件，就会被感染：</span><br><span class="line"></span><br><span class="line">    节点此前还没有感染。</span><br><span class="line">    节点与一个已感染节点相邻。</span><br><span class="line"></span><br><span class="line">返回感染整棵树需要的分钟数。</span><br></pre></td></tr></table></figure>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,5,3,null,4,10,6,9,2], start = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：节点按以下过程被感染：</span><br><span class="line">- 第 0 分钟：节点 3</span><br><span class="line">- 第 1 分钟：节点 1、10、6</span><br><span class="line">- 第 2 分钟：节点5</span><br><span class="line">- 第 3 分钟：节点 4</span><br><span class="line">- 第 4 分钟：节点 9 和 2</span><br><span class="line">感染整棵树需要 4 分钟，所以返回 4 。</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1], start = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。</span><br></pre></td></tr></table></figure>
<h3 id="题解：（没看懂）">题解：（没看懂）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int max = 0;</span><br><span class="line">    int dfs(TreeNode* root, int start, int sum) &#123;</span><br><span class="line">        // 没感染返回-1,为nullptr自然不会被感染</span><br><span class="line">        if(root == NULL) return -1;</span><br><span class="line">        if(sum == -1 &amp;&amp; root-&gt;val == start) &#123; // 本节点为感染节点</span><br><span class="line">            sum = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum != -1) &#123;</span><br><span class="line">            // 本节点已经感染，传递到子树中</span><br><span class="line">            dfs(root-&gt;left, start, sum + 1);</span><br><span class="line">            dfs(root-&gt;right, start, sum + 1);</span><br><span class="line">            if(sum &gt; max) max = sum;</span><br><span class="line">            return sum + 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int tem = dfs(root-&gt;left, start, sum);</span><br><span class="line">            if(tem != -1) &#123; // 左子树被感染，传递到右子树</span><br><span class="line">                sum = tem;</span><br><span class="line">                dfs(root-&gt;right, start, sum + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                sum = dfs(root-&gt;right, start, sum);</span><br><span class="line">                dfs(root-&gt;left, start, sum + 1);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &gt; max) max = sum;</span><br><span class="line">        if(sum != -1) return sum + 1;</span><br><span class="line">        return -1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int amountOfTime(TreeNode* root, int start) &#123;</span><br><span class="line">        // 一个节点被感染，可以分为四种方向, 本身感染，从父节点感染，从左子树感染，从右子树感染</span><br><span class="line">        dfs(root, start, -1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="找出数组的第-K-大和">找出数组的第 K 大和</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个 正 整数 k 。你可以选择数组的任一 子序列 并且对其全部元素求和。</span><br><span class="line"></span><br><span class="line">数组的 第 k 大和 定义为：可以获得的第 k 个 最大 子序列和（子序列和允许出现重复）</span><br><span class="line"></span><br><span class="line">返回数组的 第 k 大和 。</span><br><span class="line"></span><br><span class="line">子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</span><br><span class="line"></span><br><span class="line">注意：空子序列的和视作 0 。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-3">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,4,-2], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：所有可能获得的子序列和列出如下，按递减顺序排列：</span><br><span class="line">- 6、4、4、2、2、0、0、-2</span><br><span class="line">数组的第 5 大和是 2 。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>子序列：序列中的一个元素可选可不选。</code></p>
</blockquote>
<h3 id="示例2：-3">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,-2,3,4,-10,12], k = 16</span><br><span class="line">输出：10</span><br><span class="line">解释：数组的第 16 大和是 10 。</span><br></pre></td></tr></table></figure>
<h3 id="方法一、堆">方法一、堆</h3>
<h4 id="提示一">提示一</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">记 nums 中所有非负数的和为 sum。</span><br><span class="line"></span><br><span class="line">任意一个子序列的和，都等价于从 sum 中减去某些非负数 / 加上某些负数得到。</span><br></pre></td></tr></table></figure>
<h4 id="提示二">提示二</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将 nums 所有数取绝对值，这样可以统一成从 sum 中减去某些数。</span><br><span class="line"></span><br><span class="line">我们需要按照从小到大的顺序取出 sum 要减去的子序列，如何做到？</span><br></pre></td></tr></table></figure>
<h4 id="提示三">提示三</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将 nums 所有数取绝对值后排序，然后用最大堆来实现。</span><br></pre></td></tr></table></figure>
<h4 id="提示四">提示四</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">具体来说，最大堆维护子序列的和，以及（后续需要减去的）数字的下标 i。</span><br><span class="line"></span><br><span class="line">初始时，将 sum 和下标 0 入堆。</span><br><span class="line"></span><br><span class="line">每次弹出堆顶时，将子序列的和减去 nums[i]，并考虑是否保留 nums[i−1]，从而满足子序列每个元素「选或不选」的要求。</span><br><span class="line"></span><br><span class="line">这一做法可以不重不漏地生成所有子序列的和，再配合堆，就可以从大到小生成。</span><br><span class="line">循环 k−1k-1k−1 次后，堆顶的和就是答案。</span><br></pre></td></tr></table></figure>
<h4 id="提示五">提示五</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 1. 从最大的子序列和来考虑，那么这个序列和就是所有正数的和 sum。</span><br><span class="line"> 2. 怎么找到第二大的子序列和？从最大的子序列和中减去最小的正数或加上最大的负数。</span><br><span class="line"> 3. 为了统一操作，将负数取反，然后排序，每次取最小的数，得到的就是最小的正数或最大的负数。</span><br><span class="line"> sum 中减去它，就可以得到下一个更小的子序列和。</span><br><span class="line"> 4. 被减去的数们实际上也是组成了一个子序列。按照生成子序列的模板，就是依次对每个数，考虑</span><br><span class="line"> 选择它，还是不选择它。</span><br><span class="line"></span><br><span class="line">这样分析之后，就可以回答大家的两个问题：</span><br><span class="line"></span><br><span class="line">Q：怎么保证 pq 的顶就是答案？A：因为是用当前值最大和减去最小值，所以得到的一定是下一个略小的最大和。</span><br><span class="line">Q：保留和不保留 nums[i-1] 是不是写反了？A：是否保留指的是在被 *减去* 的子序列中是否保留此数。所以，如果不保留的话，反而是要加回来，因为它不该被从 sum 里减去。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="解法：">解法：</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">kSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;x : nums)</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) sum += x;</span><br><span class="line">            <span class="keyword">else</span> x = -x;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">long</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (--k) &#123;</span><br><span class="line">            <span class="keyword">auto</span>[sum, i] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(sum - nums[i], i + <span class="number">1</span>); <span class="comment">// 保留 nums[i-1]</span></span><br><span class="line">                <span class="keyword">if</span> (i) pq.<span class="built_in">emplace</span>(sum - nums[i] + nums[i - <span class="number">1</span>], i + <span class="number">1</span>); <span class="comment">// 不保留 nums[i-1]，把之前减去的加回来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">模拟面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 15:55:06" itemprop="dateCreated datePublished" datetime="2022-08-23T15:55:06+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-27 11:20:32" itemprop="dateModified" datetime="2022-08-27T11:20:32+08:00">2022-08-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>2022-8-23</h1>
<h2 id="1-常见的HTTP协议状态码有哪些？">1. 常见的HTTP协议状态码有哪些？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">标准回答</span><br><span class="line"></span><br><span class="line">常见的状态码有：</span><br><span class="line">    1xx代表服务器端已经接受了请求。</span><br><span class="line">    2xx代表请求已经被服务器端成功接收，最常见的有200、201状态码。</span><br><span class="line">    3xx代表路径被服务器端重定向到了一个新的URL，最常见的有301、302状态码。</span><br><span class="line">    4xx代表客户端的请求发生了错误，最常见的有401、404状态码。</span><br><span class="line">    5xx代表服务器端的响应出现了错误。 </span><br><span class="line"></span><br><span class="line">加分回答</span><br><span class="line"></span><br><span class="line">    1xx：指定客户端相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</span><br><span class="line"></span><br><span class="line">    2xx：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。</span><br><span class="line">        200（成功）：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</span><br><span class="line">        201（已创建）：请求成功并且服务器创建了新的资源。</span><br><span class="line">        202（已接受）：服务器已接受请求，但尚未处理。</span><br><span class="line">        203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源。</span><br><span class="line">        204（无内容）：服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line">        205（重置内容）：服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line">        206（部分内容）：服务器成功处理了部分 GET 请求。 </span><br><span class="line"></span><br><span class="line">    3xx：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在响应头Location字段中指明。这系列中最常见的有301、302状态码。</span><br><span class="line">        300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</span><br><span class="line">        301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class="line">        302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line">        303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class="line">        304（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line">        305（使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</span><br><span class="line">        307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 </span><br><span class="line"></span><br><span class="line">    4xx：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。</span><br><span class="line"></span><br><span class="line">        400（错误请求）：服务器不理解请求的语法。</span><br><span class="line"></span><br><span class="line">        401（未授权）：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</span><br><span class="line"></span><br><span class="line">        403（禁止）：服务器拒绝请求。</span><br><span class="line"></span><br><span class="line">        404（未找到）：服务器找不到请求的网页。</span><br><span class="line"></span><br><span class="line">        405（方法禁用）：禁用请求中指定的方法。</span><br><span class="line"></span><br><span class="line">        406（不接受）：无法使用请求的内容特性响应请求的网页。</span><br><span class="line"></span><br><span class="line">        407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class="line"></span><br><span class="line">        408（请求超时）：服务器等候请求时发生超时。</span><br><span class="line"></span><br><span class="line">        409（冲突）：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</span><br><span class="line"></span><br><span class="line">        410（已删除）：如果请求的资源已永久删除，服务器就会返回此响应。</span><br><span class="line"></span><br><span class="line">        411（需要有效长度）：服务器不接受不含有效内容长度标头字段的请求。</span><br><span class="line"></span><br><span class="line">        412（未满足前提条件）：服务器未满足请求者在请求中设置的其中一个前提条件。</span><br><span class="line"></span><br><span class="line">        413（请求实体过大）：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</span><br><span class="line"></span><br><span class="line">        414（请求的 URI 过长）：请求的 URI（通常为网址）过长，服务器无法处理。</span><br><span class="line"></span><br><span class="line">        415（不支持的媒体类型）：请求的格式不受请求页面的支持。</span><br><span class="line"></span><br><span class="line">        416（请求范围不符合要求）：如果页面无法提供请求的范围，则服务器会返回此状态代码。</span><br><span class="line"></span><br><span class="line">        417 （未满足期望值）：服务器未满足&quot;期望&quot;请求标头字段的要求。</span><br><span class="line"></span><br><span class="line">    5xx：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。</span><br><span class="line">        500（服务器内部错误）：服务器遇到错误，无法完成请求。</span><br><span class="line">        501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line">        502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line">        503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</span><br><span class="line">        504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line">        505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-简述一下C-中的四种类型转换">2.简述一下C++ 中的四种类型转换</h2>
<blockquote>
<p>const_cast 只能改变运算对象的底层const,只有const_cast能改变表达式的常量属性,将常量对象转换成非常量对象的行为，我们一般称其为&quot;去掉const性质。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对改对象进行读写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法行为。<br>
然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc); <span class="comment">// 正确：但是通过p写值是未定义的行为</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cp;</span><br><span class="line"><span class="comment">// 错误：static_cast不能转换调const性质</span></span><br><span class="line"><span class="type">char</span> *q = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);</span><br><span class="line"><span class="keyword">static_cast</span>&lt;string&gt;cp; <span class="comment">//正确：字符串字面值转换成string类型</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;string&gt;cp;  <span class="comment">// 错误：const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>static_cast: 任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) / i</span><br></pre></td></tr></table></figure>
<blockquote>
<p>reinterpret_cast：reinterpret_cast，是C++里强制类型转换符。</p>
</blockquote>
<blockquote>
<p>dynamic_cast是将一个基类对象指针（或引用）转换到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理。dynamic_cast运算符涉及到编译器的属性设置，而且牵扯到的面向对象的多态性跟程序运行时的状态也有关系，所以不能完全的使用传统的替换方式来代替。但是也因此它最常用，是最不可缺少的一个运算符。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base &amp;b;</span><br><span class="line"><span class="type">const</span> Derived &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br></pre></td></tr></table></figure>
<h2 id="3-简述C-的内存管理">3.简述C++ 的内存管理</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C++的内存分区主要有五个区：分别是代码区、全局/静态存储区、常量存储区、堆区和栈区。</span><br><span class="line">代码区：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</span><br><span class="line">全局区/静态存储区（.bss【Block Started by Symbol】 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</span><br><span class="line">常量存储区：存放的是常量，不允许修改，程序运行结束自动释放。</span><br><span class="line">栈区：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</span><br><span class="line">堆区：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</span><br></pre></td></tr></table></figure>
<h2 id="两数之和">两数之和</h2>
<blockquote>
<p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。<br>
（注：返回的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 判断哈希表里面是否有tmp</span></span><br><span class="line">        <span class="type">int</span> tmp = target - numbers[i];</span><br><span class="line">        <span class="comment">// 如果没有</span></span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(tmp) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            hash[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(hash[tmp] + <span class="number">1</span>); <span class="comment">// 索引+1</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-为什么要实现多态">C++ 为什么要实现多态?</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。需要在基类函数前加virtual。</span><br></pre></td></tr></table></figure>
<h3 id="看代码：">看代码：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;调用Father类函数&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;调用Son类函数&quot;</span> &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son1;</span><br><span class="line"></span><br><span class="line">	Father* fp = &amp;son1;</span><br><span class="line">	fp-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上图代码函数没有加virtual，导致了fp-&gt;func()最后输出父类的func，而加了virual后，按照原则：不管谁指向/引用谁，都是自动识别调子类自己的函数(调用被重写过的函数）。</p>
</blockquote>
<h2 id="虚函数的作用？">虚函数的作用？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用基类的指针指向不同的派生类的对象时，</span><br><span class="line">基类指针调用其虚成员函数，则会调用其真正指向对象的成员函数，</span><br><span class="line">而不是基类中定义的成员函数（只要派生类改写了该成员函数）。</span><br><span class="line">若不是虚函数，则不管基类指针指向的哪个派生类对象，调用时都</span><br><span class="line">会调用基类中定义的那个函数。</span><br></pre></td></tr></table></figure>
<h2 id="C-重载怎么实现？">C++ 重载怎么实现？</h2>
<h2 id="C-重写和重载的区别？">C++ 重写和重载的区别？</h2>
<blockquote>
<p>函数重载是指在 同一作用域内，可以有一组具有 相同函数名，不同参数列表 的函数，这组函数被称为重载函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">(<span class="type">long</span> a)</span> </span>&#123; .. &#125; <span class="comment">// 重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">(<span class="type">char</span> a)</span> </span>&#123; .. &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">     <span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">()</span> </span>&#123; .. &#125; <span class="comment">// 重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的使用场景">二叉树的使用场景?</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数据压缩(哈夫曼树)</span><br><span class="line">2. STL的容器(map, set) (红黑树)</span><br></pre></td></tr></table></figure>
<h2 id="堆和栈的区别？">堆和栈的区别？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 栈是系统自动分配，堆是人为申请分配。</span><br><span class="line">2. 栈获得的空间较小，堆获得的空间大。</span><br><span class="line">3. 申请效率不同，栈由系统分配，速度较快。</span><br><span class="line">4. 栈是连续空间，堆是不连续空间。</span><br><span class="line">5. 存储内容不同，栈在函数调用时，函数调用的下一条可执行语句的地址第一个进栈,</span><br><span class="line">然后函数的参数进栈，静态变量不如栈。堆是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排的。</span><br></pre></td></tr></table></figure>
<h2 id="public-private-protected-继承">public/private/protected 继承</h2>
<blockquote>
<p>C++ Primer 15.5</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">公有继承(public)、私有继承(private)、保护继承(protected)是常用的三种继承方式。　　</span><br><span class="line">1. 公有继承(public) 　　</span><br><span class="line">公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。　　</span><br><span class="line">2. 私有继承(private) 　默认的继承方式（如果缺省，默认为private继承)</span><br><span class="line">私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。　</span><br><span class="line">子类也不能转换成相应的基类，如果转换，会报错：“不允许对不可访问的基类进行转换”。</span><br><span class="line">3. 保护继承(protected) 　　</span><br><span class="line">保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。　　</span><br></pre></td></tr></table></figure>
<h2 id="C-优先队列中的less和greater">C++优先队列中的less和greater</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>
<h3 id="less源代码：">less源代码：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x&lt;y;&#125;</span><br><span class="line">  <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="less-example">less example</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// less example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// std::less</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::sort, std::includes</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> foo[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">25</span>&#125;;</span><br><span class="line">  <span class="type">int</span> bar[]=&#123;<span class="number">15</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">  std::<span class="built_in">sort</span> (foo, foo+<span class="number">5</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// 5 10 15 20 25</span></span><br><span class="line">  std::<span class="built_in">sort</span> (bar, bar+<span class="number">3</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//   10 15 20</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">includes</span> (foo, foo+<span class="number">5</span>, bar, bar+<span class="number">3</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()))</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo includes bar.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="greater源代码：">greater源代码：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">greater</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line">  <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="greater-example">greater example</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// greater example</span><br><span class="line">#include &lt;iostream&gt;     // std::cout</span><br><span class="line">#include &lt;functional&gt;   // std::greater</span><br><span class="line">#include &lt;algorithm&gt;    // std::sort</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">  int numbers[]=&#123;20,40,50,10,30&#125;;</span><br><span class="line">  std::sort (numbers, numbers+5, std::greater&lt;int&gt;());</span><br><span class="line">  for (int i=0; i&lt;5; i++)</span><br><span class="line">    std::cout &lt;&lt; numbers[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">  std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以知道less<type>()是从小到大排序，greater<type>()是从大到小排序</type></type></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在C++ STL的priority_queue中：</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt;que       -&gt;      从小到大排序</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;,less&lt;int&gt; &gt;que          -&gt;      从大到小排序</span><br></pre></td></tr></table></figure>
<h2 id="请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁-※">请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁 ※</h2>
<h3 id="死锁：">死锁：</h3>
<blockquote>
<p>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。</p>
</blockquote>
<h3 id="死锁产生的必要条件">死锁产生的必要条件</h3>
<blockquote>
<ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放；</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放；</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，···，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。</li>
</ul>
</blockquote>
<h3 id="死锁产生的原因">死锁产生的原因</h3>
<blockquote>
<p>竞争资源 - 进程间推进顺序非法</p>
</blockquote>
<h3 id="怎么预防死锁">怎么预防死锁</h3>
<blockquote>
<p>有序资源分配法 - 银行家算法</p>
</blockquote>
<h2 id="x-x-1-x-1-x-哪个效率高？">x = x + 1, x += 1, x++ 哪个效率高？</h2>
<blockquote>
<p>x = x + 1 执行效率如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 读取右x的地址</span><br><span class="line">2. x + 1</span><br><span class="line">3. 读取左x的地址</span><br><span class="line">4.将右表达式的值传递给左x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x += 1 执行效率如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 读取x的地址</span><br><span class="line">2. x + 1</span><br><span class="line">3. 将得到的值传给x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x++</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 读取x的地址</span><br><span class="line">2. 自增操作</span><br></pre></td></tr></table></figure>
<h2 id="const-和-define-的区别">const 和 #define 的区别</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. #define 只在预编译阶段起作用, const在编译、运行的时候起作用</span><br><span class="line">2. #define 只是简单的字符串替换，没有类型检查。而const有对应的数据类型，需要进行类型检查。</span><br><span class="line">3. #define 只是进行展开,有多少地方使用就替换多少次，它定义的宏常量在内存中有多个备份，const定义的只读变量在程序运行中只有一份备份。</span><br><span class="line">4. #define 是不能进行调试的在预编译阶段就替换了，const常量可以进行调试</span><br></pre></td></tr></table></figure>
<h2 id="new-和-malloc的区别和联系">new 和 malloc的区别和联系</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. new 是 C++中的操作符，malloc是c中的一个函数</span><br><span class="line">2. new不只是分配内存，还会调用类的构造函数，同理，delete会调用类的析构函数，malloc则只会分配内存，不会进行初始化类成员的工作，free也不会调用析构函数。</span><br><span class="line">3. new的指针是直接带着类型信息的，malloc返回的是void*</span><br><span class="line">4. new，delete || new [], delete[] || malloc, free配套使用</span><br></pre></td></tr></table></figure>
<h2 id="构造函数和析构函数可不可以为虚函数？为什么？">构造函数和析构函数可不可以为虚函数？为什么？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">析构函数可以是虚函数，构造函数不可以。因为构造函数有特殊的工作，它处在对象创建初期，先调用基类的构造函数，再按照继承顺序调用派生类的构造函数。</span><br><span class="line">而析构函数和构造函数恰恰相反，从最后的派生类开始，依次到向上到基类，析构函数确切知道它从哪个类派生而来。</span><br><span class="line"></span><br><span class="line">如果某个类不包含虚函数,一般是表示它将不作为一个基类来使用,当一个类不作为基类使用时，析构函数没必要声明为虚函数，以防虚函数表指针浪费空间。</span><br></pre></td></tr></table></figure>
<h2 id="strcpy-和-memcpy的区别">strcpy 和 memcpy的区别</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）复制的内容不同，strcpy只能用于字符串copy，memcpy可以复制任何类型的内容，用途更广。</span><br><span class="line">2）复制的方法不同，strcpy不需要指定长度，遇到&#x27;\0&#x27;才会结束，容易溢出。memcpy需要设置复制长度。</span><br><span class="line">3）用途不同。一般复制字符串才会使用strcpy，其他类型使用memcpy</span><br></pre></td></tr></table></figure>
<h2 id="如何限制一个类对象只在堆-栈）上分配空间？">如何限制一个类对象只在堆(栈）上分配空间？</h2>
<blockquote>
<p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
</blockquote>
<blockquote>
<p>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;</p>
</blockquote>
<blockquote>
<p>动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A();</p>
</blockquote>
<h3 id="1-类对象只建立在堆上">1.类对象只建立在堆上</h3>
<blockquote>
<p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
</blockquote>
<h4 id="解决方法1：">解决方法1：</h4>
<blockquote>
<p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="该方法存在的问题：">该方法存在的问题：</h4>
<blockquote>
<p>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。</p>
</blockquote>
<blockquote>
<p>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
</blockquote>
<h4 id="解决方法2：">解决方法2：</h4>
<blockquote>
<p>构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static A *create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-类对象只建立在栈上">2.类对象只建立在栈上</h3>
<blockquote>
<p>解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    void* operator new(size_t t)&#123;&#125;     // 注意函数的第一个参数和返回值都是固定的  </span><br><span class="line">    void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载delete  </span><br><span class="line">public:  </span><br><span class="line">    A()&#123;&#125;  </span><br><span class="line">    ~A()&#123;&#125;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重载类的new操作符，使重载后的new操作符的功能为空。这样就使外层程序无法在堆上分配对象，只可以在栈上分配。</p>
</blockquote>
<h2 id="C-程序编译过程">C++ 程序编译过程</h2>
<h3 id="1-编译预处理">1. 编译预处理</h3>
<blockquote>
<p>编译预处理：处理以 # 开头的指令；</p>
</blockquote>
<h3 id="2-编译、优化">2. 编译、优化</h3>
<blockquote>
<p>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；</p>
</blockquote>
<h3 id="3-汇编">3. 汇编</h3>
<blockquote>
<p>汇编：将汇编代码 .s 翻译成机器指令 .o 文件；</p>
</blockquote>
<h3 id="4-链接">4. 链接</h3>
<blockquote>
<p>链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
</blockquote>
<p><img src="/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/mock_interview_img1.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">链接分为两种：</span><br><span class="line"></span><br><span class="line">    静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</span><br><span class="line">    动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。</span><br><span class="line">    在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</span><br><span class="line"></span><br><span class="line">二者的优缺点：</span><br><span class="line"></span><br><span class="line">    静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可</span><br><span class="line">    执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</span><br><span class="line">    动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</span><br></pre></td></tr></table></figure>
<h2 id="栈和堆的区别">栈和堆的区别</h2>
<blockquote>
<p>申请方式：栈是系统自动分配，堆是程序员主动申请。</p>
</blockquote>
<blockquote>
<p>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</p>
</blockquote>
<blockquote>
<p>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</p>
</blockquote>
<blockquote>
<p>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</p>
</blockquote>
<blockquote>
<p>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</p>
</blockquote>
<h2 id="变量的区别">变量的区别</h2>
<blockquote>
<p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
</blockquote>
<h3 id="从作用域看：">从作用域看：</h3>
<blockquote>
<p>全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p>
</blockquote>
<blockquote>
<p>静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p>
</blockquote>
<blockquote>
<p>局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p>
</blockquote>
<blockquote>
<p>静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</p>
</blockquote>
<h3 id="从分配内存空间看：">从分配内存空间看：</h3>
<blockquote>
<p>静态存储区：全局变量，静态局部变量，静态全局变量。</p>
</blockquote>
<blockquote>
<p>栈：局部变量。</p>
</blockquote>
<h2 id="全局变量定义在头文件中有什么问题？">全局变量定义在头文件中有什么问题？</h2>
<blockquote>
<p>如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>
</blockquote>
<h3 id="解决方法：">解决方法：</h3>
<blockquote>
<p>1）在头文件起始位置使用预处理指令，也就是 #ifndef，可以防止同一个头文件在一个 cpp 的include 链中被重复 include。<br>
2）头文件不做变量或者函数的定义，只做声明，定义放在cpp文件。</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/" class="post-title-link" itemprop="url">CentOS配置和下载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-22 19:24:38 / 修改时间：21:10:42" itemprop="dateCreated datePublished" datetime="2022-08-22T19:24:38+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>CentOS配置和下载</h1>
<h2 id="下载">下载</h2>
<h3 id="进入官网">进入官网</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.centos.org/</span><br></pre></td></tr></table></figure>
<h3 id="如图：">如图：</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_1.PNG" alt></p>
<h3 id="点击CentOS-Linux">点击CentOS Linux</h3>
<h3 id="如图：-2">如图：</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_2.png" alt></p>
<h3 id="点击x86-64后，链接随便选一个">点击x86/64后，链接随便选一个</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_3.png" alt></p>
<h2 id="问题">问题</h2>
<h3 id="1-虚拟机安装出现system-not-found">1.虚拟机安装出现system not found</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_5.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 打开虚拟机设置 -&gt; 设备状态 -&gt; 启动时连接</span><br></pre></td></tr></table></figure>
<h3 id="2-安装好后发现无法联网">2.安装好后发现无法联网</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_6.png" alt><br>
<img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_4.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 进入root账号</span><br><span class="line">2. 输入 `cd /etc/sysconfig/network-scripts`</span><br><span class="line">3. 输入 `vi ifcfg-ens34`</span><br><span class="line">4. 输入i, `ONBOOT=no`,改成 `ONBOOT=yes`, 输入`wq!`</span><br><span class="line">5. 重启服务 `systemctl restart network`</span><br><span class="line">6. 输入`ip addr`</span><br></pre></td></tr></table></figure>
<h2 id="配置">配置</h2>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/22/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">设计模式复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-22 15:31:43 / 修改时间：20:28:23" itemprop="dateCreated datePublished" datetime="2022-08-22T15:31:43+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计模式复习">设计模式复习</h2>
<h3 id="1-备忘录模式">1. 备忘录模式</h3>
<blockquote>
<p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
</blockquote>
<h4 id="例题：-2">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.某系统提供了用户信息操作模块，用户可以修改自己的各项信息。为了使操作过程更加人性化，可以使用（）对系统进行改进，使得用户在进行了错误操作之后可以恢复到操作之前的状态。</span><br></pre></td></tr></table></figure>
<h3 id="2-适配器模式">2.适配器模式</h3>
<blockquote>
<p>适配器模式（Adapter）通常适用于以下场景。<br>
以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。<br>
使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p>
</blockquote>
<h4 id="例题：-3">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.当已有类能满足目前的需求但和当前的系统兼容性比较差的情况下，比较适合使用（ ）</span><br></pre></td></tr></table></figure>
<h3 id="3-模板方法模式">3.模板方法模式</h3>
<blockquote>
<p>基本流程几乎一样采用模板方法模式</p>
</blockquote>
<h4 id="例题：-4">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.在银行办理业务时，一般都包含几个基本步骤，即取号排队、办理具体业务和对银行工作人员进行评分。无论具体业务是取款、存款还是转账，其基本流程都一样。可以使用（ ）模拟银行业务办理流程。</span><br></pre></td></tr></table></figure>
<h3 id="4-观察者模式">4. 观察者模式</h3>
<blockquote>
<p>观察者模式：定义对象之间的一种一对多的关系，当一个对象发生改变时，其他依赖于该对象的对象也会被通知自动改变。</p>
</blockquote>
<h4 id="例题：-5">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，应该使用何种设计模式：</span><br></pre></td></tr></table></figure>
<h3 id="5-命令模式">5.命令模式</h3>
<blockquote>
<p>命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志。</p>
</blockquote>
<h4 id="例题：-6">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.在设计中如果一个对象请求另一个对象调用其方法到达某种目的，而不和请求的对象直接打交道，这种模式是（ ）。</span><br></pre></td></tr></table></figure>
<h3 id="6-原型模式">6.原型模式</h3>
<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>
原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节。<br>
工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。<br>
它主要面对的问题是：“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。</p>
</blockquote>
<h4 id="例题：-7">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.（）模式的关键是将一个对象定义为原型，并为其提供复制自己的方法。 </span><br><span class="line">2. 以下哪个模式可以利用一个对象，快速地生成一批对象？（）</span><br></pre></td></tr></table></figure>
<h3 id="7-责任链模式">7.责任链模式</h3>
<blockquote>
<p>责任链模式是一种设计模式。<br>
在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。<br>
请求在这个链上传递，直到链上的某一个对象决定处理此请求。<br>
发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>
</blockquote>
<h4 id="例题：-8">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.某OA系统需要提供一个假条审批的模块，如果员工请假天数小于3天，主任可以审批该假条；如果员工请假天数大于等于3天，小于10天，经理可以审批；如果员工请假天数大于等于10天，小于30天，总经理可以审批；如果超过30天，总经理也不能审批，提示相应的拒绝信息。如果假条审批使用模式来进行设计，可以使用（）模式。</span><br></pre></td></tr></table></figure>
<h3 id="8-装饰者模式">8.装饰者模式</h3>
<blockquote>
<p>23种设计模式之一，英文叫Decorator Pattern，又叫装饰者模式。装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
</blockquote>
<h4 id="例题：-9">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.系统中的文本显示类（TextView）和图片显示类（PictureView）都继承了组件类（Component），分别显示文本和图片内容，现需要构造带有滚动条、或者带有黑色边框、或者既有滚动条又有黑色边框的文本显示控件和图片显示控件，但希望最多只增加三个类，（）设计模式可以实现该目的。</span><br></pre></td></tr></table></figure>
<h3 id="9-享元模式">9.享元模式</h3>
<blockquote>
<p>通过共享以便有效的支持大量细颗粒对象。</p>
</blockquote>
<h4 id="例题：-10">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 共享网络设备模拟：很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发。共享网络设备可以使用（）模拟共享网络设备的设计原理。</span><br></pre></td></tr></table></figure>
<h3 id="10-外观模式">10.外观模式</h3>
<blockquote>
<p>为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<h3 id="11-代理模式">11.代理模式</h3>
<blockquote>
<p>为其他对象提供一个代理以控制对这个对象的访问。</p>
</blockquote>
<h3 id="12-工厂方法模式">12.工厂方法模式</h3>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类。(工厂方法模式：客户必须清楚地指出想获取哪种产品；由接口的子类负责获取产品 )</p>
</blockquote>
<h3 id="13-访问者模式">13.访问者模式</h3>
<blockquote>
<p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某高校奖励审批系统可以实现教师奖励和学生奖励的审批(AwardCheck)，如果教师发表论文数超过10篇或者学生论文超过2篇可以评选科研奖，如果教师教学反馈分大于等于90分或者学生平均成绩大于等于90分可以评选成绩优秀奖。奖励审批系统可以使用（）设计该系统，以判断候选人集合中的教师或学生是否符合某种获奖要求。</span><br></pre></td></tr></table></figure>
<h3 id="14-单例模式">14.单例模式</h3>
<blockquote>
<p>单例对于不频繁创建和销毁的对象只会增加系统开支，因为它一直存在，但是对于频繁创建和销毁的却可以在一定程度上减少开支。</p>
</blockquote>
<h3 id="15-策略模式">15.策略模式</h3>
<blockquote>
<p>策略模式（Strategy）-定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<h3 id="16-建造者模式">16.建造者模式</h3>
<blockquote>
<p>建造者模式是设计模式的一种，又叫做生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<h4 id="例题：-11">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.KFC套餐一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。可以使用（)描述KFC如何创建套餐。</span><br></pre></td></tr></table></figure>
<h3 id="17-简单工厂模式">17.简单工厂模式</h3>
<blockquote>
<p>当客户获取产品时，工厂模式作为获取产品的接口。由接口直接负责获取产品</p>
</blockquote>
<h3 id="18-简单工厂模式">18.简单工厂模式</h3>
<blockquote>
<p>抽象工厂模式：客户不知道其想获取哪种产品；由接口中判断调用哪个子类，通过子类获取产品。</p>
</blockquote>
<h3 id="19-桥接模式">19.桥接模式</h3>
<blockquote>
<p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低 抽象和实现这两个可变维度的耦合度。</p>
</blockquote>
<h3 id="20-组合模式">20.组合模式</h3>
<blockquote>
<p>将对象组合成树形结构以表示部分和整体的层次结构</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">模板与泛型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-11 08:31:21" itemprop="dateCreated datePublished" datetime="2022-08-11T08:31:21+08:00">2022-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-12 11:17:13" itemprop="dateModified" datetime="2022-08-12T11:17:13+08:00">2022-08-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>第十六章 模板和泛型编程</h1>
<ul>
<li>面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。
<ul>
<li>OOP能处理类型在程序运行之前都未知的情况；</li>
<li>泛型编程中，在编译时就可以获知类型。</li>
</ul>
</li>
</ul>
<h2 id="定义模板">定义模板</h2>
<ul>
<li><strong>模板</strong>：模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</li>
<li><strong>编写一个函数来比较两个值:</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string&amp; v1, <span class="type">const</span> string&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; v1, <span class="type">const</span> <span class="type">double</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两个函数基本相同，只有参数类型不同。</li>
<li><strong>可以修改为：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2) &#123;</span><br><span class="line">    if(v1 &lt; v2) return -1;</span><br><span class="line">    if(v2 &lt; v1) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>template后跟一个<code>模板参数列表(以逗号分隔的一个或多个模板参数的列表)</code>,例如：<code>template &lt;typename T1, typename T2&gt;</code></li>
<li>compare函数声明了<code>T类型参数</code>，T表示的实际类型则在编译时根据compare的使用情况确定。</li>
</ul>
<h2 id="实例化函数模板">实例化函数模板</h2>
<ul>
<li>模板类型参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// √，返回类型和参数类型一致</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ×，U之前必须加上class 或者 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// √，模板参数列表中，typename 和 class没有什么不同，typename更清楚的指出随后的是个类型名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">U</span>&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非类型模板参数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span><br><span class="line"><span class="comment">// 如果是（*p1) 就是数组指针，（&amp;p1)就是数组引用， &amp;p1[N] 引用数组， *p1[N]指针数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用compare(“h1”, “mom”)调用时，编译器使用字面常量大小代替N和M，用于实例化模板，编译器会在一个字符串后加个’\0’做为终结符。</li>
<li>即<code>int compare(const char (&amp;p1)[3]</code>, <code>const char (&amp;p2)[4]</code>。</li>
</ul>
<h2 id="inline-和-constexpr">inline 和 constexpr</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// √， inline 跟在模板参数列表后</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// ×，inline位置不正确</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="编写类型无关的代码">编写类型无关的代码</h2>
<ul>
<li>compare 说明了编写泛型代码的两个重要原则：
<ul>
<li>模板中的函数参数是const&amp;。</li>
<li>函数体的条件判断仅使用&lt;比较运算。</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数参数是const&amp;，保证函数可以用于不能拷贝的类型，如果compare用于处理大对象，可以使函数运行更快。<br>
只使用&lt;运算符，降低了compare对要处理的类型的要求。这些类型必须支持&lt;，但不必支持&gt;。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="comment">// 即使使用指针也正确的compare版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// C++ 提供的比较函数</span></span><br><span class="line">    <span class="comment">/// less&lt;type&gt;()    -&gt;   从小到大排序 &lt;</span></span><br><span class="line">    <span class="comment">/// grater&lt;type&gt;()  -&gt;   从大到小排序 &gt;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">less</span>&lt;T&gt;()(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">less</span>&lt;T&gt;()(v2, v1)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你认为接受一个数组实参的标准库函数begin和end是如何工作的？定义你自己版本的begin和end</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">Array* <span class="title">begin</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">Array* <span class="title">end</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr + N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写一个 constexpr 模版，返回给定数组的大小。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Array* <span class="title">begin</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板">类模板</h2>
<blockquote>
<p>typedef -&gt; 取别名，typename（class) -&gt; 类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="comment">// C++语言默认情况下，假定通过作用域运算符访问的名字不是类型，所以当我们要访问的是类型时候，必须显示的告诉编译器这是一个类型</span></span><br><span class="line">    <span class="comment">// typedef创建了存在类型的别名，而typename告诉编译器std::vector&lt;T&gt;::size_type是一个类型而不是一个成员。</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="comment">// initializer_list对象中的元素是const&amp;,元素的类型一致</span></span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line">    <span class="comment">// Blob中的元素数目</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">pop_back</span>();</span><br><span class="line">    T&amp; <span class="built_in">back</span>();</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string&amp; msg) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在main函数中定义：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Blob&lt;<span class="type">int</span>&gt; ia;</span><br><span class="line">    Blob&lt;<span class="type">int</span>&gt; ia2 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ia和ia2使用特定类型版本的Blob<int>, 编译器会实例化出一个与下方定义等价的类：</int></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;<span class="type">int</span>&gt;::size_type size_type;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="comment">// initializer_list对象中的元素是const&amp;,元素的类型一致</span></span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;<span class="type">int</span>&gt; il);</span><br><span class="line">    <span class="comment">// Blob中的元素数目</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> &amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="type">int</span>&amp; <span class="built_in">back</span>();</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[] (size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string&amp; msg) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每当编译器从Blob模板实例化出一个类，会重写Blob模板，将模板参数T的每个实例替换为给定的模板实例，这里是int。</p>
</blockquote>
<h2 id="在模板作用域中引用模板类型">在模板作用域中引用模板类型</h2>
<ul>
<li>std::shared_ptr&lt;std::vector<T>&gt; data; data使用了两个模板 shared_ptr 和 vector。</T></li>
<li>使用了Blob类型参数来声明data是一个shared_ptr的实例，shared_ptr指向一个保存类型为T的对象的vector实例。</li>
<li>当我们实例化一个特定类型的Blob，例如：Blob<string> -&gt; std::shared_ptr&lt;std::vector<string>&gt; data。</string></string></li>
</ul>
<h2 id="类模板的成员函数">类模板的成员函数</h2>
<ul>
<li>一般类的成员函数  return-type A :: member-name(parm-list)</li>
<li>对应的Blob 成员：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">return-type Blob :: member-name(parm-list)</span><br></pre></td></tr></table></figure>
<h2 id="类的实现-通过编译">类的实现(通过编译)</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// constructors</span></span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of elements in the Blob</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span>      <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t)); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// element access</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span> [](size_type i) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">	<span class="comment">// throw msg if data[i] isn&#x27;t valid</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructors</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>() : <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) :</span><br><span class="line"><span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string &amp;msg) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Blob&lt;T&gt;::<span class="built_in">back</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span> [](size_type i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if i is too big, check function will throw, preventing access to a nonexistent element</span></span><br><span class="line">	<span class="built_in">check</span>(i, <span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span> [](size_type i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if i is too big, check function will throw, preventing access to a nonexistent element</span></span><br><span class="line">	<span class="built_in">check</span>(i, <span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Blob-Ptr类">Blob_Ptr类</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Blob.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> ==&lt;T&gt;</span><br><span class="line">	(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; &lt;T&gt;</span><br><span class="line">		(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, std::<span class="type">size_t</span> sz = <span class="number">0</span>) :</span><br><span class="line">		<span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (*p)[curr];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prefix</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// postfix</span></span><br><span class="line">	BlobPtr <span class="keyword">operator</span> ++(<span class="type">int</span>);</span><br><span class="line">	BlobPtr <span class="keyword">operator</span> --(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// returns  a shared_ptr to the vector if the check succeeds</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt;</span><br><span class="line">		<span class="built_in">check</span>(std::<span class="type">size_t</span>, <span class="type">const</span> std::string&amp;) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">	std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;</span><br><span class="line">	std::<span class="type">size_t</span> curr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefix ++</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if curr already points past the end of the container, can&#x27;t increment it</span></span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot;increment past end of StrBlob&quot;</span>);</span><br><span class="line">	++curr;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefix --</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> --()</span><br><span class="line">&#123;</span><br><span class="line">	--curr;</span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot;decrement past begin of BlobPtr&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// postfix ++</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> ++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postfix --</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> --(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BlobPtr&lt;T&gt; &amp;lhs, <span class="type">const</span> BlobPtr&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lhs.wptr.<span class="built_in">lock</span>() != rhs.wptr.<span class="built_in">lock</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ptrs to different Blobs!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lhs.i == rhs.i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> BlobPtr&lt;T&gt; &amp;lhs, <span class="type">const</span> BlobPtr&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lhs.wptr.<span class="built_in">lock</span>() != rhs.wptr.<span class="built_in">lock</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ptrs to different Blobs!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lhs.i &lt; rhs.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认模板实参">默认模板实参</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2, F f = <span class="built_in">F</span>()) &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(v1,v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(v2,v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制实例化">控制实例化</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>declaration是一个类或函数声明，将其中所有模板参数换成模板实参</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;; <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当编译器遇到extern模板声明时，不会在本文件中生成实例化代码。将一个实例化声明成extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义)。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
</blockquote>
<h2 id="remove-reference">remove_reference</h2>
<blockquote>
<p>我们可以使用remove_reference获取元素类型。remove_refrence&lt;decltype(*beg)&gt;::type</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_refrence&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用折叠">引用折叠</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img1.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img2.PNG" alt></p>
<ul>
<li>即 X&amp; &amp;（引用的引用）, X&amp; &amp;&amp; (引用的右值引用), X&amp;&amp; &amp;(右值引用的引用)都折叠成X&amp;（X的引用）</li>
<li>类型X&amp;&amp; &amp;&amp;（右值引用的右值引用）折叠成X&amp;&amp;(X的右值引用)</li>
</ul>
<h2 id="std-move">std::move</h2>
<ul>
<li>定义：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>move的函数参数T&amp;&amp;是一个指向模板类型参数的右值引用。通过引用折叠,此参数可以和任何类型的实参匹配。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">string s1(&quot;hi!&quot;), s2;</span><br><span class="line">// 传入string构造函数的右值结果，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型（&amp;）。</span><br><span class="line">// T -&gt; string</span><br><span class="line">// remove_reference用string实例化</span><br><span class="line">// remove_reference&lt;string&gt;::type -&gt; string</span><br><span class="line">// move 返回类型是string&amp;&amp;</span><br><span class="line">// move的函数参数t的类型为string&amp;&amp;</span><br><span class="line">// 即string&amp;&amp; move(string&amp;&amp; t)</span><br><span class="line">// static_cast&lt;string&amp;&amp;&gt;(t), 不需要转换。</span><br><span class="line">s2 = std::move(string(&quot;bye!&quot;)); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 传入一个左值,所以T是个引用</span><br><span class="line">// T -&gt; string&amp; </span><br><span class="line">// remove_reference用string&amp;实例化</span><br><span class="line">// remove_reference&lt;string&amp;&gt;::type -&gt; string</span><br><span class="line">// move 返回类型是string&amp;&amp;</span><br><span class="line">// move的函数参数t的类型为string&amp; &amp;&amp;,会折叠为string&amp;</span><br><span class="line">// 即string&amp;&amp; move(string&amp; t)</span><br><span class="line">//  static_cast&lt;string&amp;&amp;&gt;(t), t为string&amp;, cast将其转换为string&amp;&amp;</span><br><span class="line">s2 = std::move(s1);</span><br></pre></td></tr></table></figure>
<h2 id="转发">转发</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i); <span class="comment">// f改变了实参i</span></span><br><span class="line">    <span class="built_in">flip1</span>(f, j, <span class="number">42</span>); <span class="comment">// 通过flip1调用f不会改变实参j</span></span><br><span class="line">    cout &lt;&lt; j &lt;&lt; endl &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int,而非int&amp;。因此，flip1调用会实例化为<code>void flip1(void(*fcn)(int, int&amp;), int t1, int t2);</code><br>
j的值被copy到t1。f中的引用参数被绑定带t1,而非j,从而其改变不会影响j。</p>
</blockquote>
<ul>
<li>如果我们将函数参数定义成T1&amp;&amp; 和 T2&amp;&amp;, 通过引用折叠，就可以保存翻转实参的左值，右值属性。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>&amp;&amp; v1, <span class="type">int</span>&amp;&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i);</span><br><span class="line">    <span class="built_in">flip2</span>(f, j, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">flip2</span>(g, i, <span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img3.PNG" alt></p>
<h2 id="在调用中使用std-forward保持类型信息">在调用中使用std::forward保持类型信息</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(T &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传入右值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传入左值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp; &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也就是：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img4.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img5.PNG" alt></p>
<ul>
<li>最后实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>&amp;&amp; v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i);</span><br><span class="line">    <span class="built_in">flip</span>(f, j, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">flip</span>(g, i, <span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写重载模板">编写重载模板</h2>
<ul>
<li>多个可行模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; string*</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T* t) T -&gt; string</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(&amp;s) &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> string* sp = &amp;s;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; string*</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T* t) T -&gt; const string</span></span><br><span class="line">    <span class="comment">// 调用更特例化版本string debug_rep(T* t)</span></span><br><span class="line">    <span class="comment">// 因为string debug_rep(const T&amp; t)本质上可以用于任何类型，后者只能用于指针类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(sp) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非模板和模板重载</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(s) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在本例中，两个函数具有相同的参数列表，因此，显然两者提供同样好的匹配。但是，编译器会选择非模板版本。当存在多个同样好的函数模板时，编译器选择最特例化的版本，处于相同的原因，一个非模板函数比一个函数模板更好。</p>
</blockquote>
<h2 id="重载模板和类型转换">重载模板和类型转换</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果希望将字符指针按string处理,可以定义另外两个非模板重载版本</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">debug_rep</span>(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">debug_rep</span>(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; char[10]</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T *p) T -&gt; const char</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const string&amp; s) const char* 到 string 的转换</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变参数模板">可变参数模板</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;  ... rest)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl; <span class="comment">// 类型参数的数目</span></span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(rest) &lt;&lt; endl; <span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    string s = <span class="string">&quot;how now brown cow&quot;</span>;</span><br><span class="line">    <span class="built_in">foo</span>(i, s, <span class="number">42</span>, d);</span><br><span class="line">    <span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    <span class="built_in">foo</span>(d, s);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写可变参数函数模板">编写可变参数函数模板</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... rest)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>; <span class="comment">// 递归调用打印其他实参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, s = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">print</span>(cout, i, s, <span class="number">42</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包扩展">包扩展</h2>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img6.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img7.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img8.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img9.PNG" alt></p>
<h2 id="模板特例化">模板特例化</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个版本;可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 第二个版本；处理字符串字面常量</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有当传递给compare一个字符串字面常量或者一个数组时，编译器才会调用接受两个非类型模板参数的版本。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span>;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);        <span class="comment">// 调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);   <span class="comment">// 调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义函数模板特例化</li>
</ul>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img10.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img11.PNG" alt></p>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">访问控制与继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-10 10:52:54 / 修改时间：14:25:38" itemprop="dateCreated datePublished" datetime="2022-08-10T10:52:54+08:00">2022-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>C++ primer 第15章 面向对象程序设计</h1>
<h2 id="访问控制和继承">访问控制和继承</h2>
<p><img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img1.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img2.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img3.PNG" alt></p>
<blockquote>
<p>基类对象不能访问基类的peotected,private成员<br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_qx.jpg" alt></p>
</blockquote>
<p><img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img4.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img5.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img6.PNG" alt></p>
<blockquote>
<p>只有public继承的时候才能使用派生类向基类的转换</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Willson-Xbort"
      src="/images/ico.jpg">
  <p class="site-author-name" itemprop="name">Willson-Xbort</p>
  <div class="site-description" itemprop="description">none</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wilson-xbort" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wilson-xbort" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Willson-Xbort</span>

  <!-- after add-->
  <!---->
</div>





        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
