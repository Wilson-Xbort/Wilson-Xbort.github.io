<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Gelasio:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wilson-xbort.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="none">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://wilson-xbort.github.io/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="none">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Willson-Xbort">
<meta property="article:tag" content="Hexo, NexT">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wilson-xbort.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

  <!--此处为建站时间 -->
  <!--<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("09/24/2018 23:45:01");
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML ="(ㆆᴗㆆ)本弱已菜菜的存活了"+dnum+"&thinsp;天"; 
        document.getElementById("times").innerHTML = hnum + "&thinsp;时" + mnum + "&thinsp;分" + snum + "&thinsp;秒"; 
    } 
  setInterval("createtime()",250);-->


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/29/leetcode-%E5%91%A8%E8%B5%9B308/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/leetcode-%E5%91%A8%E8%B5%9B308/" class="post-title-link" itemprop="url">leetcode 周赛308</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-29 10:15:44 / 修改时间：20:19:34" itemprop="dateCreated datePublished" datetime="2022-08-29T10:15:44+08:00">2022-08-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>Leetcode 周赛308复盘</h1>
<h2 id="1-和有限的最长子序列">1. 和有限的最长子序列</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。</span><br><span class="line"></span><br><span class="line">返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度  。</span><br><span class="line"></span><br><span class="line">子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-4">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,2,1], queries = [3,10,21]</span><br><span class="line">输出：[2,3,4]</span><br><span class="line">解释：queries 对应的 answer 如下：</span><br><span class="line">- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。</span><br><span class="line">- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。</span><br><span class="line">- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-4">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,4,5], queries = [1]</span><br><span class="line">输出：[0]</span><br><span class="line">解释：空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。</span><br></pre></td></tr></table></figure>
<h3 id="解析：">解析：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 关键字： 子序列，求和</span><br><span class="line">2. 要求的和 与数组元素在数组中的顺序无关 =&gt; 先对数组排序</span><br><span class="line">3. 前缀和 ： 前缀和就是从位置1到位置i这个区间内的所有的数字之和。</span><br><span class="line">4. 循环遍历</span><br></pre></td></tr></table></figure>
<h3 id="代码：-4">代码：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 求前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queries[i] &gt;= nums[j])</span><br><span class="line">                    p++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-给你一个包含若干星号-的字符串-s-。">2.给你一个包含若干星号 * 的字符串 s 。</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在一步操作中，你可以：</span><br><span class="line"></span><br><span class="line">    选中 s 中的一个星号。</span><br><span class="line">    移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。</span><br><span class="line"></span><br><span class="line">返回移除 所有 星号之后的字符串。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">    生成的输入保证总是可以执行题面中描述的操作。</span><br><span class="line">    可以证明结果字符串是唯一的。</span><br></pre></td></tr></table></figure>
<h3 id="示例1-2">示例1:</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;leet**cod*e&quot;</span><br><span class="line">输出：&quot;lecoe&quot;</span><br><span class="line">解释：从左到右执行移除操作：</span><br><span class="line">- 距离第 1 个星号最近的字符是 &quot;leet**cod*e&quot; 中的 &#x27;t&#x27; ，s 变为 &quot;lee*cod*e&quot; 。</span><br><span class="line">- 距离第 2 个星号最近的字符是 &quot;lee*cod*e&quot; 中的 &#x27;e&#x27; ，s 变为 &quot;lecod*e&quot; 。</span><br><span class="line">- 距离第 3 个星号最近的字符是 &quot;lecod*e&quot; 中的 &#x27;d&#x27; ，s 变为 &quot;lecoe&quot; 。</span><br><span class="line">不存在其他星号，返回 &quot;lecoe&quot; 。</span><br></pre></td></tr></table></figure>
<h3 id="示例2-2">示例2:</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;erase*****&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：整个字符串都会被移除，所以返回空字符串。</span><br></pre></td></tr></table></figure>
<h3 id="解析：-2">解析：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 使用栈将非*的元素压入栈中</span><br><span class="line">2. 遇到*，出栈一个元素，如果栈为空，直接返回 &quot;&quot;</span><br><span class="line">3. 反转字符串 reserve</span><br></pre></td></tr></table></figure>
<h3 id="代码：-5">代码：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">string removeStars(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        stack&lt;char&gt; ss;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if(s[i] != &#x27;*&#x27;) ss.push(s[i]);</span><br><span class="line">            else &#123;</span><br><span class="line">                if(!ss.empty()) </span><br><span class="line">                    ss.pop();</span><br><span class="line">                </span><br><span class="line">                else </span><br><span class="line">                    return &quot;&quot;;  </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        while(!ss.empty()) &#123;</span><br><span class="line">            res += ss.top();</span><br><span class="line">            ss.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-收集垃圾的最少总时间">3.收集垃圾的最少总时间</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从 0 开始的字符串数组 garbage ，其中 garbage[i] 表示第 i 个房子的垃圾集合。garbage[i] 只包含字符 &#x27;M&#x27; ，&#x27;P&#x27; 和 &#x27;G&#x27; ，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 一 单位的任何一种垃圾都需要花费 1 分钟。</span><br><span class="line"></span><br><span class="line">同时给你一个下标从 0 开始的整数数组 travel ，其中 travel[i] 是垃圾车从房子 i 行驶到房子 i + 1 需要的分钟数。</span><br><span class="line"></span><br><span class="line">城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 0 出发，按顺序 到达每一栋房子。但它们 不是必须 到达所有的房子。</span><br><span class="line"></span><br><span class="line">任何时刻只有 一辆 垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 不能 做任何事情。</span><br><span class="line"></span><br><span class="line">请你返回收拾完所有垃圾需要花费的 最少 总分钟数。</span><br></pre></td></tr></table></figure>
<h3 id="示例1-3">示例1:</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：garbage = [&quot;G&quot;,&quot;P&quot;,&quot;GP&quot;,&quot;GG&quot;], travel = [2,4,3]</span><br><span class="line">输出：21</span><br><span class="line">解释：</span><br><span class="line">收拾纸的垃圾车：</span><br><span class="line">1. 从房子 0 行驶到房子 1</span><br><span class="line">2. 收拾房子 1 的纸垃圾</span><br><span class="line">3. 从房子 1 行驶到房子 2</span><br><span class="line">4. 收拾房子 2 的纸垃圾</span><br><span class="line">收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。</span><br><span class="line">收拾玻璃的垃圾车：</span><br><span class="line">1. 收拾房子 0 的玻璃垃圾</span><br><span class="line">2. 从房子 0 行驶到房子 1</span><br><span class="line">3. 从房子 1 行驶到房子 2</span><br><span class="line">4. 收拾房子 2 的玻璃垃圾</span><br><span class="line">5. 从房子 2 行驶到房子 3</span><br><span class="line">6. 收拾房子 3 的玻璃垃圾</span><br><span class="line">收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。</span><br><span class="line">由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。</span><br><span class="line">所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-5">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：garbage = [&quot;MMM&quot;,&quot;PGM&quot;,&quot;GP&quot;], travel = [3,10]</span><br><span class="line">输出：37</span><br><span class="line">解释：</span><br><span class="line">收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。</span><br><span class="line">收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。</span><br><span class="line">收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。</span><br><span class="line">总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。</span><br></pre></td></tr></table></figure>
<h3 id="解题思路：">解题思路：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 只要算出收集所有垃圾需要的时间 =&gt; garbage 所有字符串长度之和</span><br><span class="line">2. 考虑在房子之间移动的时间/距离之和 （比如M，只需要找到最后出现的下标就行)</span><br><span class="line">3. 加起来就是答案</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">garbageCollection</span><span class="params">(vector&lt;string&gt;&amp; garbage, vector&lt;<span class="type">int</span>&gt;&amp; travel)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = garbage.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; c : garbage[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">find</span>(c) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    s.<span class="built_in">insert</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 收集所有垃圾需要的时间</span></span><br><span class="line">            res += garbage[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// 最后出现的下标 * travel[下标 - 1]</span></span><br><span class="line">            res += i &gt; <span class="number">0</span> ? s.<span class="built_in">size</span>() * travel[i - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-给定条件下构造矩阵">4.给定条件下构造矩阵</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给你一个 正 整数 k ，同时给你：</span><br><span class="line"></span><br><span class="line">    一个大小为 n 的二维整数数组 rowConditions ，其中 rowConditions[i] = [abovei, belowi] 和</span><br><span class="line">    一个大小为 m 的二维整数数组 colConditions ，其中 colConditions[i] = [lefti, righti] 。</span><br><span class="line"></span><br><span class="line">两个数组里的整数都是 1 到 k 之间的数字。</span><br><span class="line"></span><br><span class="line">你需要构造一个 k x k 的矩阵，1 到 k 每个数字需要 恰好出现一次 。剩余的数字都是 0 。</span><br><span class="line"></span><br><span class="line">矩阵还需要满足以下条件：</span><br><span class="line"></span><br><span class="line">    对于所有 0 到 n - 1 之间的下标 i ，数字 abovei 所在的 行 必须在数字 belowi 所在行的上面。</span><br><span class="line">    对于所有 0 到 m - 1 之间的下标 i ，数字 lefti 所在的 列 必须在数字 righti 所在列的左边。</span><br><span class="line"></span><br><span class="line">返回满足上述要求的 任意 矩阵。如果不存在答案，返回一个空的矩阵。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-5">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]</span><br><span class="line">输出：[[3,0,0],[0,0,1],[0,2,0]]</span><br><span class="line">解释：上图为一个符合所有条件的矩阵。</span><br><span class="line">行要求如下：</span><br><span class="line">- 数字 1 在第 1 行，数字 2 在第 2 行，1 在 2 的上面。</span><br><span class="line">- 数字 3 在第 0 行，数字 2 在第 2 行，3 在 2 的上面。</span><br><span class="line">列要求如下：</span><br><span class="line">- 数字 2 在第 1 列，数字 1 在第 2 列，2 在 1 的左边。</span><br><span class="line">- 数字 3 在第 0 列，数字 2 在第 1 列，3 在 2 的左边。</span><br><span class="line">注意，可能有多种正确的答案。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-6">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。</span><br><span class="line">没有符合条件的矩阵存在，所以我们返回空矩阵。</span><br></pre></td></tr></table></figure>
<h3 id="提示1：">提示1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数字之间的约束只发生在行与行、列于列，而行与列之间没有任何约束。</span><br><span class="line"></span><br><span class="line">因此我们可以分别处理行与列中数字的相对顺序，如何求出这个相对顺序呢？</span><br></pre></td></tr></table></figure>
<h3 id="提示2：">提示2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序。</span><br></pre></td></tr></table></figure>
<h3 id="提示3：">提示3：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于 rowConditions，我们可以从 abovei​ 向 belowi 连一条有向边，得到一张有向图。在这张图上跑拓扑排序，得到的拓扑序就是行与行中数字的相对顺序，这样我们就知道了每一行要填哪个数字。如果得到的拓扑序长度不足 kkk，说明图中有环，无法构造，答案不存在。</span><br><span class="line"></span><br><span class="line">对 colConditions 也执行上述过程，得到每一列要填哪个数字，进而得到每个数字要填到哪一列中，这样我们就知道每一行的数字要填到哪一列了。</span><br></pre></td></tr></table></figure>
<h3 id="代码：-6">代码：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; topo_sort(int k, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; g(k);</span><br><span class="line">        vector&lt;int&gt; in_deg(k); // 入度</span><br><span class="line">        for(auto &amp;e : edges) &#123;</span><br><span class="line">            // 总共两个元素, x 在 y的上方 / 左边</span><br><span class="line">            // 顶点编号从 0 开始，方便计算</span><br><span class="line">            int x = e[0] - 1, y = e[1] - 1;</span><br><span class="line">            // 先将下边/右边的添加进图(g)中</span><br><span class="line">            g[x].push_back(y);</span><br><span class="line">            // 入度 + 1</span><br><span class="line">            ++in_deg[y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            if (in_deg[i] == 0) // 入度为0，进入队列</span><br><span class="line">                q.push(i);</span><br><span class="line">        // 使用BFS，拓扑排序和BFS原理一样，都是先从最外围的开始       </span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            int x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            order.push_back(x);</span><br><span class="line">            for(int y : g[x]) </span><br><span class="line">                if(--in_deg[y] == 0) // 入度为0，进入队列</span><br><span class="line">                q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; buildMatrix(int k, vector&lt;vector&lt;int&gt;&gt;&amp; rowConditions, vector&lt;vector&lt;int&gt;&gt;&amp; colConditions) &#123;</span><br><span class="line">        auto row = topo_sort(k, rowConditions), col = topo_sort(k, colConditions);</span><br><span class="line">        if (row.size() &lt; k || col.size() &lt; k) return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; pos(k);</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            // pos[x] 表示元素 x 应该在哪一列，这样最后的答案就知道要把 row[i] 放在哪一列了</span><br><span class="line">            pos[col[i]] = i;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans(k, vector&lt;int&gt;(k));</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            ans[i][pos[row[i]]] = row[i] + 1;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/26/307%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/26/307%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/" class="post-title-link" itemprop="url">307场周赛复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-26 12:02:17 / 修改时间：20:41:26" itemprop="dateCreated datePublished" datetime="2022-08-26T12:02:17+08:00">2022-08-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>Leetcode 第307场周赛复盘</h1>
<h2 id="1-赢得比赛需要的最少训练时长">1.赢得比赛需要的最少训练时长</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。</span><br><span class="line"></span><br><span class="line">另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。</span><br><span class="line"></span><br><span class="line">你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。</span><br><span class="line"></span><br><span class="line">击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少  energy[i] 。</span><br><span class="line"></span><br><span class="line">在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。</span><br><span class="line"></span><br><span class="line">返回击败全部 n 个对手需要训练的 最少 小时数目。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。</span><br><span class="line">按以下顺序与对手比赛：</span><br><span class="line">- 你的精力与经验都超过第 0 个对手，所以获胜。</span><br><span class="line">  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。</span><br><span class="line">- 你的精力与经验都超过第 1 个对手，所以获胜。</span><br><span class="line">  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。</span><br><span class="line">- 你的精力与经验都超过第 2 个对手，所以获胜。</span><br><span class="line">  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。</span><br><span class="line">- 你的精力与经验都超过第 3 个对手，所以获胜。</span><br><span class="line">  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。</span><br><span class="line">在比赛前进行了 8 小时训练，所以返回 8 。</span><br><span class="line">可以证明不存在更小的答案。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]</span><br><span class="line">输出：0</span><br><span class="line">解释：你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。</span><br></pre></td></tr></table></figure>
<h3 id="我的题解：">我的题解：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, vector&lt;<span class="type">int</span>&gt;&amp; energy, vector&lt;<span class="type">int</span>&gt;&amp; experience)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> energy_len = energy.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> experience_len = energy.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 经验训练次数，精力训练次数</span></span><br><span class="line">        <span class="type">int</span> exp_time_experience = <span class="number">0</span>, exp_time_energy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 训练</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; experience_len; ) &#123;</span><br><span class="line">            <span class="comment">// 必须是经验和精力严格大于敌人才能击败敌人</span></span><br><span class="line">            <span class="keyword">if</span>(initialExperience &gt; experience[i] &amp;&amp; initialEnergy &gt; energy[i]) &#123;</span><br><span class="line">                initialExperience += experience[i];</span><br><span class="line">                initialEnergy -= energy[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="comment">// 如果精力不大于敌人，我们就训练精力</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(initialEnergy - energy[i] &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                exp_time_energy++;</span><br><span class="line">                initialEnergy++;</span><br><span class="line">            &#125; <span class="comment">// 如果经验不大于敌人，我们就训练经验</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                exp_time_experience++;</span><br><span class="line">                initialExperience++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后返回经验和精力的训练次数之和</span></span><br><span class="line">        <span class="keyword">return</span> exp_time_experience + exp_time_energy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-最大回文数字">2.最大回文数字</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给你一个仅由数字（0 - 9）组成的字符串 num 。</span><br><span class="line"></span><br><span class="line">请你找出能够使用 num 中数字形成的 最大回文 整数，并以字符串形式返回。该整数不含 前导零 。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">    你 无需 使用 num 中的所有数字，但你必须使用 至少 一个数字。</span><br><span class="line">    数字可以重新排序。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-2">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;444947137&quot;</span><br><span class="line">输出：&quot;7449447&quot;</span><br><span class="line">解释：</span><br><span class="line">从 &quot;444947137&quot; 中选用数字 &quot;4449477&quot;，可以形成回文整数 &quot;7449447&quot; 。</span><br><span class="line">可以证明 &quot;7449447&quot; 是能够形成的最大回文整数。</span><br></pre></td></tr></table></figure>
<h3 id="示例2：-2">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;00009&quot;</span><br><span class="line">输出：&quot;9&quot;</span><br><span class="line">解释：</span><br><span class="line">可以证明 &quot;9&quot; 能够形成的最大回文整数。</span><br><span class="line">注意返回的整数不应含前导零。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们要考虑的情况：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路： 先构造左半部分，最后填充镜像字符串</span><br><span class="line">1. 前导 ‘0’： 比如 0000。 -&gt; 【字符串长度超过1的情况，你的第一个字母不能是0】</span><br><span class="line">2. 例如 100  ： 如果安装每次取偶数个数填左右，可能变成 010。 -&gt;【从9开始枚举到1，单独考虑0】</span><br><span class="line">3. 考虑从中间填一个字符串 -&gt; [从9开始枚举到0]</span><br><span class="line">4. 最后填充镜像字符串</span><br></pre></td></tr></table></figure>
<h1>我的题解：</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestPalindromic</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : num) cnt[c - <span class="string">&#x27;0&#x27;</span>]++;   </span><br><span class="line">        <span class="comment">// 特殊情况 0000</span></span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>] == num.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="comment">// 从9枚举到1,单独考虑0</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 找出成对的最大数字</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt[i] / <span class="number">2</span>; j++)</span><br><span class="line">                res += (i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">0</span>] / <span class="number">2</span>; i++)</span><br><span class="line">                res += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        string tmp = res;</span><br><span class="line">        <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 考虑中间填一个字符，遍历num选择最大数,[0, 9]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res += i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="感染二叉树需要的总时间">感染二叉树需要的总时间</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。</span><br><span class="line"></span><br><span class="line">每分钟，如果节点满足以下全部条件，就会被感染：</span><br><span class="line"></span><br><span class="line">    节点此前还没有感染。</span><br><span class="line">    节点与一个已感染节点相邻。</span><br><span class="line"></span><br><span class="line">返回感染整棵树需要的分钟数。</span><br></pre></td></tr></table></figure>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,5,3,null,4,10,6,9,2], start = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：节点按以下过程被感染：</span><br><span class="line">- 第 0 分钟：节点 3</span><br><span class="line">- 第 1 分钟：节点 1、10、6</span><br><span class="line">- 第 2 分钟：节点5</span><br><span class="line">- 第 3 分钟：节点 4</span><br><span class="line">- 第 4 分钟：节点 9 和 2</span><br><span class="line">感染整棵树需要 4 分钟，所以返回 4 。</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1], start = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。</span><br></pre></td></tr></table></figure>
<h3 id="题解：（没看懂）">题解：（没看懂）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int max = 0;</span><br><span class="line">    int dfs(TreeNode* root, int start, int sum) &#123;</span><br><span class="line">        // 没感染返回-1,为nullptr自然不会被感染</span><br><span class="line">        if(root == NULL) return -1;</span><br><span class="line">        if(sum == -1 &amp;&amp; root-&gt;val == start) &#123; // 本节点为感染节点</span><br><span class="line">            sum = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum != -1) &#123;</span><br><span class="line">            // 本节点已经感染，传递到子树中</span><br><span class="line">            dfs(root-&gt;left, start, sum + 1);</span><br><span class="line">            dfs(root-&gt;right, start, sum + 1);</span><br><span class="line">            if(sum &gt; max) max = sum;</span><br><span class="line">            return sum + 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int tem = dfs(root-&gt;left, start, sum);</span><br><span class="line">            if(tem != -1) &#123; // 左子树被感染，传递到右子树</span><br><span class="line">                sum = tem;</span><br><span class="line">                dfs(root-&gt;right, start, sum + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                sum = dfs(root-&gt;right, start, sum);</span><br><span class="line">                dfs(root-&gt;left, start, sum + 1);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &gt; max) max = sum;</span><br><span class="line">        if(sum != -1) return sum + 1;</span><br><span class="line">        return -1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int amountOfTime(TreeNode* root, int start) &#123;</span><br><span class="line">        // 一个节点被感染，可以分为四种方向, 本身感染，从父节点感染，从左子树感染，从右子树感染</span><br><span class="line">        dfs(root, start, -1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="找出数组的第-K-大和">找出数组的第 K 大和</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个 正 整数 k 。你可以选择数组的任一 子序列 并且对其全部元素求和。</span><br><span class="line"></span><br><span class="line">数组的 第 k 大和 定义为：可以获得的第 k 个 最大 子序列和（子序列和允许出现重复）</span><br><span class="line"></span><br><span class="line">返回数组的 第 k 大和 。</span><br><span class="line"></span><br><span class="line">子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</span><br><span class="line"></span><br><span class="line">注意：空子序列的和视作 0 。</span><br></pre></td></tr></table></figure>
<h3 id="示例1：-3">示例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,4,-2], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：所有可能获得的子序列和列出如下，按递减顺序排列：</span><br><span class="line">- 6、4、4、2、2、0、0、-2</span><br><span class="line">数组的第 5 大和是 2 。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>子序列：序列中的一个元素可选可不选。</code></p>
</blockquote>
<h3 id="示例2：-3">示例2：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,-2,3,4,-10,12], k = 16</span><br><span class="line">输出：10</span><br><span class="line">解释：数组的第 16 大和是 10 。</span><br></pre></td></tr></table></figure>
<h3 id="方法一、堆">方法一、堆</h3>
<h4 id="提示一">提示一</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">记 nums 中所有非负数的和为 sum。</span><br><span class="line"></span><br><span class="line">任意一个子序列的和，都等价于从 sum 中减去某些非负数 / 加上某些负数得到。</span><br></pre></td></tr></table></figure>
<h4 id="提示二">提示二</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将 nums 所有数取绝对值，这样可以统一成从 sum 中减去某些数。</span><br><span class="line"></span><br><span class="line">我们需要按照从小到大的顺序取出 sum 要减去的子序列，如何做到？</span><br></pre></td></tr></table></figure>
<h4 id="提示三">提示三</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将 nums 所有数取绝对值后排序，然后用最大堆来实现。</span><br></pre></td></tr></table></figure>
<h4 id="提示四">提示四</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">具体来说，最大堆维护子序列的和，以及（后续需要减去的）数字的下标 i。</span><br><span class="line"></span><br><span class="line">初始时，将 sum 和下标 0 入堆。</span><br><span class="line"></span><br><span class="line">每次弹出堆顶时，将子序列的和减去 nums[i]，并考虑是否保留 nums[i−1]，从而满足子序列每个元素「选或不选」的要求。</span><br><span class="line"></span><br><span class="line">这一做法可以不重不漏地生成所有子序列的和，再配合堆，就可以从大到小生成。</span><br><span class="line">循环 k−1k-1k−1 次后，堆顶的和就是答案。</span><br></pre></td></tr></table></figure>
<h4 id="提示五">提示五</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 1. 从最大的子序列和来考虑，那么这个序列和就是所有正数的和 sum。</span><br><span class="line"> 2. 怎么找到第二大的子序列和？从最大的子序列和中减去最小的正数或加上最大的负数。</span><br><span class="line"> 3. 为了统一操作，将负数取反，然后排序，每次取最小的数，得到的就是最小的正数或最大的负数。</span><br><span class="line"> sum 中减去它，就可以得到下一个更小的子序列和。</span><br><span class="line"> 4. 被减去的数们实际上也是组成了一个子序列。按照生成子序列的模板，就是依次对每个数，考虑</span><br><span class="line"> 选择它，还是不选择它。</span><br><span class="line"></span><br><span class="line">这样分析之后，就可以回答大家的两个问题：</span><br><span class="line"></span><br><span class="line">Q：怎么保证 pq 的顶就是答案？A：因为是用当前值最大和减去最小值，所以得到的一定是下一个略小的最大和。</span><br><span class="line">Q：保留和不保留 nums[i-1] 是不是写反了？A：是否保留指的是在被 *减去* 的子序列中是否保留此数。所以，如果不保留的话，反而是要加回来，因为它不该被从 sum 里减去。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="解法：">解法：</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">kSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;x : nums)</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) sum += x;</span><br><span class="line">            <span class="keyword">else</span> x = -x;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">long</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (--k) &#123;</span><br><span class="line">            <span class="keyword">auto</span>[sum, i] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(sum - nums[i], i + <span class="number">1</span>); <span class="comment">// 保留 nums[i-1]</span></span><br><span class="line">                <span class="keyword">if</span> (i) pq.<span class="built_in">emplace</span>(sum - nums[i] + nums[i - <span class="number">1</span>], i + <span class="number">1</span>); <span class="comment">// 不保留 nums[i-1]，把之前减去的加回来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">模拟面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 15:55:06" itemprop="dateCreated datePublished" datetime="2022-08-23T15:55:06+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-27 11:20:32" itemprop="dateModified" datetime="2022-08-27T11:20:32+08:00">2022-08-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>2022-8-23</h1>
<h2 id="1-常见的HTTP协议状态码有哪些？">1. 常见的HTTP协议状态码有哪些？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">标准回答</span><br><span class="line"></span><br><span class="line">常见的状态码有：</span><br><span class="line">    1xx代表服务器端已经接受了请求。</span><br><span class="line">    2xx代表请求已经被服务器端成功接收，最常见的有200、201状态码。</span><br><span class="line">    3xx代表路径被服务器端重定向到了一个新的URL，最常见的有301、302状态码。</span><br><span class="line">    4xx代表客户端的请求发生了错误，最常见的有401、404状态码。</span><br><span class="line">    5xx代表服务器端的响应出现了错误。 </span><br><span class="line"></span><br><span class="line">加分回答</span><br><span class="line"></span><br><span class="line">    1xx：指定客户端相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</span><br><span class="line"></span><br><span class="line">    2xx：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。</span><br><span class="line">        200（成功）：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</span><br><span class="line">        201（已创建）：请求成功并且服务器创建了新的资源。</span><br><span class="line">        202（已接受）：服务器已接受请求，但尚未处理。</span><br><span class="line">        203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源。</span><br><span class="line">        204（无内容）：服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line">        205（重置内容）：服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line">        206（部分内容）：服务器成功处理了部分 GET 请求。 </span><br><span class="line"></span><br><span class="line">    3xx：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在响应头Location字段中指明。这系列中最常见的有301、302状态码。</span><br><span class="line">        300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</span><br><span class="line">        301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class="line">        302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line">        303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class="line">        304（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line">        305（使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</span><br><span class="line">        307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 </span><br><span class="line"></span><br><span class="line">    4xx：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。</span><br><span class="line"></span><br><span class="line">        400（错误请求）：服务器不理解请求的语法。</span><br><span class="line"></span><br><span class="line">        401（未授权）：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</span><br><span class="line"></span><br><span class="line">        403（禁止）：服务器拒绝请求。</span><br><span class="line"></span><br><span class="line">        404（未找到）：服务器找不到请求的网页。</span><br><span class="line"></span><br><span class="line">        405（方法禁用）：禁用请求中指定的方法。</span><br><span class="line"></span><br><span class="line">        406（不接受）：无法使用请求的内容特性响应请求的网页。</span><br><span class="line"></span><br><span class="line">        407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class="line"></span><br><span class="line">        408（请求超时）：服务器等候请求时发生超时。</span><br><span class="line"></span><br><span class="line">        409（冲突）：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</span><br><span class="line"></span><br><span class="line">        410（已删除）：如果请求的资源已永久删除，服务器就会返回此响应。</span><br><span class="line"></span><br><span class="line">        411（需要有效长度）：服务器不接受不含有效内容长度标头字段的请求。</span><br><span class="line"></span><br><span class="line">        412（未满足前提条件）：服务器未满足请求者在请求中设置的其中一个前提条件。</span><br><span class="line"></span><br><span class="line">        413（请求实体过大）：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</span><br><span class="line"></span><br><span class="line">        414（请求的 URI 过长）：请求的 URI（通常为网址）过长，服务器无法处理。</span><br><span class="line"></span><br><span class="line">        415（不支持的媒体类型）：请求的格式不受请求页面的支持。</span><br><span class="line"></span><br><span class="line">        416（请求范围不符合要求）：如果页面无法提供请求的范围，则服务器会返回此状态代码。</span><br><span class="line"></span><br><span class="line">        417 （未满足期望值）：服务器未满足&quot;期望&quot;请求标头字段的要求。</span><br><span class="line"></span><br><span class="line">    5xx：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。</span><br><span class="line">        500（服务器内部错误）：服务器遇到错误，无法完成请求。</span><br><span class="line">        501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line">        502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line">        503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</span><br><span class="line">        504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line">        505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-简述一下C-中的四种类型转换">2.简述一下C++ 中的四种类型转换</h2>
<blockquote>
<p>const_cast 只能改变运算对象的底层const,只有const_cast能改变表达式的常量属性,将常量对象转换成非常量对象的行为，我们一般称其为&quot;去掉const性质。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对改对象进行读写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法行为。<br>
然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc); <span class="comment">// 正确：但是通过p写值是未定义的行为</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cp;</span><br><span class="line"><span class="comment">// 错误：static_cast不能转换调const性质</span></span><br><span class="line"><span class="type">char</span> *q = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);</span><br><span class="line"><span class="keyword">static_cast</span>&lt;string&gt;cp; <span class="comment">//正确：字符串字面值转换成string类型</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;string&gt;cp;  <span class="comment">// 错误：const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>static_cast: 任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) / i</span><br></pre></td></tr></table></figure>
<blockquote>
<p>reinterpret_cast：reinterpret_cast，是C++里强制类型转换符。</p>
</blockquote>
<blockquote>
<p>dynamic_cast是将一个基类对象指针（或引用）转换到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理。dynamic_cast运算符涉及到编译器的属性设置，而且牵扯到的面向对象的多态性跟程序运行时的状态也有关系，所以不能完全的使用传统的替换方式来代替。但是也因此它最常用，是最不可缺少的一个运算符。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base &amp;b;</span><br><span class="line"><span class="type">const</span> Derived &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br></pre></td></tr></table></figure>
<h2 id="3-简述C-的内存管理">3.简述C++ 的内存管理</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C++的内存分区主要有五个区：分别是代码区、全局/静态存储区、常量存储区、堆区和栈区。</span><br><span class="line">代码区：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</span><br><span class="line">全局区/静态存储区（.bss【Block Started by Symbol】 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</span><br><span class="line">常量存储区：存放的是常量，不允许修改，程序运行结束自动释放。</span><br><span class="line">栈区：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</span><br><span class="line">堆区：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</span><br></pre></td></tr></table></figure>
<h2 id="两数之和">两数之和</h2>
<blockquote>
<p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。<br>
（注：返回的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 判断哈希表里面是否有tmp</span></span><br><span class="line">        <span class="type">int</span> tmp = target - numbers[i];</span><br><span class="line">        <span class="comment">// 如果没有</span></span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(tmp) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            hash[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(hash[tmp] + <span class="number">1</span>); <span class="comment">// 索引+1</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-为什么要实现多态">C++ 为什么要实现多态?</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。需要在基类函数前加virtual。</span><br></pre></td></tr></table></figure>
<h3 id="看代码：">看代码：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;调用Father类函数&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;调用Son类函数&quot;</span> &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son1;</span><br><span class="line"></span><br><span class="line">	Father* fp = &amp;son1;</span><br><span class="line">	fp-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上图代码函数没有加virtual，导致了fp-&gt;func()最后输出父类的func，而加了virual后，按照原则：不管谁指向/引用谁，都是自动识别调子类自己的函数(调用被重写过的函数）。</p>
</blockquote>
<h2 id="虚函数的作用？">虚函数的作用？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用基类的指针指向不同的派生类的对象时，</span><br><span class="line">基类指针调用其虚成员函数，则会调用其真正指向对象的成员函数，</span><br><span class="line">而不是基类中定义的成员函数（只要派生类改写了该成员函数）。</span><br><span class="line">若不是虚函数，则不管基类指针指向的哪个派生类对象，调用时都</span><br><span class="line">会调用基类中定义的那个函数。</span><br></pre></td></tr></table></figure>
<h2 id="C-重载怎么实现？">C++ 重载怎么实现？</h2>
<h2 id="C-重写和重载的区别？">C++ 重写和重载的区别？</h2>
<blockquote>
<p>函数重载是指在 同一作用域内，可以有一组具有 相同函数名，不同参数列表 的函数，这组函数被称为重载函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">(<span class="type">long</span> a)</span> </span>&#123; .. &#125; <span class="comment">// 重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">(<span class="type">char</span> a)</span> </span>&#123; .. &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">     <span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">()</span> </span>&#123; .. &#125; <span class="comment">// 重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的使用场景">二叉树的使用场景?</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数据压缩(哈夫曼树)</span><br><span class="line">2. STL的容器(map, set) (红黑树)</span><br></pre></td></tr></table></figure>
<h2 id="堆和栈的区别？">堆和栈的区别？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 栈是系统自动分配，堆是人为申请分配。</span><br><span class="line">2. 栈获得的空间较小，堆获得的空间大。</span><br><span class="line">3. 申请效率不同，栈由系统分配，速度较快。</span><br><span class="line">4. 栈是连续空间，堆是不连续空间。</span><br><span class="line">5. 存储内容不同，栈在函数调用时，函数调用的下一条可执行语句的地址第一个进栈,</span><br><span class="line">然后函数的参数进栈，静态变量不如栈。堆是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排的。</span><br></pre></td></tr></table></figure>
<h2 id="public-private-protected-继承">public/private/protected 继承</h2>
<blockquote>
<p>C++ Primer 15.5</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">公有继承(public)、私有继承(private)、保护继承(protected)是常用的三种继承方式。　　</span><br><span class="line">1. 公有继承(public) 　　</span><br><span class="line">公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。　　</span><br><span class="line">2. 私有继承(private) 　默认的继承方式（如果缺省，默认为private继承)</span><br><span class="line">私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。　</span><br><span class="line">子类也不能转换成相应的基类，如果转换，会报错：“不允许对不可访问的基类进行转换”。</span><br><span class="line">3. 保护继承(protected) 　　</span><br><span class="line">保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。　　</span><br></pre></td></tr></table></figure>
<h2 id="C-优先队列中的less和greater">C++优先队列中的less和greater</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>
<h3 id="less源代码：">less源代码：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x&lt;y;&#125;</span><br><span class="line">  <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="less-example">less example</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// less example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// std::less</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::sort, std::includes</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> foo[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">25</span>&#125;;</span><br><span class="line">  <span class="type">int</span> bar[]=&#123;<span class="number">15</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">  std::<span class="built_in">sort</span> (foo, foo+<span class="number">5</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// 5 10 15 20 25</span></span><br><span class="line">  std::<span class="built_in">sort</span> (bar, bar+<span class="number">3</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//   10 15 20</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">includes</span> (foo, foo+<span class="number">5</span>, bar, bar+<span class="number">3</span>, std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()))</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo includes bar.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="greater源代码：">greater源代码：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">greater</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line">  <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="greater-example">greater example</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// greater example</span><br><span class="line">#include &lt;iostream&gt;     // std::cout</span><br><span class="line">#include &lt;functional&gt;   // std::greater</span><br><span class="line">#include &lt;algorithm&gt;    // std::sort</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">  int numbers[]=&#123;20,40,50,10,30&#125;;</span><br><span class="line">  std::sort (numbers, numbers+5, std::greater&lt;int&gt;());</span><br><span class="line">  for (int i=0; i&lt;5; i++)</span><br><span class="line">    std::cout &lt;&lt; numbers[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">  std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以知道less<type>()是从小到大排序，greater<type>()是从大到小排序</type></type></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在C++ STL的priority_queue中：</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt;que       -&gt;      从小到大排序</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;,less&lt;int&gt; &gt;que          -&gt;      从大到小排序</span><br></pre></td></tr></table></figure>
<h2 id="请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁-※">请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁 ※</h2>
<h3 id="死锁：">死锁：</h3>
<blockquote>
<p>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。</p>
</blockquote>
<h3 id="死锁产生的必要条件">死锁产生的必要条件</h3>
<blockquote>
<ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放；</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放；</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，···，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。</li>
</ul>
</blockquote>
<h3 id="死锁产生的原因">死锁产生的原因</h3>
<blockquote>
<p>竞争资源 - 进程间推进顺序非法</p>
</blockquote>
<h3 id="怎么预防死锁">怎么预防死锁</h3>
<blockquote>
<p>有序资源分配法 - 银行家算法</p>
</blockquote>
<h2 id="x-x-1-x-1-x-哪个效率高？">x = x + 1, x += 1, x++ 哪个效率高？</h2>
<blockquote>
<p>x = x + 1 执行效率如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 读取右x的地址</span><br><span class="line">2. x + 1</span><br><span class="line">3. 读取左x的地址</span><br><span class="line">4.将右表达式的值传递给左x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x += 1 执行效率如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 读取x的地址</span><br><span class="line">2. x + 1</span><br><span class="line">3. 将得到的值传给x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x++</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 读取x的地址</span><br><span class="line">2. 自增操作</span><br></pre></td></tr></table></figure>
<h2 id="const-和-define-的区别">const 和 #define 的区别</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. #define 只在预编译阶段起作用, const在编译、运行的时候起作用</span><br><span class="line">2. #define 只是简单的字符串替换，没有类型检查。而const有对应的数据类型，需要进行类型检查。</span><br><span class="line">3. #define 只是进行展开,有多少地方使用就替换多少次，它定义的宏常量在内存中有多个备份，const定义的只读变量在程序运行中只有一份备份。</span><br><span class="line">4. #define 是不能进行调试的在预编译阶段就替换了，const常量可以进行调试</span><br></pre></td></tr></table></figure>
<h2 id="new-和-malloc的区别和联系">new 和 malloc的区别和联系</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. new 是 C++中的操作符，malloc是c中的一个函数</span><br><span class="line">2. new不只是分配内存，还会调用类的构造函数，同理，delete会调用类的析构函数，malloc则只会分配内存，不会进行初始化类成员的工作，free也不会调用析构函数。</span><br><span class="line">3. new的指针是直接带着类型信息的，malloc返回的是void*</span><br><span class="line">4. new，delete || new [], delete[] || malloc, free配套使用</span><br></pre></td></tr></table></figure>
<h2 id="构造函数和析构函数可不可以为虚函数？为什么？">构造函数和析构函数可不可以为虚函数？为什么？</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">析构函数可以是虚函数，构造函数不可以。因为构造函数有特殊的工作，它处在对象创建初期，先调用基类的构造函数，再按照继承顺序调用派生类的构造函数。</span><br><span class="line">而析构函数和构造函数恰恰相反，从最后的派生类开始，依次到向上到基类，析构函数确切知道它从哪个类派生而来。</span><br><span class="line"></span><br><span class="line">如果某个类不包含虚函数,一般是表示它将不作为一个基类来使用,当一个类不作为基类使用时，析构函数没必要声明为虚函数，以防虚函数表指针浪费空间。</span><br></pre></td></tr></table></figure>
<h2 id="strcpy-和-memcpy的区别">strcpy 和 memcpy的区别</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）复制的内容不同，strcpy只能用于字符串copy，memcpy可以复制任何类型的内容，用途更广。</span><br><span class="line">2）复制的方法不同，strcpy不需要指定长度，遇到&#x27;\0&#x27;才会结束，容易溢出。memcpy需要设置复制长度。</span><br><span class="line">3）用途不同。一般复制字符串才会使用strcpy，其他类型使用memcpy</span><br></pre></td></tr></table></figure>
<h2 id="如何限制一个类对象只在堆-栈）上分配空间？">如何限制一个类对象只在堆(栈）上分配空间？</h2>
<blockquote>
<p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
</blockquote>
<blockquote>
<p>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;</p>
</blockquote>
<blockquote>
<p>动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A();</p>
</blockquote>
<h3 id="1-类对象只建立在堆上">1.类对象只建立在堆上</h3>
<blockquote>
<p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
</blockquote>
<h4 id="解决方法1：">解决方法1：</h4>
<blockquote>
<p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="该方法存在的问题：">该方法存在的问题：</h4>
<blockquote>
<p>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。</p>
</blockquote>
<blockquote>
<p>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
</blockquote>
<h4 id="解决方法2：">解决方法2：</h4>
<blockquote>
<p>构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static A *create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-类对象只建立在栈上">2.类对象只建立在栈上</h3>
<blockquote>
<p>解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    void* operator new(size_t t)&#123;&#125;     // 注意函数的第一个参数和返回值都是固定的  </span><br><span class="line">    void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载delete  </span><br><span class="line">public:  </span><br><span class="line">    A()&#123;&#125;  </span><br><span class="line">    ~A()&#123;&#125;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重载类的new操作符，使重载后的new操作符的功能为空。这样就使外层程序无法在堆上分配对象，只可以在栈上分配。</p>
</blockquote>
<h2 id="C-程序编译过程">C++ 程序编译过程</h2>
<h3 id="1-编译预处理">1. 编译预处理</h3>
<blockquote>
<p>编译预处理：处理以 # 开头的指令；</p>
</blockquote>
<h3 id="2-编译、优化">2. 编译、优化</h3>
<blockquote>
<p>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；</p>
</blockquote>
<h3 id="3-汇编">3. 汇编</h3>
<blockquote>
<p>汇编：将汇编代码 .s 翻译成机器指令 .o 文件；</p>
</blockquote>
<h3 id="4-链接">4. 链接</h3>
<blockquote>
<p>链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
</blockquote>
<p><img src="/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/mock_interview_img1.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">链接分为两种：</span><br><span class="line"></span><br><span class="line">    静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</span><br><span class="line">    动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。</span><br><span class="line">    在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</span><br><span class="line"></span><br><span class="line">二者的优缺点：</span><br><span class="line"></span><br><span class="line">    静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可</span><br><span class="line">    执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</span><br><span class="line">    动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</span><br></pre></td></tr></table></figure>
<h2 id="栈和堆的区别">栈和堆的区别</h2>
<blockquote>
<p>申请方式：栈是系统自动分配，堆是程序员主动申请。</p>
</blockquote>
<blockquote>
<p>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</p>
</blockquote>
<blockquote>
<p>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</p>
</blockquote>
<blockquote>
<p>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</p>
</blockquote>
<blockquote>
<p>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</p>
</blockquote>
<h2 id="变量的区别">变量的区别</h2>
<blockquote>
<p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
</blockquote>
<h3 id="从作用域看：">从作用域看：</h3>
<blockquote>
<p>全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p>
</blockquote>
<blockquote>
<p>静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p>
</blockquote>
<blockquote>
<p>局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p>
</blockquote>
<blockquote>
<p>静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</p>
</blockquote>
<h3 id="从分配内存空间看：">从分配内存空间看：</h3>
<blockquote>
<p>静态存储区：全局变量，静态局部变量，静态全局变量。</p>
</blockquote>
<blockquote>
<p>栈：局部变量。</p>
</blockquote>
<h2 id="全局变量定义在头文件中有什么问题？">全局变量定义在头文件中有什么问题？</h2>
<blockquote>
<p>如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>
</blockquote>
<h3 id="解决方法：">解决方法：</h3>
<blockquote>
<p>1）在头文件起始位置使用预处理指令，也就是 #ifndef，可以防止同一个头文件在一个 cpp 的include 链中被重复 include。<br>
2）头文件不做变量或者函数的定义，只做声明，定义放在cpp文件。</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/" class="post-title-link" itemprop="url">CentOS配置和下载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-22 19:24:38 / 修改时间：21:10:42" itemprop="dateCreated datePublished" datetime="2022-08-22T19:24:38+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>CentOS配置和下载</h1>
<h2 id="下载">下载</h2>
<h3 id="进入官网">进入官网</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.centos.org/</span><br></pre></td></tr></table></figure>
<h3 id="如图：">如图：</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_1.PNG" alt></p>
<h3 id="点击CentOS-Linux">点击CentOS Linux</h3>
<h3 id="如图：-2">如图：</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_2.png" alt></p>
<h3 id="点击x86-64后，链接随便选一个">点击x86/64后，链接随便选一个</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_3.png" alt></p>
<h2 id="问题">问题</h2>
<h3 id="1-虚拟机安装出现system-not-found">1.虚拟机安装出现system not found</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_5.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 打开虚拟机设置 -&gt; 设备状态 -&gt; 启动时连接</span><br></pre></td></tr></table></figure>
<h3 id="2-安装好后发现无法联网">2.安装好后发现无法联网</h3>
<p><img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_6.png" alt><br>
<img src="/2022/08/22/CentOS%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/CentOS_img_4.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 进入root账号</span><br><span class="line">2. 输入 `cd /etc/sysconfig/network-scripts`</span><br><span class="line">3. 输入 `vi ifcfg-ens34`</span><br><span class="line">4. 输入i, `ONBOOT=no`,改成 `ONBOOT=yes`, 输入`wq!`</span><br><span class="line">5. 重启服务 `systemctl restart network`</span><br><span class="line">6. 输入`ip addr`</span><br></pre></td></tr></table></figure>
<h2 id="配置">配置</h2>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/22/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">设计模式复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-22 15:31:43 / 修改时间：20:28:23" itemprop="dateCreated datePublished" datetime="2022-08-22T15:31:43+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计模式复习">设计模式复习</h2>
<h3 id="1-备忘录模式">1. 备忘录模式</h3>
<blockquote>
<p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
</blockquote>
<h4 id="例题：-2">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.某系统提供了用户信息操作模块，用户可以修改自己的各项信息。为了使操作过程更加人性化，可以使用（）对系统进行改进，使得用户在进行了错误操作之后可以恢复到操作之前的状态。</span><br></pre></td></tr></table></figure>
<h3 id="2-适配器模式">2.适配器模式</h3>
<blockquote>
<p>适配器模式（Adapter）通常适用于以下场景。<br>
以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。<br>
使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p>
</blockquote>
<h4 id="例题：-3">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.当已有类能满足目前的需求但和当前的系统兼容性比较差的情况下，比较适合使用（ ）</span><br></pre></td></tr></table></figure>
<h3 id="3-模板方法模式">3.模板方法模式</h3>
<blockquote>
<p>基本流程几乎一样采用模板方法模式</p>
</blockquote>
<h4 id="例题：-4">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.在银行办理业务时，一般都包含几个基本步骤，即取号排队、办理具体业务和对银行工作人员进行评分。无论具体业务是取款、存款还是转账，其基本流程都一样。可以使用（ ）模拟银行业务办理流程。</span><br></pre></td></tr></table></figure>
<h3 id="4-观察者模式">4. 观察者模式</h3>
<blockquote>
<p>观察者模式：定义对象之间的一种一对多的关系，当一个对象发生改变时，其他依赖于该对象的对象也会被通知自动改变。</p>
</blockquote>
<h4 id="例题：-5">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，应该使用何种设计模式：</span><br></pre></td></tr></table></figure>
<h3 id="5-命令模式">5.命令模式</h3>
<blockquote>
<p>命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志。</p>
</blockquote>
<h4 id="例题：-6">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.在设计中如果一个对象请求另一个对象调用其方法到达某种目的，而不和请求的对象直接打交道，这种模式是（ ）。</span><br></pre></td></tr></table></figure>
<h3 id="6-原型模式">6.原型模式</h3>
<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>
原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节。<br>
工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。<br>
它主要面对的问题是：“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。</p>
</blockquote>
<h4 id="例题：-7">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.（）模式的关键是将一个对象定义为原型，并为其提供复制自己的方法。 </span><br><span class="line">2. 以下哪个模式可以利用一个对象，快速地生成一批对象？（）</span><br></pre></td></tr></table></figure>
<h3 id="7-责任链模式">7.责任链模式</h3>
<blockquote>
<p>责任链模式是一种设计模式。<br>
在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。<br>
请求在这个链上传递，直到链上的某一个对象决定处理此请求。<br>
发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>
</blockquote>
<h4 id="例题：-8">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.某OA系统需要提供一个假条审批的模块，如果员工请假天数小于3天，主任可以审批该假条；如果员工请假天数大于等于3天，小于10天，经理可以审批；如果员工请假天数大于等于10天，小于30天，总经理可以审批；如果超过30天，总经理也不能审批，提示相应的拒绝信息。如果假条审批使用模式来进行设计，可以使用（）模式。</span><br></pre></td></tr></table></figure>
<h3 id="8-装饰者模式">8.装饰者模式</h3>
<blockquote>
<p>23种设计模式之一，英文叫Decorator Pattern，又叫装饰者模式。装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
</blockquote>
<h4 id="例题：-9">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.系统中的文本显示类（TextView）和图片显示类（PictureView）都继承了组件类（Component），分别显示文本和图片内容，现需要构造带有滚动条、或者带有黑色边框、或者既有滚动条又有黑色边框的文本显示控件和图片显示控件，但希望最多只增加三个类，（）设计模式可以实现该目的。</span><br></pre></td></tr></table></figure>
<h3 id="9-享元模式">9.享元模式</h3>
<blockquote>
<p>通过共享以便有效的支持大量细颗粒对象。</p>
</blockquote>
<h4 id="例题：-10">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 共享网络设备模拟：很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发。共享网络设备可以使用（）模拟共享网络设备的设计原理。</span><br></pre></td></tr></table></figure>
<h3 id="10-外观模式">10.外观模式</h3>
<blockquote>
<p>为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<h3 id="11-代理模式">11.代理模式</h3>
<blockquote>
<p>为其他对象提供一个代理以控制对这个对象的访问。</p>
</blockquote>
<h3 id="12-工厂方法模式">12.工厂方法模式</h3>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类。(工厂方法模式：客户必须清楚地指出想获取哪种产品；由接口的子类负责获取产品 )</p>
</blockquote>
<h3 id="13-访问者模式">13.访问者模式</h3>
<blockquote>
<p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某高校奖励审批系统可以实现教师奖励和学生奖励的审批(AwardCheck)，如果教师发表论文数超过10篇或者学生论文超过2篇可以评选科研奖，如果教师教学反馈分大于等于90分或者学生平均成绩大于等于90分可以评选成绩优秀奖。奖励审批系统可以使用（）设计该系统，以判断候选人集合中的教师或学生是否符合某种获奖要求。</span><br></pre></td></tr></table></figure>
<h3 id="14-单例模式">14.单例模式</h3>
<blockquote>
<p>单例对于不频繁创建和销毁的对象只会增加系统开支，因为它一直存在，但是对于频繁创建和销毁的却可以在一定程度上减少开支。</p>
</blockquote>
<h3 id="15-策略模式">15.策略模式</h3>
<blockquote>
<p>策略模式（Strategy）-定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<h3 id="16-建造者模式">16.建造者模式</h3>
<blockquote>
<p>建造者模式是设计模式的一种，又叫做生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<h4 id="例题：-11">例题：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.KFC套餐一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。可以使用（)描述KFC如何创建套餐。</span><br></pre></td></tr></table></figure>
<h3 id="17-简单工厂模式">17.简单工厂模式</h3>
<blockquote>
<p>当客户获取产品时，工厂模式作为获取产品的接口。由接口直接负责获取产品</p>
</blockquote>
<h3 id="18-简单工厂模式">18.简单工厂模式</h3>
<blockquote>
<p>抽象工厂模式：客户不知道其想获取哪种产品；由接口中判断调用哪个子类，通过子类获取产品。</p>
</blockquote>
<h3 id="19-桥接模式">19.桥接模式</h3>
<blockquote>
<p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低 抽象和实现这两个可变维度的耦合度。</p>
</blockquote>
<h3 id="20-组合模式">20.组合模式</h3>
<blockquote>
<p>将对象组合成树形结构以表示部分和整体的层次结构</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">模板与泛型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-11 08:31:21" itemprop="dateCreated datePublished" datetime="2022-08-11T08:31:21+08:00">2022-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-12 11:17:13" itemprop="dateModified" datetime="2022-08-12T11:17:13+08:00">2022-08-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>第十六章 模板和泛型编程</h1>
<ul>
<li>面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。
<ul>
<li>OOP能处理类型在程序运行之前都未知的情况；</li>
<li>泛型编程中，在编译时就可以获知类型。</li>
</ul>
</li>
</ul>
<h2 id="定义模板">定义模板</h2>
<ul>
<li><strong>模板</strong>：模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</li>
<li><strong>编写一个函数来比较两个值:</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string&amp; v1, <span class="type">const</span> string&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; v1, <span class="type">const</span> <span class="type">double</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两个函数基本相同，只有参数类型不同。</li>
<li><strong>可以修改为：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2) &#123;</span><br><span class="line">    if(v1 &lt; v2) return -1;</span><br><span class="line">    if(v2 &lt; v1) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>template后跟一个<code>模板参数列表(以逗号分隔的一个或多个模板参数的列表)</code>,例如：<code>template &lt;typename T1, typename T2&gt;</code></li>
<li>compare函数声明了<code>T类型参数</code>，T表示的实际类型则在编译时根据compare的使用情况确定。</li>
</ul>
<h2 id="实例化函数模板">实例化函数模板</h2>
<ul>
<li>模板类型参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// √，返回类型和参数类型一致</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ×，U之前必须加上class 或者 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// √，模板参数列表中，typename 和 class没有什么不同，typename更清楚的指出随后的是个类型名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">U</span>&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非类型模板参数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span><br><span class="line"><span class="comment">// 如果是（*p1) 就是数组指针，（&amp;p1)就是数组引用， &amp;p1[N] 引用数组， *p1[N]指针数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用compare(“h1”, “mom”)调用时，编译器使用字面常量大小代替N和M，用于实例化模板，编译器会在一个字符串后加个’\0’做为终结符。</li>
<li>即<code>int compare(const char (&amp;p1)[3]</code>, <code>const char (&amp;p2)[4]</code>。</li>
</ul>
<h2 id="inline-和-constexpr">inline 和 constexpr</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// √， inline 跟在模板参数列表后</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// ×，inline位置不正确</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="编写类型无关的代码">编写类型无关的代码</h2>
<ul>
<li>compare 说明了编写泛型代码的两个重要原则：
<ul>
<li>模板中的函数参数是const&amp;。</li>
<li>函数体的条件判断仅使用&lt;比较运算。</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数参数是const&amp;，保证函数可以用于不能拷贝的类型，如果compare用于处理大对象，可以使函数运行更快。<br>
只使用&lt;运算符，降低了compare对要处理的类型的要求。这些类型必须支持&lt;，但不必支持&gt;。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="comment">// 即使使用指针也正确的compare版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// C++ 提供的比较函数</span></span><br><span class="line">    <span class="comment">/// less&lt;type&gt;()    -&gt;   从小到大排序 &lt;</span></span><br><span class="line">    <span class="comment">/// grater&lt;type&gt;()  -&gt;   从大到小排序 &gt;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">less</span>&lt;T&gt;()(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">less</span>&lt;T&gt;()(v2, v1)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你认为接受一个数组实参的标准库函数begin和end是如何工作的？定义你自己版本的begin和end</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">Array* <span class="title">begin</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">Array* <span class="title">end</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr + N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写一个 constexpr 模版，返回给定数组的大小。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Array* <span class="title">begin</span><span class="params">(<span class="type">const</span> (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板">类模板</h2>
<blockquote>
<p>typedef -&gt; 取别名，typename（class) -&gt; 类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="comment">// C++语言默认情况下，假定通过作用域运算符访问的名字不是类型，所以当我们要访问的是类型时候，必须显示的告诉编译器这是一个类型</span></span><br><span class="line">    <span class="comment">// typedef创建了存在类型的别名，而typename告诉编译器std::vector&lt;T&gt;::size_type是一个类型而不是一个成员。</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="comment">// initializer_list对象中的元素是const&amp;,元素的类型一致</span></span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line">    <span class="comment">// Blob中的元素数目</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">pop_back</span>();</span><br><span class="line">    T&amp; <span class="built_in">back</span>();</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string&amp; msg) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在main函数中定义：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Blob&lt;<span class="type">int</span>&gt; ia;</span><br><span class="line">    Blob&lt;<span class="type">int</span>&gt; ia2 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ia和ia2使用特定类型版本的Blob<int>, 编译器会实例化出一个与下方定义等价的类：</int></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;<span class="type">int</span>&gt;::size_type size_type;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="comment">// initializer_list对象中的元素是const&amp;,元素的类型一致</span></span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;<span class="type">int</span>&gt; il);</span><br><span class="line">    <span class="comment">// Blob中的元素数目</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> &amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="type">int</span>&amp; <span class="built_in">back</span>();</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[] (size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string&amp; msg) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每当编译器从Blob模板实例化出一个类，会重写Blob模板，将模板参数T的每个实例替换为给定的模板实例，这里是int。</p>
</blockquote>
<h2 id="在模板作用域中引用模板类型">在模板作用域中引用模板类型</h2>
<ul>
<li>std::shared_ptr&lt;std::vector<T>&gt; data; data使用了两个模板 shared_ptr 和 vector。</T></li>
<li>使用了Blob类型参数来声明data是一个shared_ptr的实例，shared_ptr指向一个保存类型为T的对象的vector实例。</li>
<li>当我们实例化一个特定类型的Blob，例如：Blob<string> -&gt; std::shared_ptr&lt;std::vector<string>&gt; data。</string></string></li>
</ul>
<h2 id="类模板的成员函数">类模板的成员函数</h2>
<ul>
<li>一般类的成员函数  return-type A :: member-name(parm-list)</li>
<li>对应的Blob 成员：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">return-type Blob :: member-name(parm-list)</span><br></pre></td></tr></table></figure>
<h2 id="类的实现-通过编译">类的实现(通过编译)</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// constructors</span></span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of elements in the Blob</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span>      <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t)); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// element access</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span> [](size_type i) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">	<span class="comment">// throw msg if data[i] isn&#x27;t valid</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructors</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>() : <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) :</span><br><span class="line"><span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string &amp;msg) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Blob&lt;T&gt;::<span class="built_in">back</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span> [](size_type i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if i is too big, check function will throw, preventing access to a nonexistent element</span></span><br><span class="line">	<span class="built_in">check</span>(i, <span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span> [](size_type i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if i is too big, check function will throw, preventing access to a nonexistent element</span></span><br><span class="line">	<span class="built_in">check</span>(i, <span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Blob-Ptr类">Blob_Ptr类</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Blob.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> ==&lt;T&gt;</span><br><span class="line">	(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; &lt;T&gt;</span><br><span class="line">		(<span class="type">const</span> BlobPtr&lt;T&gt;&amp; lhs, <span class="type">const</span> BlobPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, std::<span class="type">size_t</span> sz = <span class="number">0</span>) :</span><br><span class="line">		<span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (*p)[curr];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prefix</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// postfix</span></span><br><span class="line">	BlobPtr <span class="keyword">operator</span> ++(<span class="type">int</span>);</span><br><span class="line">	BlobPtr <span class="keyword">operator</span> --(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// returns  a shared_ptr to the vector if the check succeeds</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt;</span><br><span class="line">		<span class="built_in">check</span>(std::<span class="type">size_t</span>, <span class="type">const</span> std::string&amp;) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">	std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;</span><br><span class="line">	std::<span class="type">size_t</span> curr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefix ++</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if curr already points past the end of the container, can&#x27;t increment it</span></span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot;increment past end of StrBlob&quot;</span>);</span><br><span class="line">	++curr;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefix --</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> --()</span><br><span class="line">&#123;</span><br><span class="line">	--curr;</span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot;decrement past begin of BlobPtr&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// postfix ++</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> ++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postfix --</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span> --(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BlobPtr&lt;T&gt; &amp;lhs, <span class="type">const</span> BlobPtr&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lhs.wptr.<span class="built_in">lock</span>() != rhs.wptr.<span class="built_in">lock</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ptrs to different Blobs!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lhs.i == rhs.i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> BlobPtr&lt;T&gt; &amp;lhs, <span class="type">const</span> BlobPtr&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lhs.wptr.<span class="built_in">lock</span>() != rhs.wptr.<span class="built_in">lock</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ptrs to different Blobs!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lhs.i &lt; rhs.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认模板实参">默认模板实参</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2, F f = <span class="built_in">F</span>()) &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(v1,v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(v2,v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制实例化">控制实例化</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>declaration是一个类或函数声明，将其中所有模板参数换成模板实参</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;; <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当编译器遇到extern模板声明时，不会在本文件中生成实例化代码。将一个实例化声明成extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义)。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
</blockquote>
<h2 id="remove-reference">remove_reference</h2>
<blockquote>
<p>我们可以使用remove_reference获取元素类型。remove_refrence&lt;decltype(*beg)&gt;::type</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_refrence&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用折叠">引用折叠</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img1.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img2.PNG" alt></p>
<ul>
<li>即 X&amp; &amp;（引用的引用）, X&amp; &amp;&amp; (引用的右值引用), X&amp;&amp; &amp;(右值引用的引用)都折叠成X&amp;（X的引用）</li>
<li>类型X&amp;&amp; &amp;&amp;（右值引用的右值引用）折叠成X&amp;&amp;(X的右值引用)</li>
</ul>
<h2 id="std-move">std::move</h2>
<ul>
<li>定义：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>move的函数参数T&amp;&amp;是一个指向模板类型参数的右值引用。通过引用折叠,此参数可以和任何类型的实参匹配。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">string s1(&quot;hi!&quot;), s2;</span><br><span class="line">// 传入string构造函数的右值结果，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型（&amp;）。</span><br><span class="line">// T -&gt; string</span><br><span class="line">// remove_reference用string实例化</span><br><span class="line">// remove_reference&lt;string&gt;::type -&gt; string</span><br><span class="line">// move 返回类型是string&amp;&amp;</span><br><span class="line">// move的函数参数t的类型为string&amp;&amp;</span><br><span class="line">// 即string&amp;&amp; move(string&amp;&amp; t)</span><br><span class="line">// static_cast&lt;string&amp;&amp;&gt;(t), 不需要转换。</span><br><span class="line">s2 = std::move(string(&quot;bye!&quot;)); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 传入一个左值,所以T是个引用</span><br><span class="line">// T -&gt; string&amp; </span><br><span class="line">// remove_reference用string&amp;实例化</span><br><span class="line">// remove_reference&lt;string&amp;&gt;::type -&gt; string</span><br><span class="line">// move 返回类型是string&amp;&amp;</span><br><span class="line">// move的函数参数t的类型为string&amp; &amp;&amp;,会折叠为string&amp;</span><br><span class="line">// 即string&amp;&amp; move(string&amp; t)</span><br><span class="line">//  static_cast&lt;string&amp;&amp;&gt;(t), t为string&amp;, cast将其转换为string&amp;&amp;</span><br><span class="line">s2 = std::move(s1);</span><br></pre></td></tr></table></figure>
<h2 id="转发">转发</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i); <span class="comment">// f改变了实参i</span></span><br><span class="line">    <span class="built_in">flip1</span>(f, j, <span class="number">42</span>); <span class="comment">// 通过flip1调用f不会改变实参j</span></span><br><span class="line">    cout &lt;&lt; j &lt;&lt; endl &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int,而非int&amp;。因此，flip1调用会实例化为<code>void flip1(void(*fcn)(int, int&amp;), int t1, int t2);</code><br>
j的值被copy到t1。f中的引用参数被绑定带t1,而非j,从而其改变不会影响j。</p>
</blockquote>
<ul>
<li>如果我们将函数参数定义成T1&amp;&amp; 和 T2&amp;&amp;, 通过引用折叠，就可以保存翻转实参的左值，右值属性。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>&amp;&amp; v1, <span class="type">int</span>&amp;&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i);</span><br><span class="line">    <span class="built_in">flip2</span>(f, j, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">flip2</span>(g, i, <span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img3.PNG" alt></p>
<h2 id="在调用中使用std-forward保持类型信息">在调用中使用std::forward保持类型信息</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(T &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传入右值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传入左值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp; &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也就是：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img4.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img5.PNG" alt></p>
<ul>
<li>最后实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>&amp;&amp; v1, <span class="type">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, i);</span><br><span class="line">    <span class="built_in">flip</span>(f, j, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">flip</span>(g, i, <span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写重载模板">编写重载模板</h2>
<ul>
<li>多个可行模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; string*</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T* t) T -&gt; string</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(&amp;s) &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> string* sp = &amp;s;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; string*</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T* t) T -&gt; const string</span></span><br><span class="line">    <span class="comment">// 调用更特例化版本string debug_rep(T* t)</span></span><br><span class="line">    <span class="comment">// 因为string debug_rep(const T&amp; t)本质上可以用于任何类型，后者只能用于指针类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(sp) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非模板和模板重载</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(s) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在本例中，两个函数具有相同的参数列表，因此，显然两者提供同样好的匹配。但是，编译器会选择非模板版本。当存在多个同样好的函数模板时，编译器选择最特例化的版本，处于相同的原因，一个非模板函数比一个函数模板更好。</p>
</blockquote>
<h2 id="重载模板和类型转换">重载模板和类型转换</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; t; <span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">    ostringstream ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer :&quot;</span> &lt;&lt; p; <span class="comment">// 打印指针本身</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">debug_rep</span>(*p); <span class="comment">// 打印指针指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果希望将字符指针按string处理,可以定义另外两个非模板重载版本</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">debug_rep</span>(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">debug_rep</span>(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const T&amp; t) T -&gt; char[10]</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(T *p) T -&gt; const char</span></span><br><span class="line">    <span class="comment">// 匹配string debug_rep(const string&amp; s) const char* 到 string 的转换</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变参数模板">可变参数模板</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;  ... rest)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl; <span class="comment">// 类型参数的数目</span></span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(rest) &lt;&lt; endl; <span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    string s = <span class="string">&quot;how now brown cow&quot;</span>;</span><br><span class="line">    <span class="built_in">foo</span>(i, s, <span class="number">42</span>, d);</span><br><span class="line">    <span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    <span class="built_in">foo</span>(d, s);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写可变参数函数模板">编写可变参数函数模板</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... rest)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>; <span class="comment">// 递归调用打印其他实参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, s = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">print</span>(cout, i, s, <span class="number">42</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包扩展">包扩展</h2>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img6.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img7.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img8.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img9.PNG" alt></p>
<h2 id="模板特例化">模板特例化</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个版本;可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 第二个版本；处理字符串字面常量</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有当传递给compare一个字符串字面常量或者一个数组时，编译器才会调用接受两个非类型模板参数的版本。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span>;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);        <span class="comment">// 调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);   <span class="comment">// 调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义函数模板特例化</li>
</ul>
<p><img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img10.PNG" alt><br>
<img src="/2022/08/11/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/template_img11.PNG" alt></p>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">访问控制与继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-10 10:52:54 / 修改时间：14:25:38" itemprop="dateCreated datePublished" datetime="2022-08-10T10:52:54+08:00">2022-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>C++ primer 第15章 面向对象程序设计</h1>
<h2 id="访问控制和继承">访问控制和继承</h2>
<p><img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img1.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img2.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img3.PNG" alt></p>
<blockquote>
<p>基类对象不能访问基类的peotected,private成员<br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_qx.jpg" alt></p>
</blockquote>
<p><img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img4.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img5.PNG" alt><br>
<img src="/2022/08/10/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/protected_img6.PNG" alt></p>
<blockquote>
<p>只有public继承的时候才能使用派生类向基类的转换</p>
</blockquote>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">2022-8-4面试整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-08 14:06:48" itemprop="dateCreated datePublished" datetime="2022-08-08T14:06:48+08:00">2022-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-11 10:28:30" itemprop="dateModified" datetime="2022-08-11T10:28:30+08:00">2022-08-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="算法题1：">算法题1：</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设有从小到大顺序排列，不一定连续但没有重复的整数序列A=&#123;a1, a2, a3,...am-1,am,am+1,...an-1,an&#125;,</span><br><span class="line">将该序列重新排列为B&#123;am,am+1,...an-1,an,a1,a2,...am-1&#125;。试给出一个程序从符合B序列的数组中找到a1的</span><br><span class="line">位置，要求算法复杂度&lt;O(N).</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这题我没有好好审题，一看a1，没有想到是求最小值，确实应该使用二分法</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">		<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (B[mid] &gt; B[right]) &#123;</span><br><span class="line">			<span class="comment">// 中间点要比右边界大，很有可能min值在中间点右边</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (B[mid] &lt; B[right]) &#123;</span><br><span class="line">			<span class="comment">// 中间点比右边界小，那最小值应该在中间值的左侧</span></span><br><span class="line">			right = mid;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			right -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">25</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; B = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func</span>(B);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法题2：">算法题2：</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现以下函数，中间不能调用其他任何标准库中的函数（返回一个指针指向第一次出现在字符串中的StrSearch)</span><br><span class="line">Returns a pointer to the first occurrence of strSearch in string</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* string, <span class="type">const</span> <span class="type">char</span>* strSearch, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (string[i] != strSearch[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* _strstr(<span class="type">const</span> <span class="type">char</span>* string, <span class="type">const</span> <span class="type">char</span>* strSearch) &#123;</span><br><span class="line">	<span class="type">int</span> len_str = <span class="built_in">strlen</span>(string);</span><br><span class="line">	<span class="type">int</span> len_compare = <span class="built_in">strlen</span>(strSearch);</span><br><span class="line">	<span class="keyword">if</span> (len_str &lt; len_compare) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* pos = string;</span><br><span class="line">	<span class="comment">// 去除&#x27;\0&#x27;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* pos_end = string + len_str - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos &lt;= pos_end - len_compare; pos++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">judge</span>(pos, strSearch, len_compare) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> pos;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> a[] = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, _strstr(a, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚函数程序题">虚函数程序题</h2>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> iValue;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">fun2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base fun2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pValue;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">fun2</span>();</span><br><span class="line">		Base::<span class="built_in">fun1</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived fun2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoreDerived</span> : <span class="keyword">public</span> Derived &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">double</span> dValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; endl	 </span><br><span class="line">		&lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; endl</span><br><span class="line">		&lt;&lt; <span class="built_in">sizeof</span>(MoreDerived) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Derived d;</span><br><span class="line"></span><br><span class="line">	Base&amp; rB = d;</span><br><span class="line">	rB.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Base* pB = &amp;d;</span><br><span class="line">	pB-&gt;<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下3种写法一样</span></span><br><span class="line">	pB = (Base*)&amp;d;</span><br><span class="line">	<span class="comment">// pB = &amp;d;</span></span><br><span class="line">	<span class="comment">// pB = &amp;(Base&amp;)d; // (Base)是个临时变量，而取地址符&amp;右边必须是左值，所以（Base&amp;)引用</span></span><br><span class="line">	pB-&gt;<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="首先要知道的知识">首先要知道的知识</h2>
<ol>
<li>字节对齐：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类的默认的对齐方式：规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。</span><br><span class="line">各成员变量在存放的时候根据在结构中出现的顺序依次申请空间结构的字节边界数。</span><br><span class="line">结构中占用最大空间的类型所占用的字节数的倍数。</span><br></pre></td></tr></table></figure>
<p>常用类型的对齐方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.	char 1的倍数</span><br><span class="line">2.	int 4的倍数</span><br><span class="line">3.	float 4的倍数</span><br><span class="line">4.	double 8的倍数</span><br><span class="line">5.	short 2的倍数</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>虚指针：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多态是由虚函数实现的，而虚函数主要通过虚函数表（V-Table） 来实现。</span><br><span class="line">虚函数表每一项存储的一个虚函数的地址。  </span><br><span class="line">类的每一个对象都会包含一个虚指针，这个虚指针指向虚函数表。</span><br><span class="line"></span><br><span class="line">在32位下，虚指针占4个字节，在64位下，虚指针占8个字节。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>C++ 对象的内存布局查看</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 打开vs2022自带的【x86 Native Tools Command Prompt for VS 2022】</span><br><span class="line">2. 转入到要调试的cpp目录下： 例如C:\\Users\\Administrator\\source\\repos\\test</span><br><span class="line">3. 输入cl -d1reportSingleClassLayoutXXX MMM.cpp 【xxx为类名，MMM是文件名】</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>左值和右值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">左值（L-value）：表示存储在计算机内存的对象，可寻址，相当于地址值</span><br><span class="line"></span><br><span class="line">右值（R-value）：代表的为真实值，可读，即数据值</span><br><span class="line"></span><br><span class="line">因为左值是一个地址值，因此可以对左值进行赋值操作，而右值本身就是同一个数据值，就不存在对一个数据值就行赋值的操作。</span><br><span class="line"></span><br><span class="line">int a,b;</span><br><span class="line">a=5;//为合法的操作，因为a是个地址值；</span><br><span class="line">b=a;//这个也是个合法操作，在这里b为地址值，a取其数据值即5(注意这里不是取地址值，因为a是作为一个右值)</span><br><span class="line">5=5;//这是一个非法操作，因为左值是个数据值，右值也是个数据值</span><br></pre></td></tr></table></figure>
<h2 id="开始调试">开始调试</h2>
<table>
<thead>
<tr>
<th><img src="/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/virtual_interview_img2.PNG" alt></th>
<th><img src="/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/virtual_interview_img3.PNG" alt="controller"></th>
<th><img src="/2022/08/08/2022-8-4%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/virtual_interview_img4.PNG" alt="Analysis"></th>
</tr>
</thead>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; sizeof(Base) &lt;&lt; endl	// 	虚指针8字节，int字节对齐=8 =》 16</span><br><span class="line">     &lt;&lt; sizeof(Derived) &lt;&lt; endl //  继承后pValue 字节对齐 + 8 =》 16 + 8 = 24</span><br><span class="line">	 &lt;&lt; sizeof(MoreDerived) &lt;&lt; endl; // 因为是static在静态区，不变还是24</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"></span><br><span class="line">Base&amp; rB = d;</span><br><span class="line">rB.fun1();	// 不管谁指向/引用谁，都是自动识别调子类自己的函数(调用被重写过的函数）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Base* pB = &amp;d;</span><br><span class="line">pB-&gt;fun1(); // 不管谁指向/引用谁，都是自动识别调子类自己的函数(调用被重写过的函数）</span><br><span class="line"></span><br><span class="line">pB = (Base*)&amp;d;</span><br><span class="line">//pB = &amp;(Base&amp;)d;</span><br><span class="line">// pB = &amp;d;</span><br><span class="line">pB-&gt;fun3(); // 强转后还是先调用被重写的函数，如果没有再往基类找</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/08/git%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/git%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">git使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-08 13:37:18 / 修改时间：14:04:20" itemprop="dateCreated datePublished" datetime="2022-08-08T13:37:18+08:00">2022-08-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>快速入门</h1>
<h2 id="1-找到要上传的文件夹（Win10">1. 找到要上传的文件夹（Win10)</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.1 右击出现 Git Bash Here</span><br><span class="line">1.2 配置好邮箱，用户名，密码</span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx&quot;</span><br><span class="line">git config --global user.password &quot;xxx&quot;</span><br></pre></td></tr></table></figure>
<h2 id="2-基本指令">2.基本指令</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 初始化git, 会出现.git的文件夹</span><br><span class="line">git init</span><br><span class="line">// 可加可不加</span><br><span class="line">git add README.md </span><br><span class="line">// git commit 命令将暂存区内容添加到本地仓库</span><br><span class="line">git commit -m &quot;first commit&quot; </span><br><span class="line">// 创建一个新的本地分支main, 不进行切换</span><br><span class="line">git branch -M main</span><br><span class="line">// 添加远程仓库地址</span><br><span class="line">git remote add origin https://github.com/Wilson-Xbort/test.git </span><br><span class="line">// 将本地的 main 分支推送到 origin 主机的 main 分支。</span><br><span class="line">git push -u origin main</span><br><span class="line">// 压缩成.bundle</span><br><span class="line">git bundle create xxx.bundle HEAD main</span><br><span class="line">// 验证校验是否合法</span><br><span class="line">git bundle verify ./xxx.bundle</span><br><span class="line">// 删除远程库</span><br><span class="line">git remote rm origin</span><br><span class="line">// 解压.bundle</span><br><span class="line">git clone xxx.bundle</span><br></pre></td></tr></table></figure>
<h2 id="3-error和解决方式">3. error和解决方式</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. error: failed to push some refs to &#x27;https://github.com/xxx/xxx.git&#x27;</span><br><span class="line">2. Git:nothing added to commit but untracked files present</span><br><span class="line">3. fatal: Updating an unborn branch with changes added to the index.</span><br></pre></td></tr></table></figure>
<h2 id="解决方法">解决方法</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add -A 或者 git add --all</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-xbort.github.io/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ico.jpg">
      <meta itemprop="name" content="Willson-Xbort">
      <meta itemprop="description" content="none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">虚函数复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-05 08:52:47" itemprop="dateCreated datePublished" datetime="2022-08-05T08:52:47+08:00">2022-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 20:03:10" itemprop="dateModified" datetime="2022-08-22T20:03:10+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>C++ primer 第15章 面向对象程序设计</h1>
<h1>虚函数</h1>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img1.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img2.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img3.PNG" alt></p>
<h2 id="final-和-override">final 和 override</h2>
<blockquote>
<p>final 不允许后续的其他类覆盖<br>
override 帮助编译器说明派生类中的虚函数</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img4.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img5.PNG" alt></p>
<h2 id="抽象基类-含有纯虚函数）">抽象基类(含有纯虚函数）</h2>
<blockquote>
<p>有纯虚函数的类才称之为抽象类</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img6.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img7.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img8.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img9.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img10.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img11.PNG" alt></p>
<h2 id="虚析构函数">虚析构函数</h2>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img12.PNG" alt><br>
<img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img13.PNG" alt></p>
<h2 id="重载和隐藏">重载和隐藏</h2>
<blockquote>
<p>同一作用域，那就是重载。不同作用域，那就是隐藏。</p>
</blockquote>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img14.PNG" alt></p>
<h1>虚继承</h1>
<h2 id="前置：">前置：</h2>
<blockquote>
<p>IO标准库的istream 和 ostream分别继承了base_ios的抽象基类。改抽象基类负责保存流的缓冲内容并管理流的条件状态。iostream是另外一个类，<br>
它从istream和ostream直接继承而来，可以同时读写流的内容。因为istream和ostream都继承自base_ios，所以iostream继承了base_ios两次，一次是通过<br>
istream，另一次通过ostream。<br>
在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了很多次，则派生类中将包含该类的多个子对象。<br>
这种默认的情况对某些形如iostream的类显然是行不通的。一个iostream对象肯定希望在同一个缓冲区中进行读写操作，也会要求条件状态能同时反映输入和输出操作的情况。<br>
加入在iostream对象中真的包含了base_ios的两份拷贝，则上述的共享行为就无法实现。</p>
</blockquote>
<h2 id="实现：">实现：</h2>
<h3 id="如图：-3">如图：</h3>
<p><img src="/2022/08/05/%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/virtual_img15.PNG" alt></p>
<blockquote>
<p>对于Panda进行修改，使其同时继承Raccoon科和Bear科，此时，为了避免赋予Panda两份ZooAnimal的子对象，我们将Bear和Raccoon继承ZooAnimal的方式定义为虚继承。</p>
</blockquote>
<h3 id="使用虚基类：">使用虚基类：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码我们将ZooAnimal定义为Raccoon和Bear的虚基类。<br>
virtual说明符表面了一种愿望，即在后续派生类中共享虚基类的同一份实例。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span> : <span class="keyword">public</span> Bear,</span><br><span class="line">			  <span class="keyword">public</span> Raccoon, <span class="keyword">public</span> Endangered&#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Panda通过Raccoon和Bear继承了ZooAnimal,因为Raccoon和Bear继承ZooAnimal的方式都是虚继承，所以Panda中只有一个ZooAnimal基类部分。</p>
</blockquote>
<h3 id="构造函数和虚继承">构造函数和虚继承</h3>
<blockquote>
<p>在虚派生中，虚基类是由最底层的派生类初始化的。<br>
只要我们能创建虚基类的派生类对象(Bear/Raccoon),该派生类的构造函数就必须初始化它的虚基类。当创建一个Bear/Raccoon对象时，它已经位于派生的最底层，因此<br>
Bear/Raccoon的构造函数将直接初始化其ZooAnimal基类部分</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bear::<span class="built_in">Bear</span>(std::string name, <span class="type">bool</span> onExhibit):</span><br><span class="line">	<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Bear&quot;</span>) &#123; &#125;</span><br><span class="line">Raccoon::<span class="built_in">Raccoon</span>(std::string name, <span class="type">bool</span> onExhibit):</span><br><span class="line">	<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Raccoon&quot;</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而当创建一个Panda对象时，Panda位于派生类的最底层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Panda::<span class="built_in">Panda</span>(std::string name, <span class="type">bool</span> onExhibit)</span><br><span class="line">	:<span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Panda&quot;</span>),</span><br><span class="line">	<span class="built_in">Bear</span>(name, onExhibit),</span><br><span class="line">	<span class="built_in">Raccoon</span>(name, onExhibit),</span><br><span class="line">	<span class="built_in">Endangered</span>(Endangered::critical),</span><br><span class="line">	<span class="built_in">sleeping_flag</span>(<span class="literal">false</span>) &#123; .. &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。</span><br><span class="line">2. 接下来构造Bear部分</span><br><span class="line">3. 构造Raccoon部分</span><br><span class="line">4. 构造第三直接基类Endangered</span><br><span class="line">5. 最后构造Panda部分</span><br><span class="line"></span><br><span class="line">如果Panda没有显示地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <!-- after add -->
    
       <!-- after add finish -->
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Willson-Xbort"
      src="/images/ico.jpg">
  <p class="site-author-name" itemprop="name">Willson-Xbort</p>
  <div class="site-description" itemprop="description">none</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wilson-xbort" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wilson-xbort" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Willson-Xbort</span>

  <!-- after add-->
  <!---->
</div>





        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
